public void add mapper ( mapper mapper ) { if ( this . mapper ! = null ) { throw new build exception ( `` can not define more than one mapper `` ) ; } this . mapper = mapper ; }
public mime type get mime type ( ) { return mime type ; }
public mime type get mime type ( ) { return mime type ; }
public string [ ] get command ( ) { return command ; }
public string get command ( ) { return cmd ; }
public file get file ( ) { return file ; }
public term [ ] get sub term ( ) { return sub ; }
public boolean be mime type equal ( string mime type ) { mime type mt = null ; try { if ( mime object == null ) mime object = new mime type ( this . mime type ) ; mt = new mime type ( mime type ) ; } catch ( mime type parse exception e ) { } return mime object . match ( mt ) ; }
public int size ( ) { return size ; }
public enumeration < string > get parameter name ( ) { parse parameter ( ) ; return collection . enumeration ( parameter . key set ( ) ) ; }
public type get type ( ) { return type ; }
public input stream open input stream ( ) throw i o exception { return new block input stream ( ) ; }
public int size ( ) { return size ; }
public agroal connection pool configuration supplier initial size ( int size ) { check lock ( ) ; initial size = size ; return this ; }
public string get file path ( ) { return file path ; }
public class force load system class ( string classname ) throw class not find exception { log ( `` force system load `` + classname , project . msg_debug ) ; class the class = find loaded class ( classname ) ; if ( the class == null ) { the class = find base class ( classname ) ; } return the class ; }
public class force load class ( string classname ) throw class not find exception { log ( `` force load `` + classname , project . msg_debug ) ; class the class = find loaded class ( classname ) ; if ( the class == null ) { the class = find class ( classname ) ; } return the class ; }
public static class get class ( class loader class loader , string class name ) throw class not find exception { return get class ( class loader , class name , true ) ; }
public throwable get exception ( ) { return exception ; }
public static final string get ( final string property , final string def ) { try { return system . get property ( property , def ) ; } catch ( security exception se ) { return def ; } }
public task type get task type ( ) { return task id . get task type ( ) ; }
public void set output ( print stream out ) { }
public string get message ( ) { return message ; }
public static file get plugins home ( ) { return plugins home ; }
public synchronize void set excludes ( string excludes ) { if ( be reference ( ) ) { throw too many attribute ( ) ; } default pattern . set excludes ( excludes ) ; directory scanner = null ; }
public synchronize boolean be case sensitive ( ) { return ( be reference ( ) ) ? get ref ( get project ( ) ) . be case sensitive ( ) : case sensitive ; }
public synchronize void set excludes ( string excludes ) { if ( be reference ( ) ) { throw too many attribute ( ) ; } default pattern . set excludes ( excludes ) ; directory scanner = null ; }
public string get include ( ) { return include ; }
public void set include ( string [ ] include ) { if ( include == null ) { this . include = null ; } else { this . include = new string [ include . length ] ; for ( int i = 0 ; i < include . length ; i++ ) { string pattern ; pattern = include [ i ] . trim ( ) . replace ( '/ ' , file . separator char ) . replace ( '\\ ' , file . separator char ) ; if ( pattern . end with ( file . separator ) ) { pattern += `` * * `` ; } this . include [ i ] = pattern ; } } }
public file get file ( ) { return file ; }
public list < action > get action ( ) { return new array list < action > ( ) ; }
public static void read fully ( input stream in , byte [ ] b ) throw i o exception { read fully ( in , b , 0 , b . length ) ; }
public void set parameter ( string parameter ) { assert . have text ( parameter , `` parameter name can not be empty or null `` ) ; this . parameter = parameter ; }
public reader chain ( final reader rdr ) { prefix line new filter = new prefix line ( rdr ) ; new filter . set prefix ( get prefix ( ) ) ; new filter . set initialized ( true ) ; return new filter ; }
public parser configuration set tab size ( int tab size ) { this . tab size = tab size ; return this ; }
public reader chain ( final reader rdr ) { expand property new filter = new expand property ( rdr ) ; new filter . set project ( get project ( ) ) ; return new filter ; }
public reader chain ( final reader rdr ) { expand property new filter = new expand property ( rdr ) ; new filter . set project ( get project ( ) ) ; return new filter ; }
public void add filter set ( filter set filter set ) { filter set . add element ( filter set ) ; }
public stack get stack ( ) { return stack ; }
public void set target ( string target to add ) { if ( target to add . equal ( `` `` ) ) { throw new build exception ( `` target attribute must not be empty `` ) ; } target . add ( target to add ) ; target attribute set = true ; }
public least square builder target ( final real vector new target ) { this . target = new target ; return this ; }
protect string get request detail ( ) { string builder sb = new string builder ( ) ; sb . append ( this . request . size ( ) ) . append ( `` request ( s ) execute `` ) ; if ( ! this . request . be empty ( ) ) { sb . append ( `` : \n `` ) ; for ( client http request request : this . request ) { sb . append ( request . to string ( ) ) . append ( `` \n `` ) ; } } else { sb . append ( `` . \n `` ) ; } return sb . to string ( ) ; }
public void set date format ( string date format ) { super . set internal date format ( new simple date format ( date format ) ) ; }
public static void init ( ) { }
public string get ref log message ( ) { return destination . get ref log message ( ) ; }
public static void log event ( final structure data message msg , final level level ) { logger . log if enable ( fqcn , level , event_marker , msg , null ) ; }
public static string replace property ( project project , string value , hashtable key ) throw build exception { property helper ph = property helper . get property helper ( project ) ; return ph . replace property ( null , value , key ) ; }
public string get current base ( ) { return base . to string ( ) ; }
public synchronize void register thread task ( thread thread , task task ) { if ( task ! = null ) { thread task . put ( thread , task ) ; thread group task . put ( thread . get thread group ( ) , task ) ; } else { thread task . remove ( thread ) ; thread group task . remove ( thread . get thread group ( ) ) ; } }
public void copy file ( string source file , string d file , filter set collection filter , boolean overwrite ) throw i o exception { copy file ( new file ( source file ) , new file ( d file ) , filter , overwrite , false ) ; }
public set < string > get reference string ( ) { return reference string ; }
public @ not null thread get thread ( ) { return thread ; }
public project get project ( ) { return project ; }
public void set project ( project project ) { this . project = project ; }
public string get import simple name ( ) { if ( be import on demand ) { return null ; } string import name = get import name ( ) ; return import name . substring ( import name . last index of ( ' . ' ) + 1 ) ; }
public string replace property ( string value ) throw build exception { property helper ph = property helper . get property helper ( this ) ; return ph . replace property ( null , value , null ) ; }
public string get property ( string property name ) { object o = property . get ( property name ) ; return o instanceof string ? ( string ) o : null ; }
public void add child ( unknown element child ) { if ( child == null ) { child = new array list ( ) ; } child . add ( child ) ; }
public synchronize void add child ( runtime configurable child ) { child = ( child == null ) ? new array list ( ) : child ; child . add ( child ) ; }
public list < condition > get condition ( ) { return condition ; }
public string get description ( ) { return description ; }
public void set proxy ( web proxy proxy ) { this . proxy = proxy ; }
public int get port ( ) { return this . port ; }
public char [ ] get password ( string name ) throw i o exception { char [ ] pas = null ; pas = get password from credential provider ( name ) ; if ( pas == null ) { pas = get password from config ( name ) ; } return pas ; }
public void set d ( file dest ) { d dir = dest ; }
public j package _package ( string name ) { j package p = package . get ( name ) ; if ( p == null ) { p = new j package ( name , this ) ; package . put ( name , p ) ; } return p ; }
public void set target type ( class < ? > target type ) { assert . not null ( target type , `` 'target type ' must not be null `` ) ; this . target type = target type ; }
public void add propertyset ( property set p ) { property set . add element ( p ) ; }
public static string remove path ( final string filepath ) { return remove path ( filepath , file . separator char ) ; }
public void set file ( file file ) { this . file = file ; }
public string get format ( ) { return format ; }
public void set skip empty filesets ( boolean skip ) { skip empty = skip ; }
public version get version ( ) { return version ; }
public static long length ( final boolean [ ] [ ] array ) { final int length = array . length ; return length == 0 ? 0 : start ( length - 1 ) + array [ length - 1 ] . length ; }
public void set file ( file file ) { this . file = file ; }
public void set available ( long available ) { long old available = this . available ; if ( available > system . current time millis ( ) ) this . available = available ; else this . available = 0l ; support . fire property change ( `` available `` , long . value of ( old available ) , long . value of ( this . available ) ) ; }
protected list < i document partition listener > get document partition listener ( ) { return a list ( f document partition listener ) ; }
public void set system ( string system ) { this . system = system ; } // -- void set system ( string )
public void set name ( string name ) { this . name = name ; }
public void set property ( string property ) { this . property = property ; }
protect void set feature if support ( string feature , boolean value ) { try { get xml reader ( ) . set feature ( feature , value ) ; } catch ( s a x not recognize exception e ) { log ( `` not recognizied : `` + feature , project . msg_verbose ) ; } catch ( s a x not support exception e ) { log ( `` not support : `` + feature , project . msg_verbose ) ; } }
public void set file ( file file ) { this . file = file ; }
public void add filter set ( filter set filter set ) { filter set . add element ( filter set ) ; }
public void add mapper ( mapper mapper ) { if ( this . mapper ! = null ) { throw new build exception ( `` can not define more than one mapper `` ) ; } this . mapper = mapper ; }
public string get encode ( ) { return encode ; }
public file get d ( ) { return this . dest ; }
public void set dir ( string d ) { this . dir = get project ( ) . resolve file ( d ) ; }
public path get path ( ) { return path ; }
public file get file ( ) { return file ; }
public string get public i d ( ) { return public i d ; }
public void add srcfiles ( final file set f ) { source file set . add element ( f ) ; }
public void set property ( string property ) { this . property = property ; }
public mime type get mime type ( ) { return mime type ; }
public boolean be attachment ( object value ) { return attachment utils . be attachment ( value ) ; }
public string get include ( ) { return include ; }
public void set subject ( string subject ) throw exception { this . get property bag ( ) . set object from property definition ( item schema . subject , subject ) ; }
public charset charset ( ) { return charset ! = null ? charset . for name ( charset ) : null ; }
public void set d dir ( file d dir ) { this . d dir = d dir ; }
public activation o s get os ( ) { return this . o ; } // -- activation o s get os ( )
public output < string > output ( ) { return output ; }
public int get fail ( ) { return fail ; }
public process get process implementation ( ) { if ( process implementation == null & & process implementation class name ! = null ) { synchronize ( this ) { if ( process implementation == null & & process implementation class name ! = null ) { process implementation = classloading utility . load and instantiate class ( process . class , process implementation class name , null ) ; } } } return process implementation ; }
public void set output print stream ( print stream output ) { this . out = new print stream ( output , true ) ; }
public void set type ( int type ) { this . type = type ; }
public static rev filter create ( int skip ) { if ( skip < 0 ) throw new illegal argument exception ( j git text . get ( ) . skip must be non negative ) ; return new skip rev filter ( skip ) ; }
public boolean get search forward ( ) { return forward ; }
public void set overwrite ( boolean overwrite ) { my copy . set overwrite ( overwrite ) ; }
public boolean be final ( ) { return this == final ; }
public synchronize build exception get build exception ( ) { return build exception ; }
public long get timestamp ( ) { return timestamp ; }
public void init ( filter config config ) throw servlet exception { this . config = config ; this . init ( ) ; }
public path get classpath ( ) { return classpath ; }
public static int remove specific perm ( int perm , int remove ) { return perm ^ remove ; }
public void set jar ( string jar ) { set ( job context . jar , jar ) ; }
public line string get line ( ) { return line ; }
public list < format error > get error ( ) { return error ; }
public void set classname ( string classname ) { this . classname = classname ; }
public sys property get system property ( ) { return sys property ; }
public boolean be compile ( ) { return this . compile ; }
public path get bootclasspath ( ) { return bootclasspath ; }
public string get include ( ) { return include ; }
public file get dir ( ) { return this . dir ; }
public boolean accept ( final file file ) { if ( file . be directory ( ) ) { final file [ ] file = file . list file ( ) ; return i o utils . length ( file ) == 0 ; } return file . length ( ) == 0 ; }
protect string [ ] preprocess compiler args ( string [ ] compiler args ) { return filter jvm compiler args ( compiler args ) ; }
public static void move directory to directory ( final file src , final file d dir , final boolean create d dir ) throw i o exception { validate move parameter ( src , d dir ) ; if ( ! d dir . be directory ( ) ) { if ( d dir . exists ( ) ) { throw new i o exception ( `` destination ' `` + d dir + `` ' be not a directory `` ) ; } if ( ! create d dir ) { throw new file not find exception ( `` destination directory ' `` + d dir + `` ' do not exist [ create d dir= `` + false + `` ] `` ) ; } mkdirs ( d dir ) ; } move directory ( src , new file ( d dir , src . get name ( ) ) ) ; }
public void set access ( string value ) { this . access = value ; }
public void set margin bottom ( int margin bottom ) { set property value ( new escher simple property ( escher property . text__textbottom , margin bottom ) ) ; }
public float get b ( ) { return b ; }
public float get b ( ) { return b ; }
protect void add arg ( commandline java cmd , string argument ) { if ( argument ! = null & & argument . length ( ) ! = 0 ) { cmd . create argument ( ) . set value ( argument ) ; } }
public void set password ( string password ) { this . password = password ; }
public long get length ( ) { return length ; }
public void set classpath ( path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } }
public void set name ( string name ) { this . name = name ; }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public static boolean be array ( object obj ) { return ( obj ! = null & & obj . get class ( ) . be array ( ) ) ; }
public void set property ( string property ) { this . property = property ; }
public void add and ( and selector selector ) { append selector ( selector ) ; }
public void add all ( block list < t > src ) { if ( src . size == 0 ) return ; int src dir idx = 0 ; for ( ; src dir idx < src . tail dir idx ; src dir idx++ ) add all ( src . directory [ src dir idx ] , 0 , block_size ) ; if ( src . tail blk idx ! = 0 ) add all ( src . tail block , 0 , src . tail blk idx ) ; }
public condition factory poll interval ( duration poll interval ) { return new condition factory ( alias , timeout , poll interval , poll delay , catch uncaught exception , condition evaluation listener ) ; }
public task type get task type ( ) { return task id . get task type ( ) ; }
protect void rollover ( file old file , file backup file , file new file ) { }
public file get directory ( ) { return builder . directory ( ) ; }
public mapper create mapper ( ) throw build exception { if ( mapper element ! = null ) { throw new build exception ( `` can not define more than one mapper `` , get location ( ) ) ; } mapper element = new mapper ( get project ( ) ) ; return mapper element ; }
public void set file ( file file ) { this . file = file ; }
public url get url ( ) { return url ; }
public string get ref ( ) { return ref ; }
public void set classpath ref ( reference ref ) { if ( be reference ( ) ) { throw too many attribute ( ) ; } create classpath ( ) . set refid ( ref ) ; }
public url get url ( ) { return url ; }
public string get event ( ) { return event ; }
public list < format error > get error ( ) { return error ; }
public print stream get error output ( ) { return error output ; }
public void set replace instanceof ( final boolean replace ) { f instanceof= replace ; }
public static string get element content ( final element element ) throw exception { return get element content ( element , null ) ; }
public static i o file filter a file filter ( file filter filter ) { return new delegate file filter ( filter ) ; }
public static boolean be available ( ) { return get rmic class ( ) ! = null ; }
public void set rmic ( final rmic attribute ) { this . attribute = attribute ; mapper = new rmic file name mapper ( ) ; }
public path create compiler classpath ( ) { return facade . get implementation classpath ( get project ( ) ) ; }
public boolean be final ( ) { return this == final ; }
public synchronize object get target ( ) throw exception { if ( this . lazy target == null ) { logger . debug ( `` initialize lazy target object `` ) ; this . lazy target = create object ( ) ; } return this . lazy target ; }
public void set fail on teardown error ( boolean fail on teardown error ) { this . fail on teardown error = fail on teardown error ; }
public void set expand entity ( final boolean expand ) { this . expand = expand ; engine = null ; }
public void set escape char ( char escape char ) { this . escape char = escape char ; }
public void add propertyset ( property set p ) { property set . add element ( p ) ; }
public void add ( resource collection rc ) { resource . add ( rc ) ; }
public boolean get overwrite ( ) { return m overwrite ; }
public void set mode ( string mode ) { this . mode = mode ; }
public void set dir ( string d ) { this . dir = get project ( ) . resolve file ( d ) ; }
public void add ( resource collection rc ) { get buildpath ( ) . add ( rc ) ; }
public file get file ( ) { return f file ; }
public final void set max wait millis ( final long max wait millis ) { this . max wait = duration . of millis ( max wait millis ) ; }
public void clean up ( ) { }
public void set dir ( file directory ) { this . directory = directory ; }
public static string replace special character ( string file name parameter ) { string file name = file name parameter ; if ( file name == null || file name . length ( ) == 0 ) { return file name ; } for ( char element : special_characters ) { file name = file name . replace ( element , char_replacement ) ; } return file name ; }
public string get catalog name ( ) { return this . catalog name ; }
public string get output ( ) { return output ; }
public void set compress ( boolean compress ) { do compress = compress ; }
protect void set base u r i ( parse u r i base u r i ) { this . base u r i = base u r i ; }
public synchronize void set include ( string include ) { check attribute allow ( ) ; default pattern . set include ( include ) ; ds = null ; }
public static string [ ] get default excludes ( ) { return ( string [ ] ) default excludes . to array ( new string [ default excludes . size ( ) ] ) ; }
public synchronize void set include ( string include ) { if ( be reference ( ) ) { throw too many attribute ( ) ; } default pattern . set include ( include ) ; directory scanner = null ; }
public synchronize boolean be case sensitive ( ) { return be case sensitive ; }
public sort set selector . type get selector ( ) { return selector ; }
public void set pattern ( string pattern ) { f pattern= pattern ; }
public path get classpath ( ) { return classpath ; }
public u r i builder add parameter ( iterable < query param > new params ) { if ( ! new params . iterator ( ) . have next ( ) ) { return this ; } query params update = this . parameter . add ( new params ) ; return with parameter ( update ) ; }
public void set mode ( string mode ) { this . mode = mode ; }
public int get dir mode ( project p ) { if ( be reference ( ) ) { return ( ( archive file set ) get ref ( p ) ) . get dir mode ( p ) ; } return dir mode ; }
public int get file mode ( project p ) { if ( be reference ( ) ) { return ( ( archive file set ) get ref ( p ) ) . get file mode ( p ) ; } return file mode ; }
public string get name ( ) { return to string ( ) ; }
public select set from clause ( string from clause ) { this . from clause = from clause ; this . guesstimate buffer size += from clause . length ( ) ; return this ; }
public commandline java . sys property get sys property ( ) { return get command line ( ) . get system property ( ) ; }
public void verify ( ) { check shadow ( ) ; check parent contract ( ) ; check parent consistency ( ) ; check modifier ( ) ; check assignment contract ( ) ; check contract ct scanner ( ) ; check bound and unbound type reference ( ) ; check model be tree ( ) ; check contract ct scanner ( ) ; check element be contain in attribute of it parent ( ) ; check element to path to element equivalence ( ) ; check role in parent ( ) ; check java identifier ( ) ; }
public string to string ( ) { return get i d ( ) ; }
public string get file name ( ) { return file name ; }
public void add filter set ( filter set filter set ) { filter set . add element ( filter set ) ; }
public static i o file filter a file filter ( file filter filter ) { return new delegate file filter ( filter ) ; }
public line string get line ( ) { return line ; }
public filter set create filter set ( ) { filter set filter set = new filter set ( ) ; filter set . add element ( filter set ) ; return filter set ; }
public void add mapper ( mapper mapper ) { if ( this . mapper ! = null ) { throw new build exception ( `` can not define more than one mapper `` ) ; } this . mapper = mapper ; }
public void set classpath ref ( reference r ) { create classpath ( ) . set refid ( r ) ; }
public void set classpath ref ( reference r ) { create classpath ( ) . set refid ( r ) ; }
public string get prefix ( ) { return prefix ; }
public void set property set ( property set property set ) { this . property set = property set ; }
public string [ ] get pattern ( ) { return pattern ; }
public int hash code ( ) { return to string ( ) . hash code ( ) ; }
public void set mode ( string mode ) { this . mode = mode ; }
public archive command archive ( ) { return new archive command ( repo ) ; }
public file get directory ( ) { return builder . directory ( ) ; }
public void set resource ( resource resource ) { this . resource = resource ; }
public void set exists ( string exists ) { this . exist = exists ; } // -- void set exists ( string )
public string get include ( ) { return include ; }
protect void slow scan ( ) { if ( have slow result ) { return ; } string [ ] excl = new string [ dirs exclude . size ( ) ] ; dirs exclude . copy into ( excl ) ; string [ ] not incl = new string [ dirs not include . size ( ) ] ; dirs not include . copy into ( not incl ) ; for ( string an excl : excl ) { if ( ! could hold include ( an excl ) ) { scandir ( new file ( basedir , an excl ) , an excl + file . separator , false ) ; } } for ( string a not incl : not incl ) { if ( ! could hold include ( a not incl ) ) { scandir ( new file ( basedir , a not incl ) , a not incl + file . separator , false ) ; } } have slow result = true ; }
public static string [ ] get default excludes ( ) { return ( string [ ] ) default excludes . to array ( new string [ default excludes . size ( ) ] ) ; }
public string get pattern ( project p ) { init ( p ) ; if ( be reference ( ) ) { return get ref ( p ) . get pattern ( p ) ; } set pattern ( ) ; return regexp . get pattern ( ) ; }
public synchronize void add ( resource collection c ) throw build exception { if ( be reference ( ) ) { throw no child allow ( ) ; } if ( nested ! = null ) { throw new build exception ( `` only one resource collection can be `` + `` nest into mappedresources `` , get location ( ) ) ; } set checked ( false ) ; cache coll = null ; nest = c ; }
public static < t > t check not null ( t reference ) { if ( reference == null ) { throw new null pointer exception ( ) ; } return reference ; }
public void set size ( long size ) { this . size = size ; }
public long size ( ) { return size ; }
public string get value ( ) { return value ; }
public object get result ( ) { return result ; }
public string get u r l ( ) { return service . get u r l ( ) ; }
public file get file ( ) { return file ; }
public boolean be select ( file basedir , string filename , file file ) { return be select ( basedir , filename , file . get absolute path ( ) ) ; }
public string get expression ( ) { return expression ; }
public void verify setting ( ) { if ( contain == null ) { set error ( `` the text attribute be require `` ) ; } }
public void verify setting ( ) { if ( user provide expression == null ) { set error ( `` the expression attribute be require `` ) ; } }
public date time with millis ( long new millis ) { return ( new millis == get millis ( ) ? this : new date time ( new millis , get chronology ( ) ) ) ; }
public string get classname ( ) { return classname ; }
public void set file ( file file ) { this . file = file ; }
public boolean be equal ( final string name ) { return this . name ( ) . equal ignore case ( name ) ; }
public boolean be select ( file basedir , string filename , file file ) { validate ( ) ; enumeration e = selector element ( ) ; boolean result ; while ( e . have more element ( ) ) { result = ( ( file selector ) e . next element ( ) ) . be select ( basedir , filename , file ) ; if ( ! result ) { return false ; } } return true ; }
public void set ( boolean value ) { this . value = value ; }
public final void set parameter ( final parameter [ ] parameter ) { this . parameter = parameter ; set initialize ( false ) ; }
public void sub build finish ( build event event ) { if ( event . get project ( ) == get project ( ) ) { cleanup ( ) ; } }
public void set algorithm ( io . vertx . ext . auth . mongo . hash algorithm algorithm ) { delegate . set algorithm ( algorithm ) ; }
public boolean be valid ( string value ) { return be valid ( value , ( string ) null , ( locale ) null ) ; }
public void put field ( string key , string value ) { this . field . put ( key , value ) ; }
public void set classname ( string classname ) { this . classname = classname ; }
public static user user ( string name ) { return user ( name ( name ) ) ; }
public < t1 , t2 > multi item combine2 < t1 , t2 > stream ( publisher < ? extend t1 > a , publisher < ? extend t2 > b ) { return new multi item combine2 < > ( arrays . a list ( non null ( a , `` a `` ) , non null ( b , `` b `` ) ) ) ; }
public string get name ( ) { return tag name ; }
public synchronize void add child ( runtime configurable child ) { child = ( child == null ) ? new array list ( ) : child ; child . add ( child ) ; }
public task type get task type ( ) { return task id . get task type ( ) ; }
public void set compliance ( string input ) { string ignore = cmd . add option ( null , compliance_inputs , input ) ; if ( null ! = ignore ) { ignore ( ignore ) ; } }
public void add ( file name mapper file name mapper ) { if ( be reference ( ) ) { throw no child allow ( ) ; } if ( container == null ) { if ( type == null & & classname == null ) { container = new composite mapper ( ) ; } else { file name mapper m = get implementation ( ) ; if ( m instanceof container mapper ) { container = ( container mapper ) m ; } else { throw new build exception ( string . value of ( m ) + `` mapper implementation do not support nested mapper ! `` ) ; } } } container . add ( file name mapper ) ; }
public second to standard second ( ) { check year and month ( `` second `` ) ; long second = get millis ( ) / date time constant . millis_per_second ; second = field utils . safe add ( second , get second ( ) ) ; second = field utils . safe add ( second , ( ( long ) get minute ( ) ) * ( ( long ) date time constant . seconds_per_minute ) ) ; second = field utils . safe add ( second , ( ( long ) get hour ( ) ) * ( ( long ) date time constant . seconds_per_hour ) ) ; second = field utils . safe add ( second , ( ( long ) get day ( ) ) * ( ( long ) date time constant . seconds_per_day ) ) ; second = field utils . safe add ( second , ( ( long ) get week ( ) ) * ( ( long ) date time constant . seconds_per_week ) ) ; return second . second ( field utils . safe to int ( second ) ) ; }
protect void compute time ( ) { boolean unset year = ! be set ( year ) ; if ( unset year ) set ( year , get default year ( ) ) ; try { super . compute time ( ) ; } finally { if ( unset year ) clear ( year ) ; } }
public static url create u r l ( string path ) throw malformed u r l exception { return new url ( generate u r l ( path ) ) ; }
public void copy file ( string source file , string d file , boolean filtering , boolean overwrite ) throw i o exception { file_utils . copy file ( source file , d file , filter ? global filter : null , overwrite ) ; }
public file entry get parent ( ) { return parent ; }
public void set variable time ( long time ) { }
public input stream get input stream ( ) throw i o exception { return new reader input stream ( reader ) ; }
public file get dir ( ) { return this . dir ; }
public static boolean be absolute ( string file name ) { return file path . get ( file name ) . be absolute ( ) ; }
public pc to near pc ( int line ) { int n = table length ( ) ; int near pc = 0 ; int distance = 0 ; if ( n > 0 ) { distance = line number ( 0 ) - line ; near pc = start pc ( 0 ) ; } for ( int i = 1 ; i < n ; ++i ) { int d = line number ( i ) - line ; if ( ( d < 0 & & d > distance ) || ( d > = 0 & & ( d < distance || distance < 0 ) ) ) { distance = d ; near pc = start pc ( i ) ; } } pc res = new pc ( ) ; re . index = near pc ; re . line = line + distance ; return res ; }
public static class loader context class loader ( ) { return thread . current thread ( ) . get context class loader ( ) ; }
public void close ( ) throw i o exception { if ( in ! = null & & in ! = system . in ) { in . close ( ) ; } }
public boolean have flag ( property definition flag flag ) { return this . have flag ( flag , null ) ; }
public string get language ( ) { return null ; }
public ab script ( script script ) { if ( script == null ) { throw new illegal argument exception ( `` [ script ] must not be null `` ) ; } this . script = script ; return ( ab ) this ; }
public static class loader context class loader ( ) { return thread . current thread ( ) . get context class loader ( ) ; }
public string get manager ( ) { return get text property ( prefix + `` : manager `` ) ; }
public boolean add token ( token < ? extend token identifier > token ) { return ( token ! = null ) ? add token ( token . get service ( ) , token ) : false ; }
public line string get line ( ) { return line ; }
public void put rec ptr ( final long offset , final long value ) { make dirty ( ) ; int idx = rec ptr to index ( offset ) ; database . put rec ptr ( value , this . f buffer , idx ) ; record write ( offset , 4 ) ; }
public void set in stream ( in stream stream ) { this . stream = stream ; }
public boolean be equal ( final string name ) { return this . name ( ) . equal ignore case ( name ) ; }
public void set group id ( string group id ) { this . group id = group id ; } // -- void set group id ( string )
public long get size ( ) { return size ; }
public int get offset ( ) { return this . offset ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public boolean be mark deleted ( ) { return f mark a delete ; }
public boolean be debug ( ) { return debug ; }
public static boolean verify check sum ( final byte [ ] header ) { final long stored sum = parse octal ( header , chksum_offset , chksumlen ) ; long unsigned sum = 0 ; long sign sum = 0 ; for ( int i = 0 ; i < header . length ; i++ ) { byte b = header [ i ] ; if ( chksum_offset < = i & & i < chksum_offset + chksumlen ) { b = ' ' ; } unsigned sum += 0xff & b ; sign sum += b ; } return stored sum == unsigned sum || store sum == sign sum ; }
public void clear ( ) { mod count++ ; final hash entry < k , v > [ ] data = this . data ; for ( int i = data . length - 1 ; i > = 0 ; i -- ) { data [ i ] = null ; } size = 0 ; }
public platform family ( ) { return any ; }
public final o get o s ( ) { return o ; }
public synchronize void write ( int b ) { write ( new byte [ ] { ( byte ) b } , 0 , 1 ) ; }
public void set manage task ( task task ) { set manage component ( task ) ; }
public void set property set ( property set property set ) { this . property set = property set ; }
public void set separator ( string separator ) { this . separator = separator ; }
public long get n ( ) { return n ; }
public static string replace property ( project project , string value , hashtable key ) throw build exception { property helper ph = property helper . get property helper ( project ) ; return ph . replace property ( null , value , key ) ; }
public final byte [ ] get copy buffer ( ) { return copy buffer ; }
public boolean get boolean value ( ) { return false ; }
public void set executable ( executable executable ) { this . executable = executable ; }
public void warn ( string format , object arg1 , object arg2 ) { format and log ( log_level_warn , format , arg1 , arg2 ) ; }
public output < string > output ( ) { return output ; }
public void add recipient ( public key recipient recipient ) { recipient . add ( recipient ) ; }
public void set unless ( object unless property ) { this . unless condition = unless property ; }
public path create compilerclasspath ( ) { if ( compiler classpath == null ) { compiler classpath = new path ( get project ( ) ) ; } return compiler classpath . create path ( ) ; }
public file get dir ( string sub dir ) { file dir = new file ( get dir ( ) , sub dir ) ; dir . mkdirs ( ) ; return dir ; }
public void set project ( project project ) { this . project = project ; }
public boolean be compress ( ) { return do compress ; }
public boolean accept ( final file file ) { if ( file . be directory ( ) ) { final file [ ] file = file . list file ( ) ; return i o utils . length ( file ) == 0 ; } return file . length ( ) == 0 ; }
public boolean be boolean ( ) { return false ; }
public boolean be verbose ( ) { return verbose ; }
public void set comment ( string comment ) { super . set internal comment ( comment ) ; }
public int length ( ) { int m = max length > > address_bits ; while ( m > 0 & & data [ m ] == 0 ) { m -- ; } max length = ( m < < address_bits ) + ( 64 - long . number of lead zero ( data [ m ] ) ) ; return max length ; }
public delete branch command branch delete ( ) { return new delete branch command ( repo ) ; }
public void set new c m p ( boolean new c m p ) { this . new c m p = new c m p ; }
public boolean be warn enabled ( ) { return get logger ( ) . be warn enable ( ) ; }
public string get master ( ) { return this . master ; } // -- string get master ( )
public void set new c m p ( boolean new c m p ) { this . new c m p = new c m p ; }
public response mode get response mode ( ) { return rm ; }
public void set overwrite ( boolean overwrite ) { my copy . set overwrite ( overwrite ) ; }
public rename callback get rename callback ( ) { return rename callback ; }
public void set select ( expression select , configuration config ) throw x path exception { this . select = select ; adopt child expression ( select ) ; }
public method get method ( ) { return method ; }
public static optional < class > resolve interface type argument ( class type , class interface type ) { type [ ] generic interface = type . get generic interface ( ) ; for ( type generic interface : generic interface ) { if ( generic interface instanceof parameterized type ) { parameterized type pt = ( parameterized type ) generic interface ; if ( pt . get raw type ( ) == interface type ) { return resolve single type argument ( generic interface ) ; } } } class super class = type . get superclass ( ) ; if ( super class ! = null & & super class ! = object . class ) { return resolve interface type argument ( super class , interface type ) ; } return optional . empty ( ) ; }
public path get classpath ( ) { return classpath ; }
public vector1 d get location ( ) { return location ; }
public void set jar ( string jar ) { set ( job context . jar , jar ) ; }
public file get file ( ) { return file ; }
public void set display name ( string name ) { ct table . set display name ( name ) ; }
public string a string ( ) { return a string ( format . full , null ) ; }
public string a string ( ) { return a string ( format . full , null ) ; }
public void add sysproperty ( environment . variable sysp ) { sys property . add variable ( sysp ) ; }
public string to string ( ) { return get i d ( ) ; }
public static void warn ( string msg , throwable t ) { if ( quiet mode ) return ; system . err . println ( warn_prefix + msg ) ; if ( t ! = null ) { t . print stack trace ( ) ; } }
public boolean get test set ( ) { return set ; }
public boolean rebuild context ( ) { return rebuild context ; }
public static string c ( string p ) { return p . replace ( '/ ' , ' . ' ) ; }
public string get name ( ) { return to string ( ) ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public void set file ( file file ) { this . file = file ; }
public void set file ( final file file ) { this . library file = file ; }
public void set destfile ( file destination file ) { this . destination file = destination file ; }
public void set url ( string url ) { this . url = url ; }
public bundle get bundle ( ) { return bundle ; }
public void set server ( string server ) { this . server = server ; }
public static < t > field < t > coalesce ( t value , t . . . value ) { return coalesce0 ( tool . field ( value ) , tool . field ( value ) . to array ( empty_field ) ) ; }
public source get source ( ) { return source ; }
public void set action ( string action ) { this . action = action ; }
public static file get plugins home ( ) { return plugins home ; }
public final json node factory get node factory ( ) { return _config . get node factory ( ) ; }
public boolean accept ( i b tree visitor visitor ) throw index exception { return accept ( this . db . get rec ptr ( this . root pointer ) , visitor ) ; }
public static boolean be class ( object argument ) { return argument instanceof class < ? > ; }
public string get element class ( ) { return element class ; }
public path get classpath ( ) { return classpath ; }
public void set bootclasspath ( path bootclasspath ) { if ( this . bootclasspath == null ) { this . bootclasspath = bootclasspath ; } else { this . bootclasspath . append ( bootclasspath ) ; } }
public void set argument ( object [ ] argument ) { this . argument = argument ; }
public artifact descriptor result set dependency ( list < dependency > dependency ) { if ( dependency == null ) { this . dependency = collection . empty list ( ) ; } else { this . dependency = dependency ; } return this ; }
public void set verbose ( boolean verbose ) { this . verbose = verbose ; }
public void set file name parameter ( string file name parameter ) { this . file name parameter = file name parameter ; }
public path create compiler classpath ( ) { return facade . get implementation classpath ( get project ( ) ) ; }
protect void add context ( string path spec , string dir , boolean be filter ) throw i o exception { if ( 0 == web server . get handler ( ) . length ) { throw new runtime exception ( `` could n't find handler `` ) ; } web app context web app ctx = new web app context ( ) ; web app ctx . set context path ( path spec ) ; web app ctx . set war ( dir ) ; add context ( web app ctx , true ) ; }
public void set file ( file file ) { this . file = file ; }
public string get encode ( ) { return encode ; }
public default proxy selector add ( proxy proxy , string non proxy host ) { require non null ( proxy , `` proxy can not be null `` ) ; proxy . add ( new proxy def ( proxy , non proxy host ) ) ; return this ; }
public object get revision info ( ) { return revision info ; }
public void set project ( project project ) { this . project = project ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public int get execute count ( ) { return execute count ; }
public boolean eval feature ( ) { x m l reader reader = get reader ( ) ; if ( value == null ) { value = `` true `` ; } boolean v = project . to boolean ( value ) ; try { reader . set feature ( feature , v ) ; } catch ( s a x not recognize exception e ) { log ( feature + not_recognized + feature , project . msg_verbose ) ; return false ; } catch ( s a x not support exception e ) { log ( feature + not_supported + feature , project . msg_verbose ) ; return false ; } return true ; }
public string get script ( ) { return script ; }
public boolean be verbose ( ) { return verbose ; }
public void set comment ( string comment ) { super . set internal comment ( comment ) ; }
public void set compress ( boolean compress ) { do compress = compress ; }
public void replace ( string query s q l , string [ ] column name , session session , boolean recursive , boolean force ) { string old query s q l = this . query s q l ; string [ ] old column names = this . column name ; boolean old recursive = this . recursive ; init ( query s q l , null , column name , session , recursive ) ; db exception e = recompile ( session , force ) ; if ( e ! = null ) { init ( old query s q l , null , old column name , session , old recursive ) ; recompile ( session , true ) ; throw e ; } }
protect set < configurable application context > find application context ( ) { synchronize ( application context ) { return new link hash set < configurable application context > ( application context ) ; } }
public void set fail on teardown error ( boolean fail on teardown error ) { this . fail on teardown error = fail on teardown error ; }
public void set fail on error ( boolean fail on error ) { this . fail on error = fail on error ; }
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public mock http servlet request builder query param ( string name , string . . . value ) { param ( name , value ) ; this . query params . add all ( name , arrays . a list ( value ) ) ; return this ; }
public list < warn message > get warning ( ) { return warning ; }
public void set skip empty filesets ( boolean skip ) { throw new build exception ( get task type ( ) + `` doesn\'t support the skipemptyfileset attribute `` , get location ( ) ) ; }
public line string get line ( ) { return line ; }
public void set create date ( calendar date ) { set date property ( prefix + `` : create date `` , date ) ; }
protect void set internal date ( final string date ) { this . date = date ; }
public void copy ( ) { set ( current ( ) . copy ( ) ) ; }
public void set label ( string label ) { this . label = label ; }
public void set user ( io . vertx . reactivex . ext . auth . user user ) { delegate . set user ( user . get delegate ( ) ) ; }
public static string format ( date date ) { return thread_local_date_format . get ( ) . format ( date ) ; }
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public string get comment ( ) { return comment ; }
public void set ( boolean value ) { this . value = value ; }
public string get exception class name ( ) { return exception class name ; }
public void set file ( file file ) { this . file = file ; }
public static property load property ( resource resource ) throw i o exception { property prop = new property ( ) ; fill property ( prop , resource ) ; return prop ; }
public string get compiler ( ) { string compiler impl = get compiler version ( ) ; if ( fork ) { if ( be jdk compiler ( compiler impl ) ) { compiler impl = `` ext javac `` ; } else { log ( `` since compiler setting be n't classic or modern , `` + `` ignoring fork setting . `` , project . msg_warn ) ; } } return compiler impl ; }
public string get output dir ( ) { return output dir ; }
public boolean force ( ) { return force ; }
public void set property ( string property ) { this . property = property ; }
public void wait for ( supplier < boolean > check , int check every millis ) throw interrupted exception { wait for ( check , check every millis , 1 ) ; }
public void add sysproperty ( environment . variable sysp ) { sysprops . add ( sysp ) ; }
public void remove extra field ( zip short type ) { if ( extra field == null ) { throw new java . util . no such element exception ( ) ; } if ( extra field . remove ( type ) == null ) { throw new java . util . no such element exception ( ) ; } set extra ( ) ; }
public void set refid ( reference ref ) { this . ref = ref ; }
public void add type mapping ( w s d d type map mapping ) { type mapping . add ( map ) ; }
public string get filename ( ) { string filename = get file unicode ( ) ; if ( filename == null ) { filename = get file do ( ) ; } if ( filename == null ) { filename = get file mac ( ) ; } if ( filename == null ) { filename = get file unix ( ) ; } if ( filename == null ) { filename = get file ( ) ; } return filename ; }
public file get file ( ) { return this . file ; }
public void array next elm ( appendable out ) throw i o exception { out . append ( ' , ' ) ; }
public void set resource ( resource resource ) { this . resource = resource ; }
public synchronize void add ( resource collection c ) { if ( be reference ( ) ) { throw no child allow ( ) ; } if ( c == null ) { return ; } w . add ( c ) ; }
public void add ( resource collection rc ) { resource . add ( rc ) ; }
public string get regex ( ) { return regex ; }
public int read ( char buffer cb ) throw i o exception { / * * * int sz = size ( ) ; if ( sz < =0 ) return -1 ; if ( sz > 0 ) cb . put ( buf , start , sz ) ; return -1 ; * * * / int sz = size ( ) ; if ( sz > 0 ) cb . put ( buf , start , sz ) ; start=end ; while ( true ) { fill ( ) ; int s = size ( ) ; if ( s==0 ) return sz==0 ? -1 : sz ; sz += s ; cb . put ( buf , start , s ) ; } }
public ct class get ct class ( ) { if ( resolve ! = null ) return resolve . get ct class ( ) ; return type . object . get ct class ( ) ; }
public void set unless ( object c ) { unless condition = c ; }
public static int [ ] new int array ( int len ) { if ( len == 0 ) { return empty_int_array ; } return new int [ len ] ; }
public string to string ( ) { string builder sb = new string builder ( 256 ) ; sb . append ( `` ( `` ) ; sb . append ( get subject ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get predicate ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get object ( ) ) ; sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
public void set class name ( string class name ) { reader class name = class name ; }
public t read object ( reader reader ) throw i o exception { verify ( ) ; return read ( reader ) . get object ( ) ; }
public void report_error ( string message , object info ) { system . err . print ( message ) ; system . err . flush ( ) ; if ( info instanceof symbol ) if ( ( ( symbol ) info ) . leave ! = -1 ) system . err . println ( `` at character `` + ( ( symbol ) info ) . leave + `` of input `` ) ; else system . err . println ( `` `` ) ; else system . err . println ( `` `` ) ; }
public void set manager ( string manager ) { this . manager = manager ; }
public synchronize boolean be case sensitive ( ) { return be case sensitive ; }
public file get file ( ) { return file ; }
public string get text ( ) { return f text ; }
public string get symbolic name ( ) { return symbolic name ; }
public build get build ( ) { return this . build ; } // -- build get build ( )
public void set extend ( boolean extend ) { _extended = extend ; }
public boolean be block device ( ) { return link flag == lf_blk ; }
public boolean be character device ( ) { return link flag == lf_chr ; }
public static boolean be x m l whitespace ( char c ) { if ( c== ' ' || c=='\n ' || c=='\t ' || c=='\r ' ) { return true ; } return false ; }
public void set create unicode extra field ( unicode extra field b ) { create unicode extra field = b ; }
public void set action ( string action ) { this . action = action ; }
public int get precedence ( ) { return precedence ; }
public int size ( ) { return _size ; }
public boolean equal ( object other ) { return ( this == other || ( other instanceof bean component definition & & super . equal ( other ) ) ) ; }
public static int get initialize count ( ) { return initialize count ; }
public int hash code ( ) { int hash = 3 ; hash = 17 * hash + ( this . value ! = null ? this . value . hash code ( ) : 0 ) ; hash = 17 * hash + ( this . weak ? 1 : 0 ) ; return hash ; }
public void set token stream ( token stream input ) { this . input = null ; reset ( ) ; this . input = input ; }
public final void set rule ( int rule ) { this . rule = rule ; }
public t get result ( ) { return result ; }
public static string parse text node ( node node ) { final int node count = node . get child node ( ) . get length ( ) ; if ( node count == 0 ) { return `` `` ; } string builder buffer = new string builder ( ) ; for ( int i = 0 ; i < node count ; i++ ) { node child node = node . get child node ( ) . item ( i ) ; if ( child node . get node type ( ) == node . cdata_section_node || child node . get node type ( ) == node . text_node ) { buffer . append ( child node . get node value ( ) ) ; } } return buffer . to string ( ) ; }
public void add child ( object t , object child ) { if ( t ! =null & & child ! =null ) { ( ( tree ) t ) . add child ( ( tree ) child ) ; } }
public final annotation instance class annotation ( dot name name ) { list < annotation instance > instance = annotation . get ( name ) ; if ( instance ! = null ) { for ( annotation instance instance : instance ) { if ( instance . target ( ) == this ) { return instance ; } } } return null ; }
public string source ( ) { return source ; }
public annotation visitor visit type annotation ( final int type ref , final type path type path , final string descriptor , final boolean visible ) { if ( delegate ! = null ) { return delegate . visit type annotation ( type ref , type path , descriptor , visible ) ; } return null ; }
public service descriptor get service descriptor ( ) { return service descriptor ; }
public void visit ( node visitor v ) { if ( v . visit ( this ) ) { target . visit ( v ) ; element . visit ( v ) ; } }
public bean property descriptor get any property desc ( ) { if ( type desc == null ) return null ; return type desc . get any desc ( ) ; }
public annotation visitor visit parameter annotation ( final int parameter , final string descriptor , final boolean visible ) { if ( mv ! = null ) { return mv . visit parameter annotation ( parameter , descriptor , visible ) ; } return null ; }
public annotation visitor visit parameter annotation ( final int parameter , final string descriptor , final boolean visible ) { if ( mv ! = null ) { return mv . visit parameter annotation ( parameter , descriptor , visible ) ; } return null ; }
public annotation visitor visit annotation ( final string descriptor , final boolean visible ) { if ( mv ! = null ) { return mv . visit annotation ( descriptor , visible ) ; } return null ; }
public void accept ( final method visitor mv ) { mv . visit insn ( opcode ) ; }
public enclose expr set inner ( final expression inner ) { assert not null ( inner ) ; if ( inner == this . inner ) { return this ; } notify property change ( observable property . inner , this . inner , inner ) ; if ( this . inner ! = null ) this . inner . set parent node ( null ) ; this . inner = inner ; set a parent node of ( inner ) ; return this ; }
public annotation visitor visit type annotation ( final int type ref , final type path type path , final string descriptor , final boolean visible ) { if ( api < opcodes . asm5 ) { throw new unsupported operation exception ( `` this feature require asm5 `` ) ; } if ( cv ! = null ) { return cv . visit type annotation ( type ref , type path , descriptor , visible ) ; } return null ; }
public void print subclass ( ) { system . out . println ( `` subclass : `` ) ; for ( map . entry < dot name , list < class info > > entry : subclass . entry set ( ) ) { system . out . println ( entry . get key ( ) + `` : `` ) ; for ( class info clazz : entry . get value ( ) ) system . out . println ( `` `` + clazz . name ( ) ) ; } }
public void insert before ( final abstract insn node next insn , final insn list insn list ) { if ( insn list . size == 0 ) { return ; } size += insn list . size ; abstract insn node first insn list element = insn list . first insn ; abstract insn node last insn list element = insn list . last insn ; abstract insn node previous insn = next insn . previous insn ; if ( previous insn == null ) { first insn = first insn list element ; } else { previous insn . next insn = first insn list element ; } next insn . previous insn = last insn list element ; last insn list element . next insn = next insn ; first insn list element . previous insn = previous insn ; cache = null ; insn list . remove all ( false ) ; }
public list < try catch block node > get handler ( final int insn index ) { return handler [ insn index ] ; }
public final string get name ( ) { return name ; }
public void insert before ( final abstract insn node next insn , final insn list insn list ) { if ( insn list . size == 0 ) { return ; } size += insn list . size ; abstract insn node first insn list element = insn list . first insn ; abstract insn node last insn list element = insn list . last insn ; abstract insn node previous insn = next insn . previous insn ; if ( previous insn == null ) { first insn = first insn list element ; } else { previous insn . next insn = first insn list element ; } next insn . previous insn = last insn list element ; last insn list element . next insn = next insn ; first insn list element . previous insn = previous insn ; cache = null ; insn list . remove all ( false ) ; }
protect void validate index ( int index ) { if ( index < 0 || index > size ) { throw new string index out of bound exception ( index ) ; } }
public void insert before ( final abstract insn node next insn , final insn list insn list ) { if ( insn list . size == 0 ) { return ; } size += insn list . size ; abstract insn node first insn list element = insn list . first insn ; abstract insn node last insn list element = insn list . last insn ; abstract insn node previous insn = next insn . previous insn ; if ( previous insn == null ) { first insn = first insn list element ; } else { previous insn . next insn = first insn list element ; } next insn . previous insn = last insn list element ; last insn list element . next insn = next insn ; first insn list element . previous insn = previous insn ; cache = null ; insn list . remove all ( false ) ; }
public void accept ( final method visitor method visitor ) { abstract insn node current insn = first insn ; while ( current insn ! = null ) { current insn . accept ( method visitor ) ; current insn = current insn . next insn ; } }
public void set label ( string label ) { this . label = label ; }
public void set module ( final list < module > module ) { this . module = module ; }
public string get string representation ( ) { return this . string representation ; }
public static boolean be upper case ( character self ) { return character . be upper case ( self ) ; }
public atomic integer array assert do not contain ( int value , index index ) { array . assert do not contain ( info , array , value , index ) ; return myself ; }
public self contain exactly ( @ suppress warning ( `` unchecked `` ) element . . . value ) { array . assert contain exactly ( info , actual , value ) ; return myself ; }
public void assert contains ( assertion info info , object [ ] actual , object value , index index ) { array . assert contains ( info , failure , actual , value , index ) ; }
public atomic reference array assert < t > start with ( @ suppress warning ( `` unchecked `` ) t . . . sequence ) { array . assert start with ( info , array , sequence ) ; return myself ; }
public atomic reference array assert < t > be not ( condition < ? super t > condition ) { array . assert be not ( info , array , condition ) ; return myself ; }
public self use element comparator ignore field ( string . . . field ) { return use extend by type element comparator ( new ignore field comparator ( comparators for element property or field name , get comparators for element property or field type ( ) , field ) ) ; }
public self use recursive field by field element comparator ( ) { return use extend by type element comparator ( new recursive field by field comparator ( comparators for element property or field name , get comparators for element property or field type ( ) ) ) ; }
public void test failure ( failure failure ) throw exception { }
public void assert all ( ) { list < throwable > error = error collect ( ) ; if ( ! error . be empty ( ) ) throw best multiple assertion error ( error ) ; }
public file get file ( ) { return file ; }
public boolean be atomic type ( ) { return false ; }
public atomic integer array assert have size ( int expect ) { array . assert have size ( info , array , expect ) ; return myself ; }
public atomic integer array assert have array ( int [ ] expect ) { array . assert contain exactly ( info , array , expect ) ; return myself ; }
public atomic reference array assert < t > contain only ( @ suppress warning ( `` unchecked `` ) t . . . value ) { array . assert contain only ( info , array , value ) ; return myself ; }
public long2 d array assert do not contain ( long [ ] value , index index ) { long2d array . assert do not contain ( info , actual , value , index ) ; return myself ; }
public atomic integer assert have value ( int expect value ) { be not null ( ) ; int actual value = actual . get ( ) ; if ( ! object . get comparison strategy ( ) . be equal ( actual value , expect value ) ) { throw assertion error ( should have value ( actual , expect value ) ) ; } return myself ; }
public atomic long assert do not have value ( long expect value ) { be not null ( ) ; long actual value = actual . get ( ) ; if ( object . get comparison strategy ( ) . be equal ( actual value , expect value ) ) { throw assertion error ( should not contain value ( actual , expect value ) ) ; } return myself ; }
public self contain exactly in any order ( boolean [ ] value ) { require non null parameter ( value , `` value `` ) ; array . assert contain exactly in any order ( info , actual , to primitive boolean array ( value ) ) ; return myself ; }
public atomic integer assert have value ( int expect value ) { be not null ( ) ; int actual value = actual . get ( ) ; if ( ! object . get comparison strategy ( ) . be equal ( actual value , expect value ) ) { throw assertion error ( should have value ( actual , expect value ) ) ; } return myself ; }
public void assert have same size a ( assertion info info , boolean [ ] actual , object [ ] other ) { array . assert have same size a ( info , actual , other ) ; }
public atomic integer array assert contain only once ( int . . . value ) { array . assert contain only once ( info , array , value ) ; return myself ; }
public self start with ( @ suppress warning ( `` unchecked `` ) element . . . sequence ) { array . assert start with ( info , actual , sequence ) ; return myself ; }
public atomic reference array assert < t > be not ( condition < ? super t > condition ) { array . assert be not ( info , array , condition ) ; return myself ; }
public atomic reference array assert < t > be not ( condition < ? super t > condition ) { array . assert be not ( info , array , condition ) ; return myself ; }
public list < format error > get error ( ) { return error ; }
public list < condition > get condition ( ) { return condition ; }
public void assert be negative ( assertion info info , number actual ) { assert less than ( info , actual , zero ( ) ) ; }
public void assert have same dimension a ( assertion info info , boolean [ ] [ ] actual , object other ) { array . assert have same dimension a ( info , actual , other ) ; }
public void assert be negative ( assertion info info , number actual ) { assert less than ( info , actual , zero ( ) ) ; }
public string dump ( ) { return dump ( 0 , ( int ) size ( ) ) ; }
public void assert not empty ( assertion info info , boolean [ ] actual ) { array . assert not empty ( info , failure , actual ) ; }
public void assert not empty ( assertion info info , boolean [ ] actual ) { array . assert not empty ( info , failure , actual ) ; }
public self contains ( element value , index index ) { array . assert contains ( info , actual , value , index ) ; return myself ; }
public void assert not empty ( assertion info info , boolean [ ] actual ) { array . assert not empty ( info , failure , actual ) ; }
public void assert not empty ( assertion info info , boolean [ ] actual ) { array . assert not empty ( info , failure , actual ) ; }
public void assert be relative ( assertion info info , file actual ) { if ( ! be absolute path ( info , actual ) ) return ; throw failure . failure ( info , should be relative path ( actual ) ) ; }
public void assert have same size a ( assertion info info , boolean [ ] actual , object [ ] other ) { array . assert have same size a ( info , actual , other ) ; }
public static string date to iso8601 string ( date date ) { simple date format df = new simple date format ( `` yyyy- m m-dd ' t ' h h : mm : s z `` , locale . english ) ; return df . format ( date ) ; }
public void set date format ( string date format ) { super . set internal date format ( new simple date format ( date format ) ) ; }
public string get temp name for file ( string orig file ) { return multi file writer . get temp name for file ( orig file ) ; }
public static void check state ( boolean expression , string error message template , object . . . error message args ) { if ( ! expression ) { throw new illegal state exception ( format ( error message template , error message args ) ) ; } }
public static void check argument ( boolean expression , string error message template , object . . . error message args ) { if ( ! expression ) throw new illegal argument exception ( format ( error message template , error message args ) ) ; }
public self have size great than ( int boundary ) { array . assert have size great than ( info , actual , boundary ) ; return myself ; }
public void assert have size great than ( assertion info info , boolean [ ] actual , int boundary ) { array . assert have size great than ( info , actual , boundary ) ; }
public static abstract char array assert < ? > give ( char [ ] actual ) { return assume that ( actual ) ; }
public static abstract byte array assert < ? > give ( byte [ ] actual ) { return assume that ( actual ) ; }
public static abstract byte array assert < ? > give ( byte [ ] actual ) { return assume that ( actual ) ; }
public self ignore all overridden equal ( ) { recursive comparison configuration . ignore all overridden equal ( ) ; return myself ; }
public void set date format ( string date format ) { super . set internal date format ( new simple date format ( date format ) ) ; }
public static should not be null should not be null ( string label ) { return new should not be null ( format ( `` % n expect % s not to be null `` , label ) ) ; }
public static error message factory should not be null ( ) { return instance ; }
public self have size great than ( int boundary ) { array . assert have size great than ( info , actual , boundary ) ; return myself ; }
public boolean equal ( object obj ) { if ( obj instanceof event ) { return to string ( ) . equal ( obj . to string ( ) ) ; } else { return false ; } }
public atomic long array assert contain exactly in any order ( long . . . value ) { array . assert contain exactly in any order ( info , array , value ) ; return myself ; }
public self be upper case ( ) { character . assert upper case ( info , actual ) ; return myself ; }
public atomic long assert do not have value ( long expect value ) { be not null ( ) ; long actual value = actual . get ( ) ; if ( object . get comparison strategy ( ) . be equal ( actual value , expect value ) ) { throw assertion error ( should not contain value ( actual , expect value ) ) ; } return myself ; }
public atomic integer array assert do not contain ( int value , index index ) { array . assert do not contain ( info , array , value , index ) ; return myself ; }
public self ignore collection order ( ) { recursive comparison configuration . ignore collection order ( true ) ; return myself ; }
public static boolean max length ( string value , int max ) { return ( value . length ( ) < = max ) ; }
public void assert have same size a ( assertion info info , boolean [ ] actual , object [ ] other ) { array . assert have same size a ( info , actual , other ) ; }
public self be not close to ( short expect , offset < short > offset ) { short . assert be not close to ( info , actual , expect , offset ) ; return myself ; }
public self contain exactly ( @ suppress warning ( `` unchecked `` ) element . . . value ) { array . assert contain exactly ( info , actual , value ) ; return myself ; }
public self be not close to ( int expect , offset < integer > offset ) { integer . assert be not close to ( info , actual , expect , offset ) ; return myself ; }
public atomic reference array assert < t > be not ( condition < ? super t > condition ) { array . assert be not ( info , array , condition ) ; return myself ; }
public node get node ( ) { return node ; }
public condition factory alias ( string alias ) { return new condition factory ( alias , timeout constraint , poll interval , poll delay , catch uncaught exception , exception ignorer , condition evaluation listener , executor lifecycle ) ; }
public void set target ( string target to add ) { if ( target to add . equal ( `` `` ) ) { throw new build exception ( `` target attribute must not be empty `` ) ; } target . add ( target to add ) ; target attribute set = true ; }
public object [ ] get argument ( ) { return argument ; }
public condition factory poll interval ( duration poll interval ) { return new condition factory ( alias , timeout , poll interval , poll delay , catch uncaught exception , condition evaluation listener ) ; }
public condition factory ignore exception ( final class < ? extend throwable > exception type ) { if ( exception type == null ) { throw new illegal argument exception ( `` exception can not be null `` ) ; } return new condition factory ( alias , timeout constraint , poll interval , poll delay , catch uncaught exception , new predicate exception ignorer ( e - > e . get class ( ) . equal ( exception type ) ) , condition evaluation listener , executor lifecycle ) ; }
public condition factory ignore exception instance of ( final class < ? extend throwable > exception type ) { if ( exception type == null ) { throw new illegal argument exception ( `` exception type can not be null `` ) ; } return new condition factory ( alias , timeout constraint , poll interval , poll delay , catch uncaught exception , new predicate exception ignorer ( e - > exception type . be assignable from ( e . get class ( ) ) ) , condition evaluation listener , executor lifecycle ) ; }
public int get int value ( ) { return 0 ; }
public date time minus ( long duration ) { return with duration add ( duration , -1 ) ; }
public void set modifier ( int modifier ) { this . modifier = modifier ; }
public o p c package get package ( ) { return _document . get package ( ) ; }
public final boolean be immutable ( ) { return true ; }
public boolean be enable ( ) { return this . enable ; }
public string value ( ) { return value ; }
public method get method ( ) { return method ; }
public static synchronize < t > t invoke method ( object instance , string method to execute , class < ? > define in , class < ? > [ ] argument type , object . . . argument ) throw exception { return whitebox impl . < t > invoke method ( instance , method to execute , define in , argument type , argument ) ; }
public string get field name ( ) { return field name ; }
public field capability request field ( string . . . field ) { if ( field == null || field . length == 0 ) { throw new illegal argument exception ( `` specify field ca n't be null or empty `` ) ; } set < string > field set = new hash set < > ( arrays . a list ( field ) ) ; this . field = field set . to array ( new string [ 0 ] ) ; return this ; }
public static < t > t arg that ( matcher < t > matcher ) { report matcher ( matcher ) ; return ( t ) default value ( generic type of matcher ( matcher . get class ( ) ) ) ; }
public static < t > element matcher . junction < t > not ( element matcher < ? super t > matcher ) { return new negate matcher < t > ( matcher ) ; }
public boolean add token ( token < ? extend token identifier > token ) { return ( token ! = null ) ? add token ( token . get service ( ) , token ) : false ; }
public static < t extend type description . generic > element matcher . junction < t > raw type ( class < ? > type ) { return raw type ( be ( type ) ) ; }
public class loader get class loader ( ) { return class loader ; }
public void free reference ( pointer reference ) { remove ( reference ) ; }
public static string get version string ( ) { if ( version == null ) { version = version . class . get package ( ) . get implementation version ( ) ; if ( version == null ) { version = `` [ work ] `` ; } } return version ; }
public void accept ( final method visitor mv ) { mv . visit insn ( opcode ) ; }
public void set label ( string label ) { this . label = label ; }
public static < t > element matcher . junction < t > not ( element matcher < ? super t > matcher ) { return new negate matcher < t > ( matcher ) ; }
public final boolean be unsigned ( ) { return be unsigned ; }
public static void attach ( file agent jar , string process id , attachment provider attachment provider ) { attach ( agent jar , process id , without_argument , attachment provider ) ; }
public boolean be attachment ( object value ) { return attachment utils . be attachment ( value ) ; }
public static void attach ( file agent jar , string process id , attachment provider attachment provider ) { attach ( agent jar , process id , without_argument , attachment provider ) ; }
public retry policy with max duration ( long max duration , time unit time unit ) { assert . not null ( time unit , `` time unit `` ) ; assert . state ( time unit . to nanos ( max duration ) > delay . to nanos ( ) , `` max duration must be great than the delay `` ) ; this . max duration = new duration ( max duration , time unit ) ; return this ; }
public void ensure capacity ( @ nonnegative long maximum size ) { caffeine . require argument ( maximum size > = 0 ) ; int maximum = ( int ) math . min ( maximum size , integer . max_value > > > 1 ) ; if ( ( table ! = null ) & & ( table . length > = maximum ) ) { return ; } table = new long [ ( maximum == 0 ) ? 1 : ceiling next power of two ( maximum ) ] ; table mask = math . max ( 0 , table . length - 1 ) ; sample size = ( maximum size == 0 ) ? 10 : ( 10 * maximum ) ; if ( sample size < = 0 ) { sample size = integer . max_value ; } size = 0 ; }
public void increment weight ( double weight ) { this . weight += weight ; }
public double get time ( ) { return time ; }
public access get access ( ) { return this . access ; }
public static @ unsigned long to unsigned long ( @ unsigned byte b ) { return ( ( long ) b ) & 0xff l ; }
public static double to double ( @ unsigned byte b ) { return to unsigned big integer ( to unsigned long ( b ) ) . double value ( ) ; }
public static double to double ( @ unsigned int i ) { return to unsigned big integer ( to unsigned long ( i ) ) . double value ( ) ; }
public static double to double ( @ unsigned int i ) { return to unsigned big integer ( to unsigned long ( i ) ) . double value ( ) ; }
public static double to double ( @ unsigned byte b ) { return to unsigned big integer ( to unsigned long ( b ) ) . double value ( ) ; }
public static int get hi ( long encode ) { return ( int ) ( ( encode > > 32 ) & 0x f f f f_ f f f f l ) ; }
public static < e > list < e > get list ( object list ) { return get list ( list , false ) ; }
public object reverse conversion ( boolean execute in reverse order , int index , object value , boolean [ ] convert flag ) { list < conversion < ? , ? > > conversion = conversion by index . get ( index ) ; if ( conversion ! = null ) { if ( convert flags ! = null ) { convert flag [ index ] = true ; } conversion conversion = null ; try { if ( execute in reverse order ) { for ( int i = conversion . size ( ) - 1 ; i > = 0 ; i -- ) { conversion = conversion . get ( i ) ; value = conversion . revert ( value ) ; } } else { for ( conversion < ? , ? > c : conversion ) { conversion = c ; value = conversion . revert ( value ) ; } } } catch ( data process exception ex ) { ex . set value ( value ) ; ex . set column index ( index ) ; ex . mark a non fatal ( ) ; throw ex ; } catch ( throwable ex ) { data process exception exception ; if ( conversion ! = null ) { exception = new data processing exception ( `` error convert value ' { value } ' use conversion `` + conversion . get class ( ) . get name ( ) , ex ) ; } else { exception = new data processing exception ( `` error convert value ' { value } ' `` , ex ) ; } exception . set value ( value ) ; exception . set column index ( index ) ; exception . mark a non fatal ( ) ; throw exception ; } } return value ; }
public string get regex ( ) { return regex ; }
public final boolean be unsigned ( ) { return be unsigned ; }
public string get include ( ) { return include ; }
public list < resolve type > get type parameter ( ) { return _type binding . get type parameter ( ) ; }
public resolve type get type ( ) { return _type ; }
public string get acl string ( ) { string builder sb = new string builder ( initial_capacity ) ; if ( all allow ) { sb . append ( ' * ' ) ; } else { sb . append ( get user string ( ) ) ; sb . append ( `` `` ) ; sb . append ( get group string ( ) ) ; } return sb . to string ( ) ; }
public final int type ( ) { return type ! = 0 ? type : resolve type ( ) ; }
public final int type ( ) { return type ! = 0 ? type : resolve type ( ) ; }
public string type ( ) { return parent type ; }
public static boolean be self reference ( resolve type type ) { return ( type instanceof resolve recursive type ) ; }
protect long get time stamp ( class cl ) { return verifier . get timestamp ( cl ) ; }
public static set type set ( set set , class type ) { return type set . decorate ( set , type ) ; }
public static < t > t new instance ( class < t > c ) { return ( t ) invoker helper . invoke constructor of ( c , null ) ; }
protect collection < field access > field of ( class < ? > c ) { collection < field access > field = field of a s t class . get ( c ) ; if ( field ! = null ) return field ; field = new array list < field access > ( ) ; get field ( c , field ) ; field of a s t class . put ( c , field ) ; return field ; }
public string dump ( ) { return dump ( 0 , ( int ) size ( ) ) ; }
public boolean handle message ( i message message ) throw abort exception { if ( ( null ! = message ) & & ! be ignore ( message . get kind ( ) ) ) { string result = render ( message ) ; if ( null ! = result ) { writer . println ( result ) ; writer . flush ( ) ; if ( abort on failure & & ( message . be failed ( ) || message . be abort ( ) ) ) { throw new abort exception ( message ) ; } } } return true ; }
public string get prefix ( ) { return prefix ; }
public object id get data ( ) { return data ; }
public void set user data ( object user data ) { this . user data = user data ; }
public string to string ( ) { string builder sb = new string builder ( 256 ) ; sb . append ( `` ( `` ) ; sb . append ( get subject ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get predicate ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get object ( ) ) ; sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
public boolean be weak ( ) { return weak ; }
public void activate ( ) { super . activate ( suite_context_id ) ; }
public static < t > t invoke and unwrap ( final object instance , final method method , final object . . . parameter ) throw throwable { try { return cast ( method . invoke ( instance , parameter ) ) ; } catch ( illegal argument exception e ) { throw reflection logger . log . illegal argument exception on reflection invocation ( instance . get class ( ) , instance , method , array . to string ( parameter ) , e ) ; } catch ( illegal access exception e ) { throw new weld exception ( e ) ; } catch ( invocation target exception e ) { throw e . get cause ( ) ; } }
public static < t > list < t > reverse ( list < t > self , boolean mutate ) { if ( mutate ) { collection . reverse ( self ) ; return self ; } int size = self . size ( ) ; list < t > answer = new array list < t > ( size ) ; list iterator < t > iter = self . list iterator ( size ) ; while ( iter . have previous ( ) ) { answer . add ( iter . previous ( ) ) ; } return answer ; }
public object get bean ( ) { return bean ; }
public string get method name ( ) { return method name ; }
public string get property value ( string property name ) { return get property ( ) . get ( property name ) ; }
static public void assert equal ( string message , object expect , object actual ) { if ( expect == null & & actual == null ) return ; if ( expect ! = null & & expect . equal ( actual ) ) return ; if ( expect instanceof string & & actual instanceof string ) throw new comparison failure ( message , ( string ) expect , ( string ) actual ) ; else fail not equal ( message , expect , actual ) ; }
public string get property ( ) { return property ; }
public collection value ( ) { collection v = value ; return ( vs ! = null ) ? v : ( value = new value ( ) ) ; }
public string get default string value ( ) { return default string value ; }
public synchronize void set convert value ( @ nullable object value ) { this . convert = true ; this . convert value = value ; }
public pattern get pattern ( ) { return pattern ; }
public byte [ ] get byte ( ) { return byte ; }
public static int get default integer ( ) { return convert utils bean . get instance ( ) . get default integer ( ) ; }
public static int get default integer ( ) { return convert utils bean . get instance ( ) . get default integer ( ) ; }
public static char get default character ( ) { return convert utils bean . get instance ( ) . get default character ( ) ; }
public static boolean register bean ( object name name , object bean , boolean register ) { try { m bean server mb = j m x server . get agent ( ) . get server ( ) ; boolean be register = mb . be register ( name ) ; system . out . println ( ( register ? `` `` : `` un `` ) + `` registering bean `` + name ) ; if ( register & & be register ) { system . out . println ( name + `` be already register `` ) ; return true ; } else if ( ! register & & ! be register ) { system . out . println ( name + `` be not register `` ) ; return true ; } else if ( register ) { mb . register m bean ( bean , name ) ; } else { mb . unregister m bean ( name ) ; } return true ; } catch ( j m exception e ) { system . out . println ( `` m bean registration error : `` + e . get message ( ) ) ; return false ; } }
public string get name ( ) { return this . name ; }
public class < ? > get type ( ) { return i type ; }
public static long size on heap of ( byte buffer [ ] array ) { long all element size = 0 ; for ( int i = 0 ; i < array . length ; i++ ) if ( array [ i ] ! = null ) all element size += size on heap of ( array [ i ] ) ; return all element size + size of array ( array ) ; }
public object get bean ( ) { return bean ; }
public void set cache size ( int cache size ) { this . cache size = cache size ; }
public string get descriptor ( ) { return descriptor ; }
public object pop ( ) throw empty stack exception { int n = size ( ) ; if ( n < = 0 ) { throw new empty stack exception ( ) ; } else { return remove ( n - 1 ) ; } }
public object peek ( int n ) throw empty stack exception { int m = ( size ( ) - n ) - 1 ; if ( m < 0 ) { throw new empty stack exception ( ) ; } else { return get ( m ) ; } }
public int get option ( ) { return option ; }
public line string get line ( ) { return line ; }
public string get prefix ( ) { return prefix ; }
public io . vertx . reactivex . redis . client . request arg ( int arg ) { delegate . arg ( arg ) ; return this ; }
public void set s ( string s ) { cmd . add flag ( `` -s `` , s ) ; }
public type get type ( ) { return type ; }
public void set type ( int type ) { this . type = type ; }
public string [ ] get require ( ) { return require ; }
public static option builder with long opt ( string longopt ) { instance . longopt = longopt ; return instance ; }
public static option builder be require ( boolean require ) { instance . require = require ; return instance ; }
public static option builder with long opt ( string new longopt ) { option builder . longopt = new longopt ; return instance ; }
public file get file ( ) { return file ; }
public object encode ( object object ) throw encoder exception { try { byte [ ] byte array = object instanceof string ? ( ( string ) object ) . get byte ( get charset name ( ) ) : ( byte [ ] ) object ; return encode hex ( byte array ) ; } catch ( class cast exception e ) { throw new encoder exception ( e . get message ( ) , e ) ; } catch ( unsupported encode exception e ) { throw new encoder exception ( e . get message ( ) , e ) ; } }
public byte [ ] to byte array ( final string ascii ) { if ( ascii == null ) { return empty_byte_array ; } return from ascii ( ascii . to char array ( ) ) ; }
public object decode ( final object ascii ) throw decoder exception { if ( ascii == null ) { return empty_byte_array ; } if ( ascii instanceof byte [ ] ) { return from ascii ( ( byte [ ] ) ascii ) ; } if ( ascii instanceof char [ ] ) { return from ascii ( ( char [ ] ) ascii ) ; } if ( ascii instanceof string ) { return from ascii ( ( ( string ) ascii ) . to char array ( ) ) ; } throw new decoder exception ( `` argument not a byte array `` ) ; }
public string get string ( ) throw i o exception { return new string ( input buffer , charsets . iso_8859_1 ) ; }
public static message digest get sha512 digest ( ) { return get digest ( message digest algorithms . sha_512 ) ; }
public static message digest get sha256 digest ( ) { return get digest ( message digest algorithms . sha_256 ) ; }
public byte string hash ( ) { byte [ ] result = message digest ! = null ? message digest . digest ( ) : mac . do final ( ) ; return byte string . of ( result ) ; }
public static string sha256 crypt ( final byte [ ] key byte ) { return sha256 crypt ( key byte , null ) ; }
public static string md5 crypt ( final byte [ ] key byte , final string salt ) { return md5 crypt ( key byte , salt , md5_prefix ) ; }
public static code get code ( int code ) { if ( code < = max_code ) { return code map [ code ] ; } return null ; }
public string get encode ( ) { return encode ; }
public void write ( byte [ ] b ) { }
public charset get default charset ( ) { return this . default charset ; }
public final byte [ ] get byte array ( ) { return this . byte array ; }
public byte string hash ( ) { byte [ ] result = message digest ! = null ? message digest . digest ( ) : mac . do final ( ) ; return byte string . of ( result ) ; }
public static message digest get sha256 digest ( ) { return get digest ( message digest algorithms . sha_256 ) ; }
public object encode ( final object raw ) throw encoder exception { if ( ! ( raw instanceof byte [ ] ) ) { throw new encoder exception ( `` argument not a byte array `` ) ; } return to ascii char ( ( byte [ ] ) raw ) ; }
public static string decode ( string binary data ) { if ( binary data == null ) return null ; byte [ ] decode = null ; try { decoded = decode ( binary data . get byte ( `` utf-8 `` ) ) ; } catch ( unsupported encode exception e ) { } return decode == null ? null : new string ( decode ) ; }
public boolean contains key ( object key ) { return contains ( key ) ; }
public boolean add all ( collection coll ) { return add all ( size ( ) , coll ) ; }
public string to string ( ) { if ( size ( ) == 0 ) { return `` [ ] `` ; } final string builder buf = new string builder ( ) ; buf . append ( ' [ ' ) ; final iterator < e > it = unique set ( ) . iterator ( ) ; while ( it . have next ( ) ) { final object current = it . next ( ) ; final int count = get count ( current ) ; buf . append ( count ) ; buf . append ( ' : ' ) ; buf . append ( current ) ; if ( it . have next ( ) ) { buf . append ( ' , ' ) ; } } buf . append ( ' ] ' ) ; return buf . to string ( ) ; }
public string get path ( ) { final string builder buf = new string builder ( ) ; append path ( buf ) ; return buf . to string ( ) ; }
public set < string > key set ( ) { return member . key set ( ) ; }
public void set value ( object value ) { this . value = value ; }
public string key ( ) { return key ; }
public int size ( ) { int size = 0 ; for ( final set < e > item : all ) { size += item . size ( ) ; } return size ; }
public boolean be empty ( ) { for ( final set < e > item : all ) { if ( item . be empty ( ) == false ) { return false ; } } return true ; }
public void set iterator ( final iterator < ? extend e > iterator ) { this . iterator = iterator ; }
public k get key ( final int index ) { return key [ index ] ; }
public static < e > boolean match all ( final iterator < e > iterator , final predicate < ? super e > predicate ) { if ( predicate == null ) { throw new null pointer exception ( `` predicate must not be null `` ) ; } if ( iterator ! = null ) { while ( iterator . have next ( ) ) { final e element = iterator . next ( ) ; if ( ! predicate . evaluate ( element ) ) { return false ; } } } return true ; }
public static < t > list < t > a list ( t [ ] a ) { if ( a == null ) return collection . empty list ( ) ; return array . a list ( a ) ; }
public static < t > predicate < t > any predicate ( final collection < ? extend predicate < ? super t > > predicate ) { return any predicate . any predicate ( predicate ) ; }
public boolean all match ( final predicate < ? super e > predicate ) { return iterable utils . match all ( iterable , predicate ) ; }
public void set iterator ( final iterator < ? extend e > iterator ) { this . iterator = iterator ; }
public static object a type ( object object , class type ) throw throwable { if ( object == null ) object = null object . get null object ( ) ; return invoke method n ( object . get class ( ) , object , `` a type `` , new object [ ] { type } ) ; }
public boolean add all ( final collection < ? extend attribute > collection ) { return add all ( size ( ) , collection ) ; }
public void set option comparator ( comparator comparator ) { if ( comparator == null ) { this . option comparator = new option comparator ( ) ; } else { this . option comparator = comparator ; } }
public static < a extend comparable < a > > comparable check builder < a > be ( final a a ) { return new comparable check builder < > ( a ) ; }
public void set option comparator ( comparator comparator ) { if ( comparator == null ) { this . option comparator = new option comparator ( ) ; } else { this . option comparator = comparator ; } }
public void set option comparator ( comparator comparator ) { if ( comparator == null ) { this . option comparator = new option comparator ( ) ; } else { this . option comparator = comparator ; } }
public int size ( ) { return size ; }
public int compare ( final i obj1 , final i obj2 ) { final o value1 = this . transformer . transform ( obj1 ) ; final o value2 = this . transformer . transform ( obj2 ) ; return this . decorate . compare ( value1 , value2 ) ; }
public int compare ( final e obj1 , final e obj2 ) { return comparator . compare ( obj2 , obj1 ) ; }
public static boolean safe equal ( object o1 , object o2 ) { if ( o1 == o2 ) { return true ; } if ( o1 == null || o2 == null ) { return false ; } return o1 . equal ( o2 ) ; }
public static < e > iterable < e > empty if null ( final iterable < e > iterable ) { return iterable == null ? iterable utils . < e > empty iterable ( ) : iterable ; }
public element append ( string html ) { for ( element element : this ) { element . append ( html ) ; } return this ; }
public static < e > iterable < e > empty if null ( final iterable < e > iterable ) { return iterable == null ? iterable utils . < e > empty iterable ( ) : iterable ; }
public static < c > boolean match all ( final iterable < c > input , final predicate < ? super c > predicate ) { return predicate ! = null & & iterable utils . match all ( input , predicate ) ; }
public static < t > predicate < t > any predicate ( final collection < ? extend predicate < ? super t > > predicate ) { return any predicate . any predicate ( predicate ) ; }
public closure < ? super t > get closure ( ) { return i closure ; }
public closure < ? super e > [ ] get closure ( ) { return functor utils . < e > copy ( i closure ) ; }
public closure < ? super e > [ ] get closure ( ) { return functor utils . < e > copy ( i closure ) ; }
public o transform ( final i input ) { return i map . get ( input ) ; }
public class < t > get type ( ) { return type ; }
public o transform ( final i input ) { if ( i predicate . evaluate ( input ) ) { return i true transformer . transform ( input ) ; } return i false transformer . transform ( input ) ; }
public boolean evaluate ( final t object ) { return object == null ; }
public boolean evaluate ( final t object ) { return object ! = null ; }
public o transform ( final i input ) { if ( i predicate . evaluate ( input ) ) { return i true transformer . transform ( input ) ; } return i false transformer . transform ( input ) ; }
public static < e > iterable < e > empty if null ( final iterable < e > iterable ) { return iterable == null ? iterable utils . < e > empty iterable ( ) : iterable ; }
public static string to string ( iterable < ? > iterable ) { return to string ( `` , `` , iterable ) ; }
public k [ ] get key ( ) { return key . clone ( ) ; }
public object next ( ) { if ( have next ( ) ) { this . see = true ; return this . object ; } throw new no such element exception ( ) ; }
public void add predicate ( predicate predicate ) { if ( this . predicate == collection . empty_list ) { this . predicate = new array list ( ) ; } this . predicate . add ( predicate ) ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public list iterator list iterator ( ) { return list iterator ( 0 ) ; }
public boolean have next ( ) { return false ; }
public iterable < item > get item ( ) { return this . item ; }
public boolean have next ( ) { return false ; }
public int get index ( ) { return index ; }
public static < e > resettable iterator < e > array iterator ( final e [ ] array , final int start , final int end ) { return new object array iterator < > ( array , start , end ) ; }
public static < e > resettable iterator < e > array iterator ( final object array , final int start ) { return new array iterator < > ( array , start ) ; }
public static < e > boolean match all ( final iterator < e > iterator , final predicate < ? super e > predicate ) { if ( predicate == null ) { throw new null pointer exception ( `` predicate must not be null `` ) ; } if ( iterator ! = null ) { while ( iterator . have next ( ) ) { final e element = iterator . next ( ) ; if ( ! predicate . evaluate ( element ) ) { return false ; } } } return true ; }
public void set iterator ( final iterator < ? extend e > iterator ) { this . iterator = iterator ; }
public static < e > boolean match all ( final iterator < e > iterator , final predicate < ? super e > predicate ) { if ( predicate == null ) { throw new null pointer exception ( `` predicate must not be null `` ) ; } if ( iterator ! = null ) { while ( iterator . have next ( ) ) { final e element = iterator . next ( ) ; if ( ! predicate . evaluate ( element ) ) { return false ; } } } return true ; }
public static < e > iterator < e > filter iterator ( final iterator < ? extend e > iterator , final predicate < ? super e > predicate ) { if ( iterator == null ) { throw new null pointer exception ( `` iterator must not be null `` ) ; } if ( predicate == null ) { throw new null pointer exception ( `` predicate must not be null `` ) ; } return new filter iterator < > ( iterator , predicate ) ; }
protect k generate actual key ( k key , v value ) { return key ; }
public char index replace ( int index , char equivalent key ) { assert index > = 0 : `` the index must point at an exist key . `` ; assert index < = mask || ( index == mask + 1 & & have empty key ) ; assert ( ( equivalent key ) == ( key [ index ] ) ) ; char previous value = key [ index ] ; key [ index ] = equivalent key ; return previous value ; }
public boolean equal ( object other ) { return ( this == other || ( other instanceof bean component definition & & super . equal ( other ) ) ) ; }
public void set header ( string header ) { this . header = header ; }
public node get node ( ) { return node ; }
public list iterator list iterator ( ) { return list iterator ( 0 ) ; }
public static < e > list < e > get list ( object list ) { return get list ( list , false ) ; }
public e set ( final int index , final e element ) { final int size = decorate ( ) . size ( ) ; if ( index > = size ) { decorate ( ) . add all ( collection . < e > n copy ( index - size + 1 , null ) ) ; } return decorate ( ) . set ( index , element ) ; }
public void add ( final int index , final e element ) { final int size = decorate ( ) . size ( ) ; if ( index > size ) { decorate ( ) . add all ( collection . < e > n copy ( index - size , null ) ) ; } decorate ( ) . add ( index , element ) ; }
public static boolean be whitespace ( int c ) { return c == ' ' || c == '\t ' || c == '\n ' || c == '\f ' || c == '\r ' ; }
public static < e > list < e > predicated list ( final list < e > list , final predicate < e > predicate ) { return predicate list . predicate list ( list , predicate ) ; }
public void add predicate ( predicate predicate ) { if ( this . predicate == collection . empty_list ) { this . predicate = new array list ( ) ; } this . predicate . add ( predicate ) ; }
public void set context ( object data ) { this . data = data ; }
public final int hash code ( ) { return pattern . hash code ( ) ; }
public int index of ( object key ) { key = convert key ( key ) ; int i = 0 ; for ( link entry < k , v > entry = header . after ; entry ! = header ; entry = entry . after , i++ ) { if ( be equal key ( key , entry . key ) ) { return i ; } } return -1 ; }
public static map invert map ( map map ) { map out = new hash map ( map . size ( ) ) ; for ( iterator it = map . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; out . put ( entry . get value ( ) , entry . get key ( ) ) ; } return out ; }
public k next key ( final object key ) { final link entry < k , v > entry = get entry ( key ) ; return entry == null || entry . after == header ? null : entry . after . get key ( ) ; }
public static < e > list < e > get list ( object list ) { return get list ( list , false ) ; }
public v put ( int index , final k key , final v value ) { if ( index < 0 || index > insert order . size ( ) ) { throw new index out of bound exception ( `` index : `` + index + `` , size : `` + insert order . size ( ) ) ; } final map < k , v > m = decorate ( ) ; if ( m . contains key ( key ) ) { final v result = m . remove ( key ) ; final int po = insert order . index of ( key ) ; insert order . remove ( po ) ; if ( po < index ) { index -- ; } insert order . add ( index , key ) ; m . put ( key , value ) ; return result ; } insert order . add ( index , key ) ; m . put ( key , value ) ; return null ; }
public k get key ( final int index ) { return key [ index ] ; }
public boolean add all ( collection coll ) { return add all ( size ( ) , coll ) ; }
public int count ( ) { return count ; }
public void add predicate ( predicate predicate ) { if ( this . predicate == collection . empty_list ) { this . predicate = new array list ( ) ; } this . predicate . add ( predicate ) ; }
public int [ ] [ ] long common substring length array ( final char sequence leave , final char sequence right ) { final int [ ] [ ] lcs length array = new int [ leave . length ( ) + 1 ] [ right . length ( ) + 1 ] ; for ( int i = 0 ; i < leave . length ( ) ; i++ ) { for ( int j = 0 ; j < right . length ( ) ; j++ ) { if ( i == 0 ) { lcs length array [ i ] [ j ] = 0 ; } if ( j == 0 ) { lcs length array [ i ] [ j ] = 0 ; } if ( left . char at ( i ) == right . char at ( j ) ) { lcs length array [ i + 1 ] [ j + 1 ] = lcs length array [ i ] [ j ] + 1 ; } else { lcs length array [ i + 1 ] [ j + 1 ] = math . max ( lcs length array [ i + 1 ] [ j ] , lcs length array [ i ] [ j + 1 ] ) ; } } } return lcs length array ; }
public int size ( ) { int size = 0 ; for ( final collection < e > item : all ) { size += item . size ( ) ; } return size ; }
public boolean be empty ( ) { for ( final collection < e > item : all ) { if ( item . be empty ( ) == false ) { return false ; } } return true ; }
public static boolean be array ( object obj ) { return ( obj ! = null & & obj . get class ( ) . be array ( ) ) ; }
public static < e > list < e > get list ( object list ) { return get list ( list , false ) ; }
public static byte sort set unmodifiable ( final byte sort set s ) { return new unmodifiable sort set ( s ) ; }
public < e extend t > e max ( @ nullable e a , @ nullable e b ) { return ( compare ( a , b ) > = 0 ) ? a : b ; }
public k next key ( final object key ) { final link entry < k , v > entry = get entry ( key ) ; return entry == null || entry . after == header ? null : entry . after . get key ( ) ; }
public synchronize void write ( int b ) { write ( new byte [ ] { ( byte ) b } , 0 , 1 ) ; }
public string get encode ( ) { return encode ; }
public string get comment ( ) { return comment ; }
public void set creation date ( calendar creation ) { get c o s object ( ) . set embedded date ( `` params `` , `` creation date `` , creation ) ; }
public http header get header ( ) { return this . header ; }
public int get id ( ) { return id ; }
public void write ( file new file ) throw i o exception { try ( p o i f s file system fs = p o i f s file system . create ( new file ) ) { write ( f ) ; f . write filesystem ( ) ; } }
public record [ ] get child record ( ) { return null ; }
public static boolean be public ( int flag ) { return ( flags & public ) ! = 0 ; }
public static void put long ( final long value , final byte [ ] buf , int offset ) { byte utils . to little endian ( buf , value , offset , 4 ) ; }
public synchronize void close ( ) throw i o exception { if ( in ! = null ) { in . close ( ) ; slack = null ; in = null ; } }
protect void set internal date ( final string date ) { this . date = date ; }
public int get c r c ( ) { return crc ; }
public method get method ( ) { return method ; }
protect void trim stack frame ( list stack ) { for ( int size=stacks . size ( ) , i=size-1 ; i > 0 ; i -- ) { string [ ] curr = ( string [ ] ) stack . get ( i ) ; string [ ] next = ( string [ ] ) stack . get ( i-1 ) ; list curr list = new array list ( arrays . a list ( curr ) ) ; list next list = new array list ( arrays . a list ( next ) ) ; exception utils . remove common frame ( curr list , next list ) ; int trim = curr . length - curr list . size ( ) ; if ( trim > 0 ) { curr list . add ( `` \t . . . `` +trimmed+ `` more `` ) ; stack . set ( i , curr list . to array ( new string [ curr list . size ( ) ] ) ) ; } } }
public static long compute check sum ( byte [ ] buf ) { long sum = 0 ; for ( int i = 0 ; i < buf . length ; ++i ) { sum += 255 & buf [ i ] ; } return sum ; }
public string [ ] index ( ) { return index ; }
public boolean available ( ) { return read index ! = write index ; }
public string get descriptor ( ) { return descriptor ; }
public double compression ( ) { return compression ; }
public input stream get input stream ( ) { return stream ; }
public final void write ( char buf [ ] ) throw i o exception { write ( buf , 0 , buf . length ) ; }
public list < string > get modify file ( ) { return modify file ; }
public void set flag ( byte flag ) { this . flag = flag ; }
public output < integer > num present ( ) { return num present ; }
public long get d ( ) { return d ; }
public static final long convert64 ( final byte [ ] buffer , final int offset ) { return byte utils . from little endian ( buffer , offset , 8 ) ; }
public final void set parameter ( final parameter [ ] parameter ) { this . parameter = parameter ; set initialize ( false ) ; }
public string get filename ( ) { return filename ; }
public int get offset ( ) { return offset ; }
public byte [ ] get signature ( ) { return signature ; }
public static string get matching character ( final string character , final string input , final int maximum length ) { final string builder sb = new string builder ( input . length ( ) ) ; for ( int i = 0 ; i < input . length ( ) ; i++ ) { final char c = input . char at ( i ) ; if ( character . index of ( c ) ! = -1 ) { if ( sb . length ( ) < maximum length ) { sb . append ( c ) ; } else { break ; } } } return sb . to string ( ) ; }
public void set cache ( boolean cache ) { this . cache = cache ; }
public void skip w p byte ( int num of byte ) throw i o exception { for ( int i = 0 ; i < num of byte ; i++ ) { read w p byte ( ) ; } }
public void remove extra field ( zip short type ) { if ( extra field == null ) { throw new java . util . no such element exception ( ) ; } if ( extra field . remove ( type ) == null ) { throw new java . util . no such element exception ( ) ; } set extra ( ) ; }
public boolean be delete content ( ) { return f delete content ; }
public static string get compress filename ( final string filename ) { return file name util . get compressed filename ( filename ) ; }
public static int load byte ( final input stream input stream , final byte [ ] array ) throw i o exception { return read ( input stream , array , 0 , array . length ) ; }
public int get offset ( ) { return offset ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public string get arg name ( ) { return default arg name ; }
public boolean be final ( ) { return this == final ; }
public final file get pack directory ( ) { return pack directory ; }
public boolean have next ( ) { return false ; }
public byte [ ] to byte array ( ) throw i o exception { byte array output stream output = new byte array output stream ( ) ; input stream be = null ; try { be = create input stream ( ) ; i o utils . copy ( be , output ) ; } finally { if ( be ! = null ) { be . close ( ) ; } } return output . to byte array ( ) ; }
public string get public id ( ) { return public id ; }
public reader reader value ( ) { return field data instanceof reader ? ( reader ) field data : null ; }
public stack get stack ( ) { return stack ; }
public locator get location ( ) { return d o m locator . get location info ( e ) ; }
public declaration get declaration by id ( string id ) { declaration decl = declaration by id . get ( id ) ; if ( ( decl == null ) & & ( parent ! = null ) ) { decl = parent . get declaration by id ( id ) ; } return decl ; }
public void clear ( ) { registered rule . clear ( ) ; }
public i content type matcher get matcher ( ) { return matcher ; }
public void clear ( ) { decorate rule . clear ( ) ; }
public string get namespace u r i ( ) { return namespace . get u r i ( ) ; }
public void add child ( unknown element child ) { if ( child == null ) { child = new array list ( ) ; } child . add ( child ) ; }
public void add rule ( string pattern , rule rule ) { rule . set digester ( this ) ; get rule ( ) . add ( pattern , rule ) ; }
public void set digester ( digester digester ) { wrap rule . set digester ( digester ) ; iterator it = default rule . iterator ( ) ; while ( it . have next ( ) ) { rule rule = ( rule ) it . next ( ) ; rule . set digester ( digester ) ; } }
public rule operation error collection get error ( ) { return this . error ; }
public param type get param type ( ) { return param type ; }
public stack get stack ( ) { return stack ; }
public void set validating ( boolean validating ) { this . validate = validating ; }
public string get message ( ) { return message ; }
public void set property name ( string property name ) { this . property name = property name ; }
public string get method name ( ) { return method name ; }
public param type get param type ( ) { return param type ; }
public call method builder with param type ( class < ? > . . . param type ) { this . param type = param type ; if ( param type ! = null ) { this . param count = param type . length ; } else { param count = 0 ; } return this ; }
public plugin management get plugin management ( ) { return this . plugin management ; } // -- plugin management get plugin management ( )
public set property builder set property ( string attribute property name ) { if ( attribute property name == null || attribute property name . length ( ) == 0 ) { main binder . add error ( `` { for pattern ( \ `` % s\ `` ) . set property ( string ) } empty 'attribute property name ' not allow `` , key pattern ) ; } return add provider ( new set property builder ( key pattern , namespace u r i , main binder , this , attribute property name ) ) ; }
public static logger get log ( ) { return runtime singleton . get log ( ) ; }
public void set namespace aware ( boolean namespace aware ) { this . namespace aware = namespace aware ; }
public digester loader set validating ( boolean validating ) { factory . set validating ( validate ) ; return this ; }
public t get ( ) { return t ; }
public rule get rule ( ) { return this . rule ; }
public object param builder < t > of index ( int param index ) { if ( param index < 0 ) { this . report error ( `` object param ( % s ) . of index ( int ) `` , `` negative index argument not allow `` ) ; } this . param index = param index ; return this ; }
public void trace ( object message , object [ ] params ) { do log ( level . trace , fqcn , message , params , null ) ; }
public string get id ( ) { return id ; }
public void set type declaration ( type declaration decl ) { internal set type declaration ( decl ) ; }
public void set argument ( object [ ] argument ) { this . argument = argument ; }
public object get result ( ) { return result ; }
public servlet input stream create input stream ( ) throw i o exception { if ( input stream == null ) { input stream = new coyote input stream ( input buffer ) ; } return input stream ; }
public void set process input stream ( final output stream o ) { if ( input ! = null ) { if ( input == system . in ) { input thread = create system in pump ( input , o ) ; } else { input thread = create pump ( input , o , true ) ; } } else { try { o . close ( ) ; } catch ( final i o exception e ) { final string msg = `` get exception while close output stream `` ; debug utils . handle exception ( msg , e ) ; } } }
public static command < void > continue with auth ( request id request id , auth challenge response auth challenge response ) { object . require non null ( request id , `` request id be require `` ) ; object . require non null ( auth challenge response , `` auth challenge response be require `` ) ; return new command < > ( `` fetch . continue with auth `` , immutable map . of ( `` request id `` , request id . to string ( ) , `` auth challenge response `` , auth challenge response ) ) ; }
public credential get credential ( ) { return credential ; }
public void set class realm ( class realm class realm ) { this . class realm = class realm ; }
public int read ( ) throw i o exception { int b = read first byte ( ) ; return b > = 0 ? b : in . read ( ) ; }
public cookie get ( string cookie name ) { assert parameter . not null ( cookie name , `` cookie name `` ) ; return cooky . get ( cookie name ) ; }
public void set header ( string header ) { this . header = header ; }
public void set header ( string header ) { this . header = header ; }
public void set host ( string host ) { this . host = host ; } // -- void set host ( string )
public void set timeout ( time value timeout ) { this . timeout = timeout ; }
public boolean be enable ( ) { return this . enable ; }
public input stream get input stream ( ) { return stream ; }
public boolean be close ( ) { return close ; }
public reason get reason ( ) { return this . reason ; }
public static query string query builder query string query ( string query string ) { return new query string query builder ( query string ) ; }
public header get request header ( string header name ) { if ( header name == null ) { return null ; } else { return get request header group ( ) . get condensed header ( header name ) ; } }
public void set request header ( header header ) { header [ ] header = get request header group ( ) . get header ( header . get name ( ) ) ; for ( int i = 0 ; i < header . length ; i++ ) { get request header group ( ) . remove header ( header [ i ] ) ; } get request header group ( ) . add header ( header ) ; }
public void set strict parsing ( boolean be strict ) { this . be strict parse = be strict ; }
public string get content ( ) { if ( char == null ) { return null ; } return new string ( char ) ; }
public void set proxy ( web proxy proxy ) { this . proxy = proxy ; }
public static boolean be transmittable ( int status code ) { return ( status code == normal ) || ( status code == shutdown ) || ( status code == protocol ) || ( status code == bad_data ) || ( status code == bad_payload ) || ( status code == policy_violation ) || ( status code == message_too_large ) || ( status code == required_extension ) || ( status code == server_error ) || ( status code == service_restart ) || ( status code == try_again_later ) || ( status code == invalid_upstream_response ) ; }
public int get port ( ) { return _port ; }
public string get path ( ) throw u r i exception { char [ ] path = get raw path ( ) ; return ( path == null ) ? null : decode ( path , get protocol charset ( ) ) ; }
public void set request body type ( body type request body type ) { this . throw if readonly ( ) ; this . request body type = request body type ; }
public final http params get request params ( ) { return request params ; }
public output < t > out ( ) { return out ; }
public void set part ( integer part ) { set integer property ( prefix+ `` : part `` , part ) ; }
public string get content ( ) { if ( char == null ) { return null ; } return new string ( char ) ; }
public enumeration get allow method ( ) { check use ( ) ; return method allow . element ( ) ; }
public boolean be allow ( string method ) { check use ( ) ; return method allow . contains ( method ) ; }
public void set allow header name ( predicate < string > allow header name ) { assert . not null ( allow header name , `` allow header name can not be null `` ) ; this . allow header name = allow header name ; }
public boolean need semaphore ( ) { return false ; }
protect @ non null string validate host ( @ non null string host ) { if ( ! host . equal ( default_host ) ) { host resolution configuration configuration = server configuration . get host resolution ( ) ; if ( configuration ! = null ) { list < pattern > allow host = configuration . get allow host ( ) ; if ( ! allow host . be empty ( ) & & allow host . stream ( ) . map ( pattern - > pattern . matcher ( host ) ) . none match ( matcher : : match ) ) { return default_host ; } } } return host ; }
public void set parameter ( parameter [ ] parameter ) { if ( parameter ! = null ) { for ( int i = 0 ; i < parameter . length ; i++ ) { config parameter . add ( parameter [ i ] ) ; } } }
public synchronize void set http connection factory timeout ( long timeout ) { this . params . set connection manager timeout ( timeout ) ; }
public boolean be boolean ( ) { return false ; }
public void set ( boolean value ) { this . value = value ; }
public final void set first row relative ( boolean rel ) { field_3_first_column=row relative . set boolean ( field_3_first_column , rel ) ; }
public string get protocol ( ) { return protocol ; }
public io . vertx . reactivex . ext . web . handler . auth handler add authority ( set < string > authority ) { delegate . add authority ( authority ) ; return this ; }
public int get port ( ) { return ( _port == -1 ) ? http u r l . default_port : _port ; }
public path get path ( ) { return path ; }
public void set basenames ( string . . . basenames ) { if ( basenames ! = null ) { this . basenames = new string [ basenames . length ] ; for ( int i = 0 ; i < basenames . length ; i++ ) { string basename = basenames [ i ] ; assert . have text ( basename , `` basename must not be empty `` ) ; this . basenames [ i ] = basename . trim ( ) ; } } else { this . basenames = new string [ 0 ] ; } }
public boolean be fragment ( ) { return fragment ; }
public set < string > get reference string ( ) { return reference string ; }
public string get password ( ) { return this . password ; } // -- string get password ( )
public static date convert date string to date ( string value ) { return parse internal ( value , true ) ; }
public object parse ( byte [ ] byte , string charset ) { if ( bytes == null ) { throw new illegal argument exception ( `` byte must not be null `` ) ; } if ( charset == null ) { throw new illegal argument exception ( `` charset must not be null `` ) ; } object content ; content = create parser ( ) . parse ( byte , charset ) ; return content ; }
public void set connection ( string connection ) { this . connection = connection ; } // -- void set connection ( string )
public void write p d f ( output stream output ) throw i o exception { output . write ( value a string . get byte ( `` iso-8859-1 `` ) ) ; }
public servlet input stream create input stream ( ) throw i o exception { if ( input stream == null ) { input stream = new coyote input stream ( input buffer ) ; } return input stream ; }
public static void write swap short ( final output stream output , final short value ) throw i o exception { output . write ( ( byte ) ( ( value > > 0 ) & 0xff ) ) ; output . write ( ( byte ) ( ( value > > 8 ) & 0xff ) ) ; }
public file get dir ( ) { return this . dir ; }
public static void copy file ( final file src file , final file d file ) throw i o exception { copy file ( src file , d file , standard copy option . copy_attributes , standard copy option . replace_existing ) ; }
public void set counter ( counter counter ) { this . counter = counter ; }
public void set path filter ( tree filter filter ) { path filter = filter ! = null ? filter : tree filter . all ; }
public static void create directory ( string directory name ) { file path . get ( directory name ) . create directory ( ) ; }
public t get result ( ) { return result ; }
public boolean accept ( final file file ) { return accept ( file . get name ( ) ) ; }
public boolean accept ( final file file ) { if ( file . be directory ( ) ) { final file [ ] file = file . list file ( ) ; return i o utils . length ( file ) == 0 ; } return file . length ( ) == 0 ; }
public file get file ( ) { return file ; }
public static i o file filter a file filter ( file filter filter ) { return new delegate file filter ( filter ) ; }
public static i o file filter a file filter ( file filter filter ) { return new delegate file filter ( filter ) ; }
public validate object input stream accept ( final string . . . pattern ) { for ( final string pattern : pattern ) { accept matcher . add ( new wildcard class name matcher ( pattern ) ) ; } return this ; }
public boolean accept ( final file file ) { return file . be directory ( ) ; }
public static int last index of ( final boolean [ ] array , final boolean value to find ) { return last index of ( array , value to find , integer . max_value ) ; }
public string get file path ( ) { return file path ; }
public boolean accept ( final file file ) { if ( file . be directory ( ) ) { final file [ ] file = file . list file ( ) ; return i o utils . length ( file ) == 0 ; } return file . length ( ) == 0 ; }
public static checksum checksum ( file file , checksum checksum ) throw i o exception { if ( file . be directory ( ) ) { throw new illegal argument exception ( `` checksum ca n't be compute on directory `` ) ; } input stream in = null ; try { in = new check input stream ( new file input stream ( file ) , checksum ) ; i o utils . copy ( in , new null output stream ( ) ) ; } finally { i o utils . close quietly ( in ) ; } return checksum ; }
public static void copy directory ( final file src dir , final file d dir , final file filter filter , final boolean preserve file date ) throw i o exception { copy directory ( src dir , d dir , filter , preserve file date , standard copy option . replace_existing ) ; }
public static void copy directory ( final file src dir , final file d dir , final boolean preserve file date ) throw i o exception { copy directory ( src dir , d dir , null , preserve file date ) ; }
protect void copy ( final path source file , final path target file ) throw i o exception { file . copy ( source file , target file , copy option ) ; }
public static i o file filter a file filter ( file filter filter ) { return new delegate file filter ( filter ) ; }
public static void move to directory ( final file src , final file d dir , final boolean create d dir ) throw i o exception { validate move parameter ( src , d dir ) ; if ( src . be directory ( ) ) { move directory to directory ( src , d dir , create d dir ) ; } else { move file to directory ( src , d dir , create d dir ) ; } }
public static void move directory to directory ( final file src , final file d dir , final boolean create d dir ) throw i o exception { validate move parameter ( src , d dir ) ; if ( ! d dir . be directory ( ) ) { if ( d dir . exists ( ) ) { throw new i o exception ( `` destination ' `` + d dir + `` ' be not a directory `` ) ; } if ( ! create d dir ) { throw new file not find exception ( `` destination directory ' `` + d dir + `` ' do not exist [ create d dir= `` + false + `` ] `` ) ; } mkdirs ( d dir ) ; } move directory ( src , new file ( d dir , src . get name ( ) ) ) ; }
public static void write ( string data , output stream output ) throw i o exception { write ( data , output , charset . default charset ( ) ) ; }
public int count ( ) { return count ; }
protect void set name source start ( int start ) { this . name start= start ; }
public input stream get input stream ( ) { return input stream ; }
public long get n ( ) { return n ; }
public void add observer ( final file alteration observer observer ) { if ( observer ! = null ) { observer . add ( observer ) ; } }
public void add ( final observer observer ) { observer . add ( observer ) ; }
public int read ( ) throw i o exception { throw new i o exception ( ) ; }
public boolean be close ( ) { return close ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public instant instant value ( ) { instant ret = delegate . instant value ( ) ; return ret ; }
public final collection < t > to collection ( ) { list < t > list = new array list < t > ( ) ; add to ( list ) ; return list ; }
public final connection get innermost delegate internal ( ) { connection conn = connection ; while ( conn ! = null & & conn instanceof delegate connection ) { conn = ( ( delegate connection < ? > ) conn ) . get delegate internal ( ) ; if ( this == conn ) { return null ; } } return conn ; }
public static list < string > read line ( url url , charset charset ) throw i o exception { return char stream . read line ( new reader supplier ( url , charset ) ) ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public node get parent ( ) { return parent ; }
public static int space ( byte buffer buffer ) { if ( buffer == null ) return 0 ; return buffer . capacity ( ) - buffer . limit ( ) ; }
public char sequence sub sequence ( int start , int end ) { return new char slice ( array , offset+start , end-start ) ; }
public void set st offset ( int st ) { this . st offset = st ; }
public void write ( final char [ ] cbuf , final int off , final int len ) throw i o exception { out . write ( cbuf , off , len ) ; }
public void write ( final char [ ] cbuf , final int off , final int len ) throw i o exception { list < exception > cause list = null ; int i = 0 ; for ( final writer w : writer ) { if ( w ! = null ) { try { w . write ( cbuf , off , len ) ; } catch ( final i o exception e ) { cause list = add ( cause list , i , e ) ; } } i++ ; } if ( not empty ( cause list ) ) { throw new i o exception list ( `` write `` , cause list ) ; } }
public writer append ( char sequence value ) { builder . append ( value ) ; return this ; }
public tag tag ( ) { return tag ; }
@ override public void flush ( ) throw i o exception { delegate . flush ( ) ; }
public int get threshold ( ) { return current threshold ; }
public void set count ( int count ) { this . count = count ; }
public string [ ] get pattern ( ) { return pattern ; }
public static i o file filter not file filter ( final i o file filter filter ) { return filter . negate ( ) ; }
public void set output ( file file ) throw i o exception { create x m l writer ( ) . set output stream ( new file output stream ( file ) ) ; }
protect void set internal date ( final string date ) { this . date = date ; }
public static data checksum read data checksum ( file meta file ) throw i o exception { data input stream in = null ; try { in = new data input stream ( new buffer input stream ( new file input stream ( meta file ) , hdfs constant . io_file_buffer_size ) ) ; return read data checksum ( in , meta file ) ; } finally { i o utils . close stream ( in ) ; } }
public static void read fully ( input stream in , byte [ ] b ) throw i o exception { read fully ( in , b , 0 , b . length ) ; }
public string to string ( ) { return to string ( `` `` ) ; }
public int get position ( ) { return position ; }
public int read ( ) throw i o exception { throw new i o exception ( ) ; }
public int read int ( ) throw i o exception { return read int ( this ) ; }
public line string get line ( ) { return line ; }
public static void copy ( final input stream input , final writer output , final charset input encode ) throw i o exception { final input stream reader in = new input stream reader ( input , charsets . to charset ( input encode ) ) ; copy ( in , output ) ; }
public static void write ( final char [ ] data , final writer output ) throw i o exception { if ( data ! = null ) { output . write ( data ) ; } }
public static long copy large ( final input stream input , final output stream output , final long input offset , final long length ) throw i o exception { return copy large ( input , output , input offset , length , new byte [ default_buffer_size ] ) ; }
public static boolean be valid compress buffer ( byte [ ] input , int offset , int length ) throw i o exception { if ( input == null ) throw new null pointer exception ( `` input be null `` ) ; return impl . be valid compress buffer ( input , offset , length ) ; }
public void add ( final observer observer ) { observer . add ( observer ) ; }
public writer append ( final char value ) { builder . append ( value ) ; return this ; }
public string get all thread ( boolean without monitor ) { return pepper thread dumper . get thread dump a string ( ! without monitor ) ; }
public static void write ( string data , output stream output ) throw i o exception { write ( data , output , charset . default charset ( ) ) ; }
public input stream get input stream ( boolean long output ) throw i o exception { return get input stream ( long output , `` `` ) ; }
public static input stream to input stream ( string input , charset encode ) { return new byte array input stream ( input . get byte ( charsets . to charset ( encode ) ) ) ; }
public static boolean [ ] to primitive ( boolean [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_boolean_array ; } final boolean [ ] result = new boolean [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . boolean value ( ) ; } return result ; }
public static short [ ] to primitive ( final short [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_short_array ; } final short [ ] result = new short [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . short value ( ) ; } return result ; }
public static int [ ] to primitive ( integer [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_int_array ; } final int [ ] result = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . int value ( ) ; } return result ; }
public static boolean be empty ( object [ ] array ) { return array == null || array . length == 0 ; }
public boolean be index object ( ) { return index object ; }
public value holder get generic argument value ( class < ? > require type , string require name , set < value holder > use value holder ) { for ( value holder value holder : this . generic argument value ) { if ( use value holder ! = null & & use value holder . contains ( value holder ) ) { continue ; } if ( value holder . get name ( ) ! = null & & ( require name == null || ! value holder . get name ( ) . equal ( require name ) ) ) { continue ; } if ( value holder . get type ( ) ! = null & & ( require type == null || ! class utils . match type name ( require type , value holder . get type ( ) ) ) ) { continue ; } if ( require type ! = null & & value holder . get type ( ) == null & & value holder . get name ( ) == null & & ! class utils . be assignable value ( require type , value holder . get value ( ) ) ) { continue ; } return value holder ; } return null ; }
public equal builder append ( double [ ] lh , double [ ] rh ) { if ( be equal == false ) { return this ; } if ( lhs == rh ) { return this ; } if ( lhs == null || rh == null ) { this . set equal ( false ) ; return this ; } if ( lh . length ! = rh . length ) { this . set equal ( false ) ; return this ; } for ( int i = 0 ; i < lh . length & & be equal ; ++i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public compare to builder append ( boolean [ ] lh , boolean [ ] rh ) { if ( comparison ! = 0 ) { return this ; } if ( lhs == rh ) { return this ; } if ( lhs == null ) { comparison = -1 ; return this ; } if ( rhs == null ) { comparison = +1 ; return this ; } if ( lh . length ! = rh . length ) { comparison = ( lh . length < rh . length ) ? -1 : +1 ; return this ; } for ( int i = 0 ; i < lh . length & & comparison == 0 ; i++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public compare to builder append ( byte [ ] lh , byte [ ] rh ) { if ( comparison ! = 0 ) { return this ; } if ( lhs == rh ) { return this ; } if ( lhs == null ) { comparison = -1 ; return this ; } if ( rhs == null ) { comparison = +1 ; return this ; } if ( lh . length ! = rh . length ) { comparison = ( lh . length < rh . length ) ? -1 : +1 ; return this ; } for ( int i = 0 ; i < lh . length & & comparison == 0 ; i++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public equal builder append ( double [ ] lh , double [ ] rh ) { if ( be equal == false ) { return this ; } if ( lhs == rh ) { return this ; } if ( lhs == null || rh == null ) { this . set equal ( false ) ; return this ; } if ( lh . length ! = rh . length ) { this . set equal ( false ) ; return this ; } for ( int i = 0 ; i < lh . length & & be equal ; ++i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public equal builder append ( short [ ] lh , short [ ] rh ) { if ( be equal == false ) { return this ; } if ( lhs == rh ) { return this ; } if ( lhs == null || rh == null ) { this . set equal ( false ) ; return this ; } if ( lh . length ! = rh . length ) { this . set equal ( false ) ; return this ; } for ( int i = 0 ; i < lh . length & & be equal ; ++i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; }
public hash code builder append ( byte [ ] array ) { if ( array == null ) { i total = i total * i constant ; } else { for ( int i = 0 ; i < array . length ; i++ ) { append ( array [ i ] ) ; } } return this ; }
public string get field name ( ) { return field name ; }
public void set separator ( string separator ) { this . separator = separator ; }
public to string builder append a object to string ( object object ) { object utils . identity to string ( this . get string buffer ( ) , object ) ; return this ; }
public to string builder append ( int [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; }
public to string builder append ( int [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; }
public to string builder append ( double [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; }
public to string builder append ( int value ) { style . append ( buffer , null , value ) ; return this ; }
public static void identity to string ( string buffer buffer , object object ) { if ( object == null ) { throw new null pointer exception ( `` can not get the to string of a null identity `` ) ; } buffer . append ( object . get class ( ) . get name ( ) ) . append ( ' @ ' ) . append ( integer . to hex string ( system . identity hash code ( object ) ) ) ; }
public string to string ( ) { return to string buffer ( ) . to string ( ) ; }
protect void append detail ( string buffer buffer , string field name , char [ ] array ) { buffer . append ( array start ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( i > 0 ) { buffer . append ( array separator ) ; } append detail ( buffer , field name , array [ i ] ) ; } buffer . append ( array end ) ; }
protect void append detail ( string buffer buffer , string field name , float [ ] array ) { buffer . append ( array start ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( i > 0 ) { buffer . append ( array separator ) ; } append detail ( buffer , field name , array [ i ] ) ; } buffer . append ( array end ) ; }
protect void append detail ( string buffer buffer , string field name , char [ ] array ) { buffer . append ( array start ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( i > 0 ) { buffer . append ( array separator ) ; } append detail ( buffer , field name , array [ i ] ) ; } buffer . append ( array end ) ; }
protect void append detail ( string buffer buffer , string field name , char [ ] array ) { buffer . append ( array start ) ; for ( int i = 0 ; i < array . length ; i++ ) { if ( i > 0 ) { buffer . append ( array separator ) ; } append detail ( buffer , field name , array [ i ] ) ; } buffer . append ( array end ) ; }
public static char range be not ( char ch ) { return new char range ( ch , ch , true ) ; }
public static char range be ( char ch ) { return new char range ( ch , ch , false ) ; }
public static string to string ( byte [ ] array ) { string builder buf = new string builder ( ) ; buf . append ( ' [ ' ) ; int max index = array . length - 1 ; for ( int i = 0 ; i < = max index ; i++ ) { buf . append ( array [ i ] ) ; if ( i < max index ) { buf . append ( `` , `` ) ; } } buf . append ( ' ] ' ) ; return buf . to string ( ) ; }
public static string get package canonical name ( class cl ) { if ( cls == null ) { return string utils . empty ; } return get package canonical name ( cl . get name ( ) ) ; }
public static string get package name ( class cl ) { if ( cls == null ) { return string utils . empty ; } return get package name ( cl . get name ( ) ) ; }
public class < ? > resolve bean class ( class loader class loader ) throw class not find exception { string class name = get bean class name ( ) ; if ( class name == null ) { return null ; } class < ? > resolve class = class utils . for name ( class name , class loader ) ; this . bean class = resolve class ; return resolve class ; }
public static string get package name ( class cl ) { if ( cls == null ) { return string utils . empty ; } return get package name ( cl . get name ( ) ) ; }
public class < ? > get value class ( ) { return object . class ; }
public final throwable get throwable ( ) { return throwable ; }
public final throwable get throwable ( ) { return throwable ; }
public void add ( throwable t ) { throwables . add ( t ) ; }
public void close archive entry ( ) throw i o exception { if ( finish ) { throw new i o exception ( `` stream have already be finish `` ) ; } if ( ! have unclosed entry ) { throw new i o exception ( `` no current entry to close `` ) ; } out . flush block ( ) ; if ( curr bytes < curr size ) { throw new i o exception ( `` entry ' `` + curr name + `` ' close at ' `` + curr bytes + `` ' before the ' `` + curr size + `` ' byte specify in the header be write `` ) ; } record write += ( curr size / record_size ) ; if ( 0 ! = curr size % record_size ) { record written++ ; } have unclosed entry = false ; }
protect object sput ( object key , object value , int hash ) { entry [ ] tab = table ; int index = hash & ( tab . length - 1 ) ; entry first = tab [ index ] ; entry e = first ; for ( ; ; ) { if ( e == null ) { entry new entry = new entry ( hash , key , value , first ) ; tab [ index ] = new entry ; if ( ++count > = threshold ) rehash ( ) ; else record modification ( new entry ) ; return null ; } else if ( e . hash == hash & & eq ( key , e . key ) ) { object old value = e . value ; e . value = value ; return old value ; } else e = e . next ; } }
protect object sput ( object key , object value , int hash ) { entry [ ] tab = table ; int index = hash & ( tab . length - 1 ) ; entry first = tab [ index ] ; entry e = first ; for ( ; ; ) { if ( e == null ) { entry new entry = new entry ( hash , key , value , first ) ; tab [ index ] = new entry ; if ( ++count > = threshold ) rehash ( ) ; else record modification ( new entry ) ; return null ; } else if ( e . hash == hash & & eq ( key , e . key ) ) { object old value = e . value ; e . value = value ; return old value ; } else e = e . next ; } }
public parser configuration set tab size ( int tab size ) { this . tab size = tab size ; return this ; }
public locale get locale ( ) { return locale ; }
public int get min length ( ) { return min length ; }
public double get numerator degree of freedom ( ) { return numerator degree of freedom ; }
public void set denominator ( int denominator ) { this . get c o s object ( ) . set int ( `` d `` , denominator ) ; }
public static double function mod ( final double b ) { return new double function ( ) { @ override public double apply ( double a ) { return a % b ; } } ; }
public void set float value ( float float value ) { this . float value = float value ; }
public boolean contains number ( number number ) { if ( number == null ) { return false ; } return contains long ( number . long value ( ) ) ; }
public boolean have next ( ) { return false ; }
public boolean contains number ( number number ) { if ( number == null ) { return false ; } return contains integer ( number . int value ( ) ) ; }
public int get range ( ) { return i range ; }
public static int [ ] to primitive ( integer [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_int_array ; } final int [ ] result = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . int value ( ) ; } return result ; }
public void set integer value ( int integer value ) { this . integer value = integer value ; }
public object get value ( ) { return this . value ; }
public boolean be map ( ) { return true ; }
public boolean be boolean ( ) { return false ; }
public boolean equal ( object obj ) { if ( obj instanceof event ) { return to string ( ) . equal ( obj . to string ( ) ) ; } else { return false ; } }
public int hash code ( ) { return to string ( ) . hash code ( ) ; }
public void increment ( ) { sync . increment ( ) ; }
public boolean be na n ( ) { return be na n ; }
public void set long value ( long long value ) { this . long value = long value ; }
public void set float value ( float float value ) { this . float value = float value ; }
public int get range ( ) { return i range ; }
public static string identity to string ( final object object ) { return null == object ? null : object . get class ( ) . get name ( ) + ' @ ' + integer . to hex string ( system . identity hash code ( object ) ) ; }
public int count ( ) { return count ; }
public static void write field ( field field , object target , object value , boolean force access ) throw illegal access exception { if ( field == null ) { throw new illegal argument exception ( `` the field must not be null `` ) ; } if ( force access & & ! field . be accessible ( ) ) { field . set accessible ( true ) ; } else { member utils . set accessible workaround ( field ) ; } field . set ( target , value ) ; }
public static void write field ( field field , object target , object value , boolean force access ) throw illegal access exception { if ( field == null ) { throw new illegal argument exception ( `` the field must not be null `` ) ; } if ( force access & & ! field . be accessible ( ) ) { field . set accessible ( true ) ; } else { member utils . set accessible workaround ( field ) ; } field . set ( target , value ) ; }
public static date parse ( date self , string format , string input ) throw parse exception { return new simple date format ( format ) . parse ( input ) ; }
protect void validate index ( int index ) { if ( index < 0 || index > size ) { throw new string index out of bound exception ( index ) ; } }
public static string capitalize ( string str ) { int str len ; if ( str == null || ( str len = str . length ( ) ) == 0 ) { return str ; } return new string buffer ( str len ) . append ( character . to title case ( str . char at ( 0 ) ) ) . append ( str . substring ( 1 ) ) . to string ( ) ; }
protect int validate range ( int start index , int end index ) { if ( start index < 0 ) { throw new string index out of bound exception ( start index ) ; } if ( end index > size ) { end index = size ; } if ( start index > end index ) { throw new string index out of bound exception ( `` end < start `` ) ; } return end index ; }
public static string capitalize ( string str ) { int str len ; if ( str == null || ( str len = str . length ( ) ) == 0 ) { return str ; } return new string buffer ( str len ) . append ( character . to title case ( str . char at ( 0 ) ) ) . append ( str . substring ( 1 ) ) . to string ( ) ; }
public void set replace ( string replace ) { this . replace = project . to boolean ( replace ) ; }
public name or definition tokenizer ( ) { return this . tokenizer ; }
public int hash code ( ) { int hash = 3 ; hash = 17 * hash + ( this . value ! = null ? this . value . hash code ( ) : 0 ) ; hash = 17 * hash + ( this . weak ? 1 : 0 ) ; return hash ; }
public str builder delete ( int start index , int end index ) { end index = validate range ( start index , end index ) ; int len = end index - start index ; if ( len > 0 ) { delete impl ( start index , end index , len ) ; } return this ; }
protect void ensure restrict index ( final int index ) { if ( index < 0 ) throw new index out of bound exception ( `` index ( `` + index + `` ) be negative `` ) ; if ( index > = size ( ) ) throw new index out of bound exception ( `` index ( `` + index + `` ) be great than or equal to list size ( `` + ( size ( ) ) + `` ) `` ) ; }
public static map synchronize map ( map map ) { return collection . synchronize map ( map ) ; }
public static char range be ( char ch ) { return new char range ( ch , ch , false ) ; }
public string matcher string matcher ( final string str ) { if ( str == null || str . length ( ) == 0 ) { return none_matcher ; } return new abstract string matcher . string matcher ( str ) ; }
public i content type matcher get matcher ( ) { return matcher ; }
public i content type matcher get matcher ( ) { return matcher ; }
public boolean be quote ( ) { return be quote ; }
public void set empty value ( string empty value ) { this . empty value = empty value ; }
public boolean add token ( token < ? extend token identifier > token ) { return ( token ! = null ) ? add token ( token . get service ( ) , token ) : false ; }
public object parse ( char [ ] char ) { if ( char == null ) { throw new illegal argument exception ( `` char must not be null `` ) ; } object content ; content = create parser ( ) . parse ( char ) ; return content ; }
public void run ( ) { this . delegate . run ( ) ; }
public static void check argument ( boolean expression , string error message template , object . . . error message args ) { if ( ! expression ) throw new illegal argument exception ( format ( error message template , error message args ) ) ; }
public static boolean be empty ( string str ) { return ( str == null || str . length ( ) == 0 ) ; }
public void set ( object object , object value ) throw exception { }
public class [ ] get property type ( ) { return type . clone ( ) ; }
public < e extend enum < e > > void write optional enum ( @ nullable e enum value ) throw i o exception { if ( enum value == null ) { write boolean ( false ) ; } else { write boolean ( true ) ; write v int ( enum value . ordinal ( ) ) ; } }
public static < e extend enum < e > > boolean be valid enum ( class < e > enum class , string enum name ) { if ( enum name == null ) { return false ; } try { enum . value of ( enum class , enum name ) ; return true ; } catch ( illegal argument exception ex ) { return false ; } }
protect static final int hash code ( final object [ ] array ) { if ( array == null ) { return 0 ; } int hash code= array . get class ( ) . get name ( ) . hash code ( ) ; for ( object element : array ) { hash code= hash code * hash_factor + hash code ( element ) ; } return hash code ; }
public int compare to ( dot name other ) { index state s1 = new index state ( ) ; index state s2 = new index state ( ) ; for ( ; ; ) { int c1 = next char ( s1 , this ) ; int c2 = next char ( s2 , other ) ; if ( c1 == -1 ) { return c2 == -1 ? 0 : -1 ; } if ( c2 == -1 ) { return 1 ; } if ( c1 ! = c2 ) { return c1 - c2 ; } } }
public static < t > array < t > of all ( iterable < ? extend t > element ) { object . require non null ( element , `` element be null `` ) ; if ( element instanceof array ) { return ( array < t > ) elements ; } if ( element instanceof list view & & ( ( list view < t , ? > ) element ) . get delegate ( ) instanceof array ) { return ( array < t > ) ( ( list view < t , ? > ) element ) . get delegate ( ) ; } return wrap ( to array ( element ) ) ; }
public static void write field ( field field , object target , object value , boolean force access ) throw illegal access exception { if ( field == null ) { throw new illegal argument exception ( `` the field must not be null `` ) ; } if ( force access & & ! field . be accessible ( ) ) { field . set accessible ( true ) ; } else { member utils . set accessible workaround ( field ) ; } field . set ( target , value ) ; }
public static void write field ( field field , object target , object value , boolean force access ) throw illegal access exception { if ( field == null ) { throw new illegal argument exception ( `` the field must not be null `` ) ; } if ( force access & & ! field . be accessible ( ) ) { field . set accessible ( true ) ; } else { member utils . set accessible workaround ( field ) ; } field . set ( target , value ) ; }
public static numeric entity escaper outside of ( int codepoint low , int codepoint high ) { return new numeric entity escaper ( codepoint low , codepoint high , false ) ; }
public static numeric entity escaper outside of ( int codepoint low , int codepoint high ) { return new numeric entity escaper ( codepoint low , codepoint high , false ) ; }
public static numeric entity escaper between ( int codepoint low , int codepoint high ) { return new numeric entity escaper ( codepoint low , codepoint high , true ) ; }
public right get right ( ) { return right ; }
protect void validate index ( int index ) { if ( index < 0 || index > size ) { throw new string index out of bound exception ( index ) ; } }
public void set ( int index ) { if ( ( index < 0 ) || ( index > = size ( ) ) ) { return ; } set bit ( index ) ; }
public static int compare region ( byte [ ] array1 , int start idx1 , byte [ ] array2 , int start idx2 , int length ) { int result = 0 ; for ( int i = 0 ; result == 0 & & i < length ; i++ ) { result = ( array1 [ start idx1 + i ] & 0xff ) - ( array2 [ start idx2 + i ] & 0xff ) ; } return result ; }
public static int find last index of ( object self , closure closure ) { return find last index of ( self , 0 , closure ) ; }
public void add all ( json array array ) { element . add all ( array . element ) ; }
public static boolean be not empty ( int [ ] array ) { return ( array ! = null & & array . length ! = 0 ) ; }
public static void swap ( final int [ ] array , int offset1 , int offset2 , int len ) { if ( be empty ( array ) || offset1 > = array . length || offset2 > = array . length ) { return ; } if ( offset1 < 0 ) { offset1 = 0 ; } if ( offset2 < 0 ) { offset2 = 0 ; } len = math . min ( math . min ( len , array . length - offset1 ) , array . length - offset2 ) ; for ( int i = 0 ; i < len ; i++ , offset1++ , offset2++ ) { final int aux = array [ offset1 ] ; array [ offset1 ] = array [ offset2 ] ; array [ offset2 ] = aux ; } }
public static void swap ( final double [ ] array , final int offset1 , final int offset2 ) { if ( be empty ( array ) ) { return ; } swap ( array , offset1 , offset2 , 1 ) ; }
public static int [ ] to primitive ( integer [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_int_array ; } final int [ ] result = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . int value ( ) ; } return result ; }
public static int [ ] to primitive ( integer [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_int_array ; } final int [ ] result = new int [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . int value ( ) ; } return result ; }
public static class get wrapper type ( class primitive type ) { if ( primitive type . be primitive ( ) ) { return primitives_to_wrappers . get ( primitive type ) ; } return primitive type ; }
public static short [ ] to object ( short [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_short_object_array ; } final short [ ] result = new short [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = new short ( array [ i ] ) ; } return result ; }
public static boolean be transient ( int mod ) { return ( mod & transient ) ! = 0 ; }
public string [ ] get exclude mime type ( ) { set < string > exclude = _mime type . get excluded ( ) ; return exclude . to array ( new string [ exclude . size ( ) ] ) ; }
public int compare ( writable comparable a , writable comparable b ) { return a . compare to ( b ) ; }
public final void remove job change listener ( i job change listener listener ) { super . remove job change listener ( listener ) ; }
public int get threshold ( ) { return threshold ; }
public type get type ( ) { return type ; }
public static string replace first ( final string text , final pattern regex , final string replacement ) { if ( text == null || regex == null|| replacement == null ) { return text ; } return regex . matcher ( text ) . replace first ( replacement ) ; }
public static string replace first ( final string text , final pattern regex , final string replacement ) { if ( text == null || regex == null|| replacement == null ) { return text ; } return regex . matcher ( text ) . replace first ( replacement ) ; }
public static string replace all ( final string text , final string regex , final string replacement ) { if ( text == null || regex == null || replacement == null ) { return text ; } return text . replace all ( regex , replacement ) ; }
public void set delimiter ( string delimiter ) { this . delimiter = delimiter ; }
public @ not null thread get thread ( ) { return thread ; }
public @ not null thread get thread ( ) { return thread ; }
public void set calendar ( calendar calendar ) { this . calendar = calendar ; }
public static fast date format get date time instance ( final int date style , final int time style , final time zone time zone ) { return get date time instance ( date style , time style , time zone , null ) ; }
public static fast date format get date time instance ( final int date style , final int time style , final time zone time zone ) { return get date time instance ( date style , time style , time zone , null ) ; }
public static fast date format get time instance ( final int style , final time zone time zone ) { return cache . get time instance ( style , time zone , null ) ; }
public date time zone get time zone ( ) { return this . time zone ; }
public int hash code ( ) { return pattern . hash code ( ) + 13 * ( time zone . hash code ( ) + 13 * locale . hash code ( ) ) ; }
public list get stop class ( ) { return stop class ; }
public static string format ( long millis , string pattern , time zone time zone , locale locale ) { return format ( new date ( millis ) , pattern , time zone , locale ) ; }
public int hash code ( ) { return to string ( ) . hash code ( ) ; }
public int hash code ( ) { return pattern . hash code ( ) + 13 * ( time zone . hash code ( ) + 13 * locale . hash code ( ) ) ; }
public logger get logger ( string name ) { return root logger . get or create ( name ) . create logger ( ) ; }
public string get error message ( ) { return error message ; }
public void fatal ( object message ) { if ( message ! = null ) { get logger ( ) . fatal error ( string . value of ( message ) ) ; } }
public void error ( object message , throwable t ) { if ( get logger ( ) . be error enable ( ) ) get logger ( ) . error ( string . value of ( message ) , t ) ; }
public boolean be warn enabled ( ) { return category . be enable for ( priority . warn ) ; }
public void trace ( string msg , throwable t ) { if ( logger . be loggable ( level . fine ) ) { log ( self , level . fine , msg , t ) ; } }
public void debug ( object message ) { do log ( level . debug , fqcn , message , null , null ) ; }
public void debug ( object message ) { get logger ( ) . log ( fqcn , priority . debug , message , null ) ; }
public boolean be debug ( ) { return debug ; }
public boolean be available ( ) { return impl . be available ( impl ) ; }
public void fatal ( object message , throwable t ) { if ( get logger ( ) . be fatal error enable ( ) ) get logger ( ) . fatal error ( string . value of ( message ) , t ) ; }
public boolean be info enable ( ) { return be level enable ( info ) ; }
public void remove ( ) { throw new unsupported operation exception ( ) ; }
public void set point only ( boolean point only ) { this . point only = point only ; }
public void set count ( int count ) { this . count = count ; }
public void increment weight ( double weight ) { this . weight += weight ; }
public double of ( double [ ] d , int num param ) { int n = ( int ) d [ 0 ] ; double result = 1 ; for ( int i = n ; i > 1 ; i -- ) result * = i ; return result ; }
public big fraction add ( final int i ) { return add ( big integer . value of ( i ) ) ; }
public double pdf ( double x ) { if ( x < 0 ) { throw new illegal argument exception ( ) ; } if ( x == 0 ) { if ( alpha == 1 . 0 ) { return rate ; } else if ( alpha < 1 ) { return double . positive_infinity ; } else { return 0 ; } } if ( alpha == 1 . 0 ) { return rate * math . exp ( -x * rate ) ; } return rate * math . exp ( ( alpha - 1 . 0 ) * math . log ( x * rate ) - x * rate - log gamma ( alpha ) ) ; }
public void set relative path ( string relative path ) { this . relative path = relative path ; } // -- void set relative path ( string )
public void set flag ( byte flag ) { this . flag = flag ; }
public void set thread two phase commit ( boolean thread two phase commit ) { this . thread two phase commit = thread two phase commit ; }
public dfp get two ( ) { return two ; }
public void set denominator degree of freedom ( double degree of freedom ) { set denominator degree of freedom internal ( degree of freedom ) ; }
public boolean equal ( dd y ) { return hi == y . hi & & lo == y . lo ; }
public vector get target ( ) { return target vector ; }
public double norm x ( double x ) { return shape factory . norm x ( x ) ; }
public void set center window ( boolean value ) { prefs . set boolean ( c o s name . center_window , value ) ; }
public void set interval ( long interval ) { this . interval = interval ; }
public location get location ( ) { return this . location ; }
public void set ( object instance ) { this . declared class = instance . get class ( ) ; this . instance = instance ; }
public t get ( ) { return t ; }
public void set num axis ( short field_1_num axis ) { this . field_1_num axis = field_1_num axis ; }
public boolean have norm ( ) { return have norm ; }
public field vector3 d < t > apply inverse to ( final field vector3 d < t > u ) { final t x = u . get x ( ) ; final t y = u . get y ( ) ; final t z = u . get z ( ) ; final t s = q1 . multiply ( x ) . add ( q2 . multiply ( y ) ) . add ( q3 . multiply ( z ) ) ; final t m0 = q0 . negate ( ) ; return new field vector3 d < t > ( m0 . multiply ( x . multiply ( m0 ) . subtract ( q2 . multiply ( z ) . subtract ( q3 . multiply ( y ) ) ) ) . add ( s . multiply ( q1 ) ) . multiply ( 2 ) . subtract ( x ) , m0 . multiply ( y . multiply ( m0 ) . subtract ( q3 . multiply ( x ) . subtract ( q1 . multiply ( z ) ) ) ) . add ( s . multiply ( q2 ) ) . multiply ( 2 ) . subtract ( y ) , m0 . multiply ( z . multiply ( m0 ) . subtract ( q1 . multiply ( y ) . subtract ( q2 . multiply ( x ) ) ) ) . add ( s . multiply ( q3 ) ) . multiply ( 2 ) . subtract ( z ) ) ; }
public boolean be na n ( ) { return be na n ; }
public void reset ( final vector2 d p , final double alpha ) { unlink reverse ( ) ; this . angle = math utils . normalize angle ( alpha , fast math . pi ) ; cos = fast math . co ( this . angle ) ; sin = fast math . sin ( this . angle ) ; origin offset = math array . linear combination ( co , p . get y ( ) , -sin , p . get x ( ) ) ; }
public static byte [ ] get time u u i d byte ( ) { return create time u u i d byte ( instance . create time safe ( ) ) ; }
public double get origin offset ( ) { return origin offset ; }
public final int get end a ( ) { return end a ; }
public double get double ( object key ) { try { return double . value of ( ( string ) get ( key ) ) ; } catch ( exception e ) { return null ; } }
public boolean be similar to ( final line line ) { final double angle = vector3 d . angle ( direction , line . direction ) ; return ( ( angle < tolerance ) || ( angle > ( fast math . pi - tolerance ) ) ) & & contains ( line . zero ) ; }
public void reset ( final vector2 d p , final double alpha ) { unlink reverse ( ) ; this . angle = math utils . normalize angle ( alpha , fast math . pi ) ; cos = fast math . co ( this . angle ) ; sin = fast math . sin ( this . angle ) ; origin offset = math array . linear combination ( co , p . get y ( ) , -sin , p . get x ( ) ) ; }
public string check origin ( @ nullable string request origin ) { if ( ! string utils . have text ( request origin ) ) { return null ; } if ( object utils . be empty ( this . allow origin ) ) { return null ; } if ( this . allow origin . contains ( all ) ) { if ( this . allow credential ! = boolean . true ) { return all ; } else { return request origin ; } } for ( string allow origin : this . allow origin ) { if ( request origin . equal ignore case ( allow origin ) ) { return request origin ; } } return null ; }
public void pack ( ) { trie arc < t > arc = first arc ; while ( arc ! = null ) { arc . pack ( ) ; arc = arc . next ; } }
public vector3 d get u ( ) { return u ; }
public string get prefix string ( ) { return prefix ; }
public static string add key suffix ( string key , string . . . suffix ) { string key suffix = concat suffix ( suffix ) ; return add suffix ( key , key suffix ) ; }
public list < integer > to list ( ) { final array list < integer > v = new array list < integer > ( ) ; final e w a h iterator i = this . get e w a h iterator ( ) ; int po = 0 ; while ( i . have next ( ) ) { run length word localrlw = i . next ( ) ; if ( localrlw . get running bit ( ) ) { final long n = localrlw . get running length ( ) ; for ( long j = 0 ; j < n ; ++j ) { for ( int c = 0 ; c < word_in_bits ; ++c ) v . add ( pos++ ) ; } } else { po += word_in_bits * localrlw . get running length ( ) ; } final int nlw = localrlw . get number of literal word ( ) ; for ( int j = 0 ; j < nlw ; ++j ) { long data = i . buffer ( ) . get word ( i . literal word ( ) + j ) ; while ( data ! = 0 ) { final long t = data & -data ; v . add ( long . bit count ( t - 1 ) + po ) ; data ^= t ; } pos += word_in_bits ; } } while ( ( v . size ( ) > 0 ) & & ( v . get ( v . size ( ) - 1 ) > = this . size in bit ) ) v . remove ( v . size ( ) - 1 ) ; return v ; }
public static boolean match ( int actual dimension value , char require dimension symbol ) { if ( require dimension symbol == dimension . sym_dontcare ) { return true ; } if ( require dimension symbol == dimension . sym_true & & ( actual dimension value > = 0 || actual dimension value == dimension . true ) ) { return true ; } if ( require dimension symbol == dimension . sym_false & & actual dimension value == dimension . false ) { return true ; } if ( require dimension symbol == dimension . sym_p & & actual dimension value == dimension . p ) { return true ; } if ( require dimension symbol == dimension . sym_l & & actual dimension value == dimension . l ) { return true ; } if ( require dimension symbol == dimension . sym_a & & actual dimension value == dimension . a ) { return true ; } return false ; }
public final void set matrix ( matrix matrix ) { c o s array matrix array = null ; if ( matrix ! = null ) { matrix array = matrix . to c o s array ( ) ; } dictionary . set item ( c o s name . matrix , matrix array ) ; }
public boolean have norm ( ) { return have norm ; }
public void set option comparator ( comparator comparator ) { if ( comparator == null ) { this . option comparator = new option comparator ( ) ; } else { this . option comparator = comparator ; } }
public int get column number ( ) { return -1 ; }
public build step builder add build step ( build step build step ) { final build step builder build step builder = new build step builder ( this ) ; build step builder . set build step ( build step ) ; return build step builder ; }
public double get min ( int dimension ) { future object . check index ( dimension , type . point dimension count ( ) /2 ) ; return decode min ( ( ( bytes ref ) field data ) . byte , dimension ) ; }
public string get event ( ) { return event ; }
public boolean be updatable primary key ( ) { return updatable primary key ; }
public void set variable time ( long time ) { }
public state get state ( ) { return state . get ( ) . get state ( ) ; }
public void add mapper ( mapper mapper ) { if ( this . mapper ! = null ) { throw new build exception ( `` can not define more than one mapper `` ) ; } this . mapper = mapper ; }
public state get state ( ) { return state . get ( ) . get state ( ) ; }
public string get provider ( ) { return provider ; }
public list < format error > get error ( ) { return error ; }
protect void increment count ( ) throw max count exceed exception { count . increment ( ) ; }
public void notify after evaluation ( string expr ) { if ( get evaluation listener ( ) == null ) return ; for ( evaluation listener listener : get evaluation listener ( ) ) { listener . after evaluation ( this , expr ) ; } }
public void row process ( string [ ] row , t context ) { row . add ( row ) ; }
public void set variable ( variable declaration variable ) { assert not null ( variable ) ; this . variable = variable ; variable . set parent ( this ) ; }
public static double link ( double r ) { if ( r < 0 . 0 ) { double s = math . exp ( r ) ; return s / ( 1 . 0 + s ) ; } else { double s = math . exp ( -r ) ; return 1 . 0 / ( 1 . 0 + s ) ; } }
public boolean be function ( ) { return this . function ; }
public x s l f picture data get picture data ( ) { if ( _data == null ) { string blip id = get blip id ( ) ; if ( blip id == null ) { return null ; } package part p = get sheet ( ) . get package part ( ) ; package relationship rel = p . get relationship ( blip id ) ; if ( rel ! = null ) { try { package part img part = p . get related part ( rel ) ; _data = new x s l f picture data ( img part ) ; } catch ( exception e ) { throw new p o i x m l exception ( e ) ; } } } return _data ; }
public static double link ( double r ) { if ( r < 0 . 0 ) { double s = math . exp ( r ) ; return s / ( 1 . 0 + s ) ; } else { double s = math . exp ( -r ) ; return 1 . 0 / ( 1 . 0 + s ) ; } }
public boolean be normalize ( ) { return be normalize ; }
public void load ( ) { web component . load ( ) ; }
public e next ( ) { if ( ! next object set & & ! set next object ( ) ) { throw new no such element exception ( ) ; } next object set = false ; return next object ; }
public double get x ( ) { return x ; }
public static boolean be whitespace ( int c ) { return c == ' ' || c == '\t ' || c == '\n ' || c == '\f ' || c == '\r ' ; }
public double density ( double x ) { final double dev = x - median ; return ( 1 / math . pi ) * ( scale / ( dev * dev + scale * scale ) ) ; }
public static double function constant ( final double c ) { return new double function ( ) { @ override public double apply ( double a ) { return c ; } } ; }
public void clear ( ) { clear ( size ) ; }
public int get window size ( ) { return window size ; }
public synchronize void set max impl ( univariate statistic max impl ) { this . max impl = max impl ; }
public string to string ( ) { return impl . to string ( impl ) ; }
public double evaluate ( final double [ ] value , final double [ ] weight ) throw math illegal argument exception { return evaluate ( value , weight , 0 , value . length ) ; }
public static double max ( final double [ ] value , final int begin , final int length ) throw math illegal argument exception { return max . evaluate ( value , begin , length ) ; }
public double evaluate ( final double [ ] value , final double mean ) throw math illegal argument exception { return evaluate ( value , mean , 0 , value . length ) ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public static boolean verify check sum ( final byte [ ] header ) { final long stored sum = parse octal ( header , chksum_offset , chksumlen ) ; long unsigned sum = 0 ; long sign sum = 0 ; for ( int i = 0 ; i < header . length ; i++ ) { byte b = header [ i ] ; if ( chksum_offset < = i & & i < chksum_offset + chksumlen ) { b = ' ' ; } unsigned sum += 0xff & b ; sign sum += b ; } return stored sum == unsigned sum || store sum == sign sum ; }
public double of ( double [ ] d , int num param ) { int n = ( int ) d [ 0 ] ; double result = 1 ; for ( int i = n ; i > 1 ; i -- ) result * = i ; return result ; }
public static double magnitude ( final double x , final double y , final double z ) { return math . sqrt ( x * x + y * y + z * z ) ; }
public final void set matrix ( matrix matrix ) { c o s array matrix array = null ; if ( matrix ! = null ) { matrix array = matrix . to c o s array ( ) ; } dictionary . set item ( c o s name . matrix , matrix array ) ; }
public static boolean validate ( long n ) { if ( n < 0 ) { throw new illegal argument exception ( `` n > = 0 require but it be `` + n ) ; } return n ! = 0l ; }
public static event < request intercept > request intercept ( ) { return new event < > ( domain_name + `` . request intercept `` , map ( `` interception id `` , request intercept . class ) ) ; }
public static double max ( final double [ ] value , final int begin , final int length ) throw math illegal argument exception { return max . evaluate ( value , begin , length ) ; }
public static double variance ( final double [ ] value , final int begin , final int length ) throw math illegal argument exception { return variance . evaluate ( value , begin , length ) ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public static void not null ( final object obj , final string message ) throw illegal argument exception { if ( obj == null ) { throw new illegal argument exception ( message ) ; } }
public void set iterator ( final iterator < ? extend e > iterator ) { this . iterator = iterator ; }
public o transform ( final i input ) { if ( i predicate . evaluate ( input ) ) { return i true transformer . transform ( input ) ; } return i false transformer . transform ( input ) ; }
public static string capitalize fully ( string str , final char . . . delimiters ) { if ( string utils . be empty ( str ) ) { return str ; } str = str . to lower case ( ) ; return capitalize ( str , delimiters ) ; }
public i content type matcher get matcher ( ) { return matcher ; }
public static str matcher string matcher ( string str ) { if ( str == null || str . length ( ) == 0 ) { return none_matcher ; } return new string matcher ( str ) ; }
public int get leave context start offset ( ) { return leave context start offset ; }
public int get l c s length ( ) { return lcs length ; }
public string source ( ) { return source ; }
public static boolean be empty ( string str ) { return ( str == null || str . length ( ) == 0 ) ; }
public static string capitalize ( string str ) { int str len ; if ( str == null || ( str len = str . length ( ) ) == 0 ) { return str ; } return new string buffer ( str len ) . append ( character . to title case ( str . char at ( 0 ) ) ) . append ( str . substring ( 1 ) ) . to string ( ) ; }
public static boolean be array ( object obj ) { return ( obj ! = null & & obj . get class ( ) . be array ( ) ) ; }
public string key ( ) { return key ; }
public void clear ( ) { clear ( size ) ; }
public void set variable ( variable declaration variable ) { assert not null ( variable ) ; this . variable = variable ; variable . set parent ( this ) ; }
public boolean be empty ( ) { return size ( ) == 0 ; }
public static string capitalize ( string str ) { int str len ; if ( str == null || ( str len = str . length ( ) ) == 0 ) { return str ; } return new string buffer ( str len ) . append ( character . to title case ( str . char at ( 0 ) ) ) . append ( str . substring ( 1 ) ) . to string ( ) ; }
public void set user ( string user ) { super . set internal user ( user ) ; }
public string get comment ( ) { return comment ; }
public value holder get indexed argument value ( int index , class < ? > require type ) { return get indexed argument value ( index , require type , null ) ; }
public string format message ( final log record record ) { string msg = super . format message ( record ) ; msg = replace class name ( msg , record . get thrown ( ) ) ; msg = replace class name ( msg , record . get parameter ( ) ) ; return msg ; }
public float float value ( ) { return value ; }
public synchronize void modify ( long start value , long min value , long max value , long increment ) { if ( start value == null ) { start value = this . value ; } if ( min value == null ) { min value = this . min value ; } if ( max value == null ) { max value = this . max value ; } if ( increment == null ) { increment = this . increment ; } if ( ! be valid ( start value , min value , max value , increment ) ) { throw db exception . get ( error code . sequence_attributes_invalid , get name ( ) , string . value of ( start value ) , string . value of ( min value ) , string . value of ( max value ) , string . value of ( increment ) ) ; } this . value = start value ; this . value with margin = start value ; this . min value = min value ; this . max value = max value ; this . increment = increment ; }
public int get max length ( ) { return max length ; }
public static boolean max length ( string value , int max ) { return ( value . length ( ) < = max ) ; }
public int get min length ( ) { return min length ; }
public static boolean be valid ( string st value ) { return n c name . be valid ( st value ) ; }
public big decimal get decimal value ( ) throw x path exception { return ( ( decimal value ) convert primitive ( build in atomic type . decimal , true , null ) . a atomic ( ) ) . get decimal value ( ) ; }
public integer validate ( string value , locale locale ) { return ( integer ) parse ( value , ( string ) null , locale ) ; }
public calendar validate ( string value , string pattern , locale locale ) { return ( calendar ) parse ( value , pattern , locale , ( time zone ) null ) ; }
public int po ( ) { return po ; }
public static boolean be token ( string value ) { if ( value == null ) return true ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; i++ ) { char c = value . char at ( i ) ; if ( tspecials . index of ( c ) ! = -1 ) return false ; } return true ; }
public int get total number of shard ( ) { return this . total number of shard ; }
public int get min length ( ) { return this . min length ; }
public long validate ( string value , string pattern , locale locale ) { return ( long ) parse ( value , pattern , locale ) ; }
public long validate ( string value ) { return ( long ) parse ( value , ( string ) null , ( locale ) null ) ; }
public double value ( ) { return value ; }
public byte validate ( string value , locale locale ) { return ( byte ) parse ( value , ( string ) null , locale ) ; }
public long validate ( string value , string pattern , locale locale ) { return ( long ) parse ( value , pattern , locale ) ; }
public date validate ( string value , string pattern , locale locale ) { return ( date ) parse ( value , pattern , locale , ( time zone ) null ) ; }
public calendar validate ( string value ) { return ( calendar ) parse ( value , ( string ) null , ( locale ) null , ( time zone ) null ) ; }
public static void check scheme ( final string scheme ) { scheme_checker . check ( scheme ) ; }
public int count ( ) { return count ; }
public static void turn all log on ( ) { py4j_logger . set level ( level . all ) ; }
public string value ( ) { return value ; }
public artifact descriptor result set dependency ( list < dependency > dependency ) { if ( dependency == null ) { this . dependency = collection . empty list ( ) ; } else { this . dependency = dependency ; } return this ; }
public string get name ( int value ) { return constant . get name ( value ) ; }
public void set action ( string action ) { this . action = action ; }
public int count ( ) { return count ; }
public string get output ( ) { return output ; }
public node peek node ( ) { return ( node ) node . get ( node . size ( ) -1 ) ; }
public node get node ( ) { return node ; }
public list < format error > get error ( ) { return error ; }
public int hash code ( ) { return get node ( ) . hash code ( ) ; }
public option get option ( ) { return option ; }
public option get option ( ) { return option ; }
public int get option ( ) { return option ; }
public object get value ( ) { return this . value ; }
public double t_max ( ) { return t_max ; }
public void set interval ( double t_min , double t_max ) { if ( t_min > t_max ) throw new illegal argument exception ( `` t_min < = t_max require . `` ) ; this . t_min = t_min ; this . t_max = t_max ; }
public int get capacity ( ) { return this . get ( ) . length ; }
public list query ( double x1 , double x2 ) { return super . query ( new interval ( math . min ( x1 , x2 ) , math . max ( x1 , x2 ) ) ) ; }
public long get d ( ) { return d ; }
public static double pt seg dist sq ( double x1 , double y1 , double x2 , double y2 , double x , double y , double [ ] result ) { double run = x2 - x1 ; double rise = y2 - y1 ; double t = 0 . 0 ; double f = run * run + rise * rise ; if ( f ! = 0 ) t = ( run * ( x - x1 ) + rise * ( y - y1 ) ) / f ; if ( t < 0 ) t = 0 . 0 ; else if ( t > 1 ) t = 1 . 0 ; double nx = x1 + t * run ; double ny = y1 + t * rise ; if ( result ! = null ) { result [ 0 ] = nx ; result [ 1 ] = ny ; result [ 2 ] = t ; } double dx = x - nx ; double dy = y - ny ; return dx * dx + dy * dy ; }
public static double pt line dist sq ( double x1 , double y1 , double x2 , double y2 , double x , double y , double [ ] result ) { double run = x2 - x1 ; double rise = y2 - y1 ; double t = 0 . 0 ; double f = run * run + rise * rise ; if ( f ! = 0 ) t = ( run * ( x - x1 ) + rise * ( y - y1 ) ) / f ; double nx = x1 + t * run ; double ny = y1 + t * rise ; if ( result ! = null ) { result [ 0 ] = nx ; result [ 1 ] = ny ; result [ 2 ] = t ; } double dx = x - nx ; double dy = y - ny ; return dx * dx + dy * dy ; }
public static double pt line dist sq ( double x1 , double y1 , double x2 , double y2 , double x , double y , double [ ] result ) { double run = x2 - x1 ; double rise = y2 - y1 ; double t = 0 . 0 ; double f = run * run + rise * rise ; if ( f ! = 0 ) t = ( run * ( x - x1 ) + rise * ( y - y1 ) ) / f ; double nx = x1 + t * run ; double ny = y1 + t * rise ; if ( result ! = null ) { result [ 0 ] = nx ; result [ 1 ] = ny ; result [ 2 ] = t ; } double dx = x - nx ; double dy = y - ny ; return dx * dx + dy * dy ; }
public string to string ( ) { return to string ( `` `` ) ; }
public int [ ] get value ( ) { int [ ] result = new int [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get value ( i ) ; } return result ; }
public double get x ( ) { return x ; }
public rest assure config decoder config ( decoder config decoder config ) { not null ( decoder config , `` decoder config `` ) ; return new rest assure config ( conf ( redirect config . class ) , conf ( http client config . class ) , conf ( log config . class ) , conf ( encoder config . class ) , decoder config , conf ( session config . class ) , conf ( object mapper config . class ) , conf ( connection config . class ) , conf ( json config . class ) , conf ( xml config . class ) , conf ( s s l config . class ) , conf ( matcher config . class ) , conf ( header config . class ) , conf ( multi part config . class ) , conf ( param config . class ) , conf ( o auth config . class ) , conf ( failure config . class ) ) ; }
public name get qualifier ( ) { return this . optional qualifier ; }
public bean builder < t > bean class ( class < ? > bean class ) { this . bean class = bean class ; return this ; }
public type get type ( ) { return type ; }
public void set type ( int type ) { this . type = type ; }
public void register bean ( class < ? > bean class ) { do register bean ( bean class , null , null , null , null ) ; }
public static boolean be public ( class clazz , member member ) { return modifier . be public ( member . get modifier ( ) ) & & modifier . be public ( clazz . get modifier ( ) ) ; }
public schema get schema ( ) { return schema ; }
public void set cache ( boolean cache ) { this . cache = cache ; }
public string get x path ( ) { return xpath ; }
public string to string ( ) { return get i d ( ) ; }
public handler [ ] get and set handler ( final handler [ ] handler ) throw security exception { final handler [ ] safe handler = handler . clone ( ) ; for ( handler handler : safe handler ) { if ( handler == null ) { throw new illegal argument exception ( `` a handler be null `` ) ; } } return logger node . set handler ( safe handler ) ; }
public void set ignore comment ( boolean ignore comment ) { this . ignore comment = ignore comment ; }
public boolean be ignore comment ( ) { return ignore comment ; }
public void add text ( string text ) { this . text = text ; }
public void add text ( string text ) { this . text = text ; }
public void set default handler ( element handler handler ) { default handler = handler ; }
public void set filter ( tree filter filter ) { this . filter = filter ; }
public document get a document ( ) throw exception { string element string = get a string ( ) ; reader reader = new string reader ( element string ) ; document doc = x m l utils . new document ( new input source ( reader ) ) ; if ( doc == null ) { throw new exception ( message . get message ( `` no doc00 `` , element string ) ) ; } return doc ; }
public static data output stream new data output stream ( file file ) throw i o exception { return new data output stream ( new file output stream ( file ) ) ; }
public string to string ( ) { return `` [ namespace : prefix \ `` `` + prefix + `` \ `` be map to uri \ `` `` + uri + `` \ `` ] `` ; }
public string get mode ( ) { return mode ; }
public string [ ] get pattern ( ) { return pattern ; }
public string get x path ( ) { return xpath ; }
public void set mode ( string mode ) { this . mode = mode ; }
public string get namespace prefix ( ) { return namespace . get prefix ( ) ; }
public object get user data ( ) { return user data ; }
public static void sort ( list < node > list , string xpath expression ) { x path xpath = create x path ( xpath expression ) ; xpath . sort ( list ) ; }
public string read attribute value ( xml namespace xml namespace , string attribute name ) throw exception { if ( xml namespace == xml namespace . not specify ) { return this . read attribute value ( attribute name ) ; } else { q name q name = new q name ( ews utility . get namespace uri ( xml namespace ) , attribute name ) ; return read attribute value ( q name ) ; } }
public mutable rate new rate ( string name ) { return new rate ( name , name , false ) ; }
public class < t > get type ( ) { return type ; }
public < t > t give other ( type tag tag , t value ) { class < t > type = tag . get type ( ) ; if ( value ! = null & & ! type . be assignable from ( value . get class ( ) ) & & ! wrap ( type , value . get class ( ) ) ) { throw new reflection exception ( `` type tag do not match value . `` ) ; } tuple < t > tuple = give tuple ( tag ) ; if ( tuple . get red ( ) == null ) { return null ; } if ( type . be array ( ) & & array be deeply equal ( tuple . get red ( ) , value ) ) { return tuple . get blue ( ) ; } if ( ! type . be array ( ) & & tuple . get red ( ) . equal ( value ) ) { return tuple . get blue ( ) ; } return tuple . get red ( ) ; }
public < t > tuple < t > give tuple ( type tag tag ) { realize cache for ( tag , empty stack ( ) ) ; return cache . get tuple ( tag ) ; }
public string get name ( int value ) { return constant . get name ( value ) ; }
public static optional < object [ ] > remove ( final t accessor , final object . . . key value ) { return element helper . remove ( ( object ) accessor , key value ) ; }
public static synchronize < t > constructor expectation setup < t > when new ( string fully qualify name ) throw exception { final class < t > for name = ( class < t > ) class . for name ( fully qualify name ) ; return new default constructor expectation setup < t > ( for name ) ; }
public object get result ( ) { return result ; }
public final collection < t > to collection ( ) { list < t > list = new array list < t > ( ) ; add to ( list ) ; return list ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public void set port ( int port ) { set property ( `` port `` , string . value of ( port ) ) ; }
public final void validate ( final setting setting , final boolean validate value ) { validate ( setting , validate value , false , false ) ; }
public url get url ( ) { return url ; }
public setting setting ( ) { return setting ; }
public string get smtp address ( ) { return this . smtp address ; }
public string get error code namespace ( ) { return error code namespace ; }
public static void error ( error message message , string data ) { errors++ ; err ( nl+ `` error : `` + error message . get ( message , data ) ) ; }
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public string get uri ( ) { return uri ; }
public string get illegal value a string ( ) { string value = i string value ; if ( value == null ) { value = string . value of ( i number value ) ; } return value ; }
public version get version ( ) { return version ; }
public boolean be index object ( ) { return index object ; }
public void set namespace ( xml namespace xml namespace ) { this . xml namespace = xml namespace ; }
public final q name get name ( ) { return name ; }
public string get name ( ) { return this . name ; } // -- string get name ( )
public int get major version ( ) { return major ; }
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
protect folder id get parent folder id ( ) { return this . parent folder id ; }
protect string get mailbox smtp address ( ) { return this . mailbox smtp address ; }
public void set exchange2007 compatibility mode ( boolean value ) { this . exchange2007 compatibility mode = value ; }
public boolean get exchange2007 compatibility mode ( ) { return this . exchange2007 compatibility mode ; }
protect void resume trace ( ) { if ( trace logger . be loggable ( level . fine ) ) { trace input . set trace ( true ) ; trace output . set trace ( true ) ; } }
public static trace listener remove ( trace listener l , trace listener oldl ) { return ( trace listener ) remove internal ( l , oldl ) ; }
public void set user agent ( string user agent ) { this . user agent = user agent + `` ( `` + exchange service base . default user agent + `` ) `` ; }
public string get user agent ( ) { return this . user agent ; }
public string get server number ( ) { return server info . get server number ( ) ; }
public http request with body ( string body ) { this . body = new string body ( body ) ; return this ; }
public final byte [ ] a unquoted u t f8 ( ) { byte [ ] result = _unquoted u t f8 ref ; if ( result == null ) { _unquoted u t f8 ref = result = json_encoder . encode a u t f8 ( _value ) ; } return result ; }
public void set id ( string id ) { this . id = id ; }
public void set folder id ( string folder id ) { this . folder id = folder id ; }
protect service object type get service object type ( ) { return service object type . item ; }
public void set user ( string user ) { super . set internal user ( user ) ; }
public void set folder id ( string folder id ) { this . folder id = folder id ; }
public node get node ( ) { return node ; }
public collection < string > get group ( ) { return group ; }
protect string get smtp address ( ) { return this . smtp address ; }
public void set property ( string property ) { this . property = property ; }
public string get id ( ) { return this . id ; } // -- string get id ( )
public void set context ( object data ) { this . data = data ; }
public string get smtp address ( ) { return this . smtp address ; }
public string get encode ( ) { return this . encoding ; } // -- string get encoding ( )
public @ nullable proxy get proxy ( ) { return proxy ; }
public void set proxy username ( string proxy username ) { this . proxy username = proxy username ; }
public void set auto update ( string auto update ) { this . auto update = auto update ; } // -- void set auto update ( string )
public folder move ( folder id destination folder id ) throw exception { this . throw if this be new ( ) ; ew utility . validate param ( destination folder id , `` destination folder id `` ) ; return this . get service ( ) . move folder ( this . get id ( ) , destination folder id ) ; }
public static string null to empty ( @ nullable string string ) { return ( string == null ) ? `` `` : string ; }
public item get item ( ) { return ( item ) this . get service object ( ) ; }
public void set destination folder id ( folder id destination folder id ) { this . destination folder id = destination folder id ; }
protect string get smtp address ( ) { return this . smtp address ; }
public push subscription end subscribe to push notification ( i async result async result ) throw exception { subscribe to push notification request request = async request result . extract service request ( this , async result ) ; return request . end execute ( async result ) . get response at index ( 0 ) . get subscription ( ) ; }
public void set timeout ( time value timeout ) { this . timeout = timeout ; }
public item id get item id ( ) { return this . item id ; }
public final int get hour ( ) { return hour ; }
public void load from xml ( ews service xml reader reader ) throw exception { this . id = reader . read element value ( xml namespace . message , xml element name . subscription id ) ; if ( this . get uses watermark ( ) ) { this . watermark = reader . read element value ( xml namespace . message , xml element name . watermark ) ; } }
public rule operation error collection get error ( ) { return this . error ; }
public version get version ( ) { return version ; }
public schema get schema ( ) { return schema ; }
public void set folder ( iterable < folder > folder ) { this . set object ( ( collection < folder > ) folder ) ; }
public legacy free busy status get free busy status ( ) { return free busy status ; }
public void set child ( string list value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . child , value ) ; }
protect affect task occurrence get default affect task occurrence ( ) { return affect task occurrence . all occurrence ; }
public string get file a ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . file a ) ; }
public date get assign time ( ) throw service local exception { return get property bag ( ) . get object from property definition ( task schema . assigned time ) ; }
public string get file a ( ) throw exception { return ( string ) this . get object from property definition ( contact schema . file a ) ; }
public void set child ( string list value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . child , value ) ; }
public void set nick name ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . nick name , value ) ; }
public string get nick name ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . nick name ) ; }
public void set child ( string list value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . child , value ) ; }
public void set department ( string value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . department , value ) ; }
public string get file a ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . file a ) ; }
public void set child ( string list value ) throw exception { this . get property bag ( ) . set object from property definition ( contact schema . child , value ) ; }
public string get file a ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . file a ) ; }
public string get file a ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . file a ) ; }
public email address get from ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . from ) ; }
public string get file a ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . file a ) ; }
public string list get unique unread sender ( ) throw argument exception { string list unread sender = null ; / * * this property need not be present hence * the property bag may not contain it . * check for the presence of this property before access it . * / if ( this . get property bag ( ) . contains ( conversation schema . unique unread sender ) ) { out param < string list > out = new out param < string list > ( ) ; this . get property bag ( ) . try get property type ( string list . class , conversation schema . unique unread sender , out ) ; unread sender = out . get param ( ) ; } return unread sender ; }
public string get topic ( ) throw argument exception { string return value = `` `` ; / * * this property need not be present hence the * property bag may not contain it . * check for the presence of this property before access it . * / if ( this . get property bag ( ) . contains ( conversation schema . topic ) ) { out param < string > out = new out param < string > ( ) ; this . get property bag ( ) . try get property type ( string . class , conversation schema . topic , out ) ; return value = out . get param ( ) ; } return return value ; }
public string list get global item class ( ) throw exception { return get property bag ( ) . get object from property definition ( conversation schema . global item class ) ; }
public string list get global item class ( ) throw exception { return get property bag ( ) . get object from property definition ( conversation schema . global item class ) ; }
public string list get item class ( ) throw exception { return get property bag ( ) . get object from property definition ( conversation schema . item class ) ; }
public boolean get be read receipt ( ) { return this . be read receipt ; }
public email address get from ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . from ) ; }
public void set mime content ( mime content value ) throw exception { this . get property bag ( ) . set object from property definition ( item schema . mime content , value ) ; }
public mime content get mime content ( ) throw service local exception { return get property bag ( ) . get object from property definition ( item schema . mime content ) ; }
public string get file a ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . file a ) ; }
public meeting response type get response type ( ) throw service local exception { return get property bag ( ) . get object from property definition ( meet message schema . response type ) ; }
public void set subject ( string subject ) { this . subject = subject ; }
public boolean get be delegate ( ) throw service local exception { return get property bag ( ) . get object from property definition ( meet message schema . be delegate ) ; }
public boolean get be read ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . be read ) ; }
public legacy free busy status get free busy status ( ) { return free busy status ; }
public oof reply get internal reply ( ) { return internal reply ; }
public string get reference ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . reference ) ; }
public email address get from ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . from ) ; }
public email address get from ( ) throw service local exception { return get property bag ( ) . get object from property definition ( email message schema . from ) ; }
public string get file a ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . file a ) ; }
public string get file a ( ) throw service local exception { return get property bag ( ) . get object from property definition ( contact schema . file a ) ; }
public object get state ( ) { return state ; }
public boolean be attachment ( object value ) { return attachment utils . be attachment ( value ) ; }
public http request with body ( string body ) { this . body = new string body ( body ) ; return this ; }
public void clear ( ) { item . clear ( ) ; }
public int get port ( ) { return this . port ; } // -- int get port ( )
public void set global schema reference ( boolean value ) { this . global schema reference = value ; }
public double get time ( ) { return time ; }
public optional < string > get category property ( ) { return category ; }
public void set context folder id ( folder id wrapper value ) { this . context folder id = value ; }
protect folder id wrapper get context folder id ( ) { return this . context folder id ; }
protect folder id wrapper get context folder id ( ) { return this . context folder id ; }
public string get id ( ) { return id ; }
public string get type ( ) { return type ; }
public int get position ( ) { return position ; }
public final int get hour ( ) { return hour ; }
public item id wrapper list get ignore item id ( ) { return this . ignored item id ; }
public binary node binary node ( byte [ ] data ) { return binary node . value of ( data ) ; }
public void set available ( long available ) { long old available = this . available ; if ( available > system . current time millis ( ) ) this . available = available ; else this . available = 0l ; support . fire property change ( `` available `` , long . value of ( old available ) , long . value of ( this . available ) ) ; }
public string get event ( ) { return event ; }
public date get timestamp ( ) { return timestamp ; }
public void set unsubscribe ( string unsubscribe ) { this . unsubscribe = unsubscribe ; } // -- void set unsubscribe ( string )
public void remove notification event ( i notification event delegate notification event ) { on notification event . remove ( notification event ) ; }
public boolean try read element from xml ( ews service xml reader reader ) throw exception { if ( reader . get local name ( ) . equal ignore case ( xml element name . mailbox ) ) { this . load from xml ( reader , reader . get local name ( ) ) ; return true ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . response type ) ) { this . response type = reader . read element value ( meet response type . class ) ; return true ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . last response time ) ) { this . last response time = reader . read element value a date time ( ) ; return true ; } else { return super . try read element from xml ( reader ) ; } }
public string get public id ( ) { return ( this . public id ) ; }
public void set owner ( storage owner owner ) { this . owner = owner ; }
public void set owner ( storage owner owner ) { this . owner = owner ; }
public static autodiscover error parse ( ews xml reader reader ) throw exception { autodiscover error error = new autodiscover error ( ) ; error . time = reader . read attribute value ( xml attribute name . time ) ; error . id = reader . read attribute value ( xml attribute name . id ) ; do { reader . read ( ) ; if ( reader . get node type ( ) . get node type ( ) == xml node type . start_element ) { if ( reader . get local name ( ) . equal ignore case ( xml element name . error code ) ) { error . error code = reader . read element value ( integer . class ) ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . message ) ) { error . message = reader . read element value ( ) ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . debug data ) ) { error . debug data = reader . read element value ( ) ; } else { reader . skip current element ( ) ; } } } while ( ! reader . be end element ( xml namespace . not specify , xml element name . error ) ) ; return error ; }
public string get xml element name ( ) { return this . xml element name ; }
public void set legacy free busy status ( legacy free busy status value ) throw exception { this . get property bag ( ) . set object from property definition ( appointment schema . legacy free busy status , value ) ; }
public boolean be be date ( ) { return be date . be set ( field_9_options ) ; }
public list < string > get checkout conflict ( ) { return checkout conflict ; }
public response message create reply ( boolean reply all ) throw exception { this . throw if this be new ( ) ; return new response message ( this , reply all ? response message type . reply all : response message type . reply ) ; }
public meeting request delivery scope get meeting request delivery scope ( ) { return this . meeting request delivery scope ; }
public void set work listener ( @ nullable work listener work listener ) { this . work listener = work listener ; }
public string get title ( ) { return title ; }
public namespace get namespace ( ) { return namespace ; }
protect void clear change ( ) { change = false ; }
protect complex type binding mode get bind mode ( x s complex type type ) { complex type binding mode r = complex type binding mode . get ( type ) ; assert r ! =null ; return r ; }
public void remove ( int index ) { entry . remove ( index ) ; }
public final void set rule ( int rule ) { this . rule = rule ; }
public delegate folder permission level get note folder permission level ( ) { return this . delegate folder permission . get ( xml element name . note folder permission level ) . get permission level ( ) ; }
public void set permission ( path p , fs permission permission ) throw i o exception { }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public string get file name ( ) { return this . file name ; }
public string get content ( ) { return content ; }
public text edit perform ( ) { text edit result= do copy ( f edit ) ; if ( result ! = null ) { for ( text edit edit : f copy . key set ( ) ) { edit . post process copy ( this ) ; } } return result ; }
public list < string > get delete ( ) { return delete ; }
public member get member ( ) { return this . executable ; }
public void set im address key ( im address key key , string value ) { if ( value == null ) { this . internal remove ( key ) ; } else { im address entry entry ; if ( this . get entry ( ) . contains key ( key ) ) { entry = this . get entry ( ) . get ( key ) ; entry . set im address ( value ) ; this . change ( ) ; } else { entry = new im address entry ( key , value ) ; this . internal add ( entry ) ; } } }
public void set name ( string name ) { this . name = name ; }
public string get value ( ) { return value ; }
public item get item ( ) { return ( item ) this . get service object ( ) ; }
public int get count ( ) { return message . size ( ) ; }
public void set ( int value ) { this . value = value ; }
public void set standard user ( standard user standard user ) { if ( this . can set field value ( this . standard user , standard user ) ) { this . standard user = standard user ; this . change ( ) ; } }
public static autodiscover error parse ( ews xml reader reader ) throw exception { autodiscover error error = new autodiscover error ( ) ; error . time = reader . read attribute value ( xml attribute name . time ) ; error . id = reader . read attribute value ( xml attribute name . id ) ; do { reader . read ( ) ; if ( reader . get node type ( ) . get node type ( ) == xml node type . start_element ) { if ( reader . get local name ( ) . equal ignore case ( xml element name . error code ) ) { error . error code = reader . read element value ( integer . class ) ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . message ) ) { error . message = reader . read element value ( ) ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . debug data ) ) { error . debug data = reader . read element value ( ) ; } else { reader . skip current element ( ) ; } } } while ( ! reader . be end element ( xml namespace . not specify , xml element name . error ) ) ; return error ; }
public boolean be pattern ( ) { return pattern name ! = null ; }
public occurrence info collection get modify occurrence ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . modified occurrence ) ; }
public void mark ( int mark limit ) { }
public string get xml name ( ) { return version ; }
public string list get unique unread sender ( ) throw argument exception { string list unread sender = null ; / * * this property need not be present hence * the property bag may not contain it . * check for the presence of this property before access it . * / if ( this . get property bag ( ) . contains ( conversation schema . unique unread sender ) ) { out param < string list > out = new out param < string list > ( ) ; this . get property bag ( ) . try get property type ( string list . class , conversation schema . unique unread sender , out ) ; unread sender = out . get param ( ) ; } return unread sender ; }
public string get address ( ) { return this . address ; } // -- string get address ( )
public request < ? > get request ( ) { return request ; }
public static field < string > de encrypt ( string string ) { return de encrypt ( val ( string ) ) ; }
public void set report ( object report ) { this . report = report ; } // -- void set report ( object )
public void suppress read receipt ( ) throw exception { this . throw if this be new ( ) ; new suppress read receipt ( this ) . internal create ( null , null ) ; }
public folder traversal get traversal ( ) { return traversal ; }
public column prefix uniqueness constraint < k > with unique id ( string unique ) { lock . with lock id ( unique ) ; return this ; }
public void merge ( composite change change ) { change [ ] others= change . get child ( ) ; for ( change other : others ) { change . remove ( other ) ; add ( other ) ; } }
public void add all ( change [ ] change ) { for ( change change : change ) { add ( change ) ; } }
public boolean equal ( object obj ) { if ( obj instanceof event ) { return to string ( ) . equal ( obj . to string ( ) ) ; } else { return false ; } }
public list < attribute source > get term ( int state ) { int num t = det . init transition ( state , transition ) ; list < attribute source > tokens = new array list < > ( ) ; for ( int i = 0 ; i < num t ; i++ ) { det . get next transition ( transition ) ; token . add all ( array . a list ( this . token ) . sub list ( transition . min , transition . max + 1 ) ) ; } return token ; }
public static double day in week ( x path context context ) throw x path exception { return day in week ( date time ( context ) ) ; }
public void remove update ( document event e ) { if ( ! dirty ) { set dirty ( true ) ; } }
public time change get standard ( ) { return this . standard ; }
public type get type ( ) { return type ; }
public boolean equal ( object obj ) { if ( obj instanceof event ) { return to string ( ) . equal ( obj . to string ( ) ) ; } else { return false ; } }
public void set flag ( byte flag ) { this . flag = flag ; }
public void set name ( string name ) { this . name = name ; }
protect iterable < t service object > get object ( ) { return this . object ; }
public string get order by ( ) { return order by ; }
public static long copy ( input stream inp , output stream out ) throw i o exception { final byte [ ] buff = new byte [ 4096 ] ; long total count = 0 ; for ( int count ; ( count = inp . read ( buff ) ) ! = -1 ; total count += count ) { if ( count > 0 ) { out . write ( buff , 0 , count ) ; } } return total count ; }
public void set traversal ( folder traversal traversal ) { this . traversal = traversal ; }
public folder traversal get traversal ( ) { return traversal ; }
public iterable < item > get item ( ) { return this . item ; }
public void remove ( int index ) { entry . remove ( index ) ; }
public int get offset ( ) { return offset ; }
public int get count ( ) { return this . item . size ( ) ; }
public iterable < item > get item ( ) { return this . item ; }
public static int read fully ( input stream be , byte [ ] buf ) throw i o exception { int byte read = 0 ; int read ; while ( byte read < buf . length & & ( ( read = be . read ( buf , bytes read , buf . length - byte read ) ) > = 0 ) ) { byte read += read ; } return byte read ; }
public static date parse date ( string date value ) throw date parse exception { return parse date ( date value , null ) ; }
public void set link ( boolean value ) { this . link = value ; }
public list get all function ( ) { return stylesheet . get all stylesheet function ( ) ; }
public string [ ] get readable property name ( ) { if ( this . property name == null ) { list < string > name = new array list < > ( ) ; property descriptor [ ] prop = this . bean wrapper . get property descriptor ( ) ; for ( property descriptor pd : prop ) { if ( this . bean wrapper . be readable property ( pd . get name ( ) ) ) { name . add ( pd . get name ( ) ) ; } } this . property name = string utils . to string array ( name ) ; } return this . property name ; }
public final boolean use static type ( ) { return _as static ; }
public string get title ( ) { return title ; }
public void decrement font size ( ) { scale font ( 1 / font scale factor ) ; }
public void decrement font size ( ) { scale font ( 1 / font scale factor ) ; }
public void increment font size ( ) { scale font ( font scale factor ) ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public int get layout version ( ) { return layout version ; }
public void set bound box ( bound box b box ) { bound box = b box ; }
public static < e > list < e > a list ( iterable < e > i ) { if ( i instanceof collection ) { return new array list < e > ( ( collection < e > ) i ) ; } array list < e > a = new array list < e > ( ) ; for ( e e : i ) { a . add ( e ) ; } return a ; }
public object get render hint ( render hint . key hint key ) { return _hints . get ( hint key ) ; }
public void set render hint ( map hint ) { render hint = hint ; }
public string uri ( ) { return uri ; }
public input stream get input stream ( ) throw i o exception { return url . open stream ( ) ; }
public string to turtle ( ) { string val = this . value ; val = val . replace ( `` \ `` `` , `` \\\ `` `` ) ; val = `` \ `` `` +val+ `` \ `` `` ; if ( data type == null ) { if ( language ! = null ) { val = val+ `` @ `` +language ; } } else { val = val+ `` ^^ < `` + data type . get xml schema u r i string ( ) + `` > `` ; } return val ; }
public double compression ( ) { return compression ; }
public void set font b box ( bound box b box ) { this . font b box = b box ; }
public list < ligature > get ligature ( ) { return ligatures ; }
public void add ligature ( ligature ligature ) { ligature . add ( ligature ) ; }
public float float value ( ) { return value ; }
public float float value ( ) { return value ; }
public void set bound box ( bound box b box ) { bound box = b box ; }
public boolean equal ( object obj ) { if ( ! ( obj instanceof parser notice ) ) { return false ; } return compare to ( ( parser notice ) obj ) ==0 ; }
protect boolean be valid scheme ( string scheme ) { if ( scheme == null ) { return false ; } if ( ! scheme_pattern . matcher ( scheme ) . match ( ) ) { return false ; } if ( be off ( allow_all_schemes ) ) { if ( ! this . allow scheme . contains ( scheme ) ) { return false ; } } return true ; }
public void set height ( short height ) { field_4_height = height ; }
public static float get float ( byte [ ] data ) { return get float ( data , 0 ) ; }
public int get position ( ) { return position ; }
public set entry set ( ) { composite set entry = new composite set ( ) ; for ( int i = this . composite . length - 1 ; i > = 0 ; -- i ) { entry . add composited ( this . composite [ i ] . entry set ( ) ) ; } return entry ; }
public void set width ( string width value ) { x w p f table . set width value ( width value , get tc width ( ) ) ; }
public second to standard second ( ) { check year and month ( `` second `` ) ; long second = get millis ( ) / date time constant . millis_per_second ; second = field utils . safe add ( second , get second ( ) ) ; second = field utils . safe add ( second , ( ( long ) get minute ( ) ) * ( ( long ) date time constant . seconds_per_minute ) ) ; second = field utils . safe add ( second , ( ( long ) get hour ( ) ) * ( ( long ) date time constant . seconds_per_hour ) ) ; second = field utils . safe add ( second , ( ( long ) get day ( ) ) * ( ( long ) date time constant . seconds_per_day ) ) ; second = field utils . safe add ( second , ( ( long ) get week ( ) ) * ( ( long ) date time constant . seconds_per_week ) ) ; return second . second ( field utils . safe to int ( second ) ) ; }
public void set successor ( string successor value ) { successor = successor value ; }
public string get successor ( ) { return successor ; }
public string get name ( ) { return f method . get name ( ) ; }
public record find first record by sid ( short sid ) { int ix = find first record loc by sid ( sid ) ; if ( ix < 0 ) { return null ; } return ( record ) _records . get ( ix ) ; }
public static string new string iso8859_1 ( final byte [ ] bytes ) { return new string ( byte , charsets . iso_8859_1 ) ; }
public static string to hex string ( byte [ ] array ) { string builder sb = new string builder ( 2 * array . length ) ; for ( int i = 0 ; i < array . length ; i++ ) { string hex = integer . to hex string ( array [ i ] & 0xff ) ; if ( hex . length ( ) == 1 ) { sb . append ( ' 0 ' ) ; } sb . append ( hex ) ; } return sb . to string ( ) ; }
public void set new element name ( string new name ) { f new element name= new name ; }
public input stream get input stream ( ) throw i o exception { return url . open stream ( ) ; }
public font box font get font box font ( ) { if ( cid font ! = null ) { return cid font ; } else { return t1 font ; } }
public int get platform ( ) { return platform ; }
public void set idx ( long value ) { this . idx = value ; }
public output < t > y ( ) { return y ; }
public string get u r l ( ) { return service . get u r l ( ) ; }
protect void validate profile ( string profile ) { if ( ! string utils . have text ( profile ) ) { throw new illegal argument exception ( `` invalid profile [ `` + profile + `` ] : must contain text `` ) ; } if ( profile . char at ( 0 ) == ' ! ' ) { throw new illegal argument exception ( `` invalid profile [ `` + profile + `` ] : must not begin with ! operator `` ) ; } }
protect byte [ ] new sign key ( a w s credential credential , string date stamp , string region name , string service name ) { byte [ ] k secret = ( `` aws4 `` + credential . get a w s secret key ( ) ) . get byte ( charset . for name ( `` utf-8 `` ) ) ; byte [ ] k date = sign ( date stamp , k secret , sign algorithm . hmac s h a256 ) ; byte [ ] k region = sign ( region name , k date , sign algorithm . hmac s h a256 ) ; byte [ ] k service = sign ( service name , k region , sign algorithm . hmac s h a256 ) ; return sign ( aws4_terminator , k service , sign algorithm . hmac s h a256 ) ; }
public static void shift ( final boolean [ ] array , final int offset ) { if ( array == null ) { return ; } shift ( array , 0 , array . length , offset ) ; }
public string get language ( ) { return language ; }
public output < t > y ( ) { return y ; }
public double get x ( ) { return x ; }
public list < string > get component ( ) { list < string > component = new array list < string > ( ) ; c o s array co component = ( c o s array ) dictionary . get dictionary object ( c o s name . component ) ; if ( cos component == null ) { return component ; } for ( c o s base name : co component ) { component . add ( ( ( c o s name ) name ) . get name ( ) ) ; } return component ; }
public void debug ( object message ) { do log ( level . debug , fqcn , message , null , null ) ; }
public void split info ( string message ) { if ( log . be info enable ( ) ) log . info ( message , split message ( 0 ) ) ; }
public node get node ( ) { return node ; }
public list < node > get node ( ) { return node ; }
public void set owner document ( document doc ) { document = doc ; }
public set < type > get type ( ) { return type ; }
public void handle error ( exception e ) throw s a x exception { handle error ( e , true ) ; }
public void unload document ( document doc ) { unload document ( doc , true ) ; }
public int hash code ( ) { return get node ( ) . hash code ( ) ; }
public term aggregation builder collect mode ( sub agg collection mode collect mode ) { if ( collect mode == null ) { throw new illegal argument exception ( `` [ collect mode ] must not be null : [ `` + name + `` ] `` ) ; } this . collect mode = collect mode ; return this ; }
public void unload document ( document doc ) { return ; }
public int get index ( ) { return index ; }
public cleanup repository response cleanup repository ( cleanup repository request cleanup repository request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( cleanup repository request , snapshot request converter : : cleanup repository , option , cleanup repository response : : from x content , empty set ( ) ) ; }
public void for each ( lambda expression comsumer ) { iterator < object > iter = iterator ( ) ; while ( iter . have next ( ) ) { comsumer . invoke ( iter . next ( ) ) ; } }
public store get store ( ) { return store ; }
protect void do ( ) { execution list . execute ( ) ; }
public void set parameter value type name ( string value ) { this . parameter value type name = value ; }
public int get offset ( ) { return offset ; }
public i region get coverage ( ) { if ( f map . be empty ( ) ) return new region ( 0 , 0 ) ; int offset= -1 ; int end offset= -1 ; iterator < region > e= f map . value ( ) . iterator ( ) ; while ( e . have next ( ) ) { i region r= e . next ( ) ; if ( offset < 0 || r . get offset ( ) < offset ) offset= r . get offset ( ) ; int end= r . get offset ( ) + r . get length ( ) ; if ( end > end offset ) end offset= end ; } return new region ( offset , end offset - offset ) ; }
public void close ( ) throw i o exception { document . close ( ) ; }
public field set set field ( field field ) { return set field ( new field description . for loaded field ( field ) ) ; }
public document get document ( ) { return doc ; }
public void set target ( string target to add ) { if ( target to add . equal ( `` `` ) ) { throw new build exception ( `` target attribute must not be empty `` ) ; } target . add ( target to add ) ; target attribute set = true ; }
public final void add term freq vector ( term freq vector vector ) throw i o exception { if ( ! be document open ( ) ) throw new illegal state exception ( `` can not add term vector when document be not open `` ) ; if ( be field open ( ) ) throw new illegal state exception ( `` can not add term vector when field be open `` ) ; add term freq vector internal ( vector ) ; }
public final void add term ( string term text , int freq ) { if ( ! be document open ( ) ) throw new illegal state exception ( `` can not add term when document be not open `` ) ; if ( ! be field open ( ) ) throw new illegal state exception ( `` can not add term when field be not open `` ) ; add term internal ( term text , freq ) ; }
public log command set max count ( int max count ) { check callable ( ) ; this . max count = max count ; return this ; }
public void set description ( string description ) { this . description = description ; }
public int frequency ( int key ) { return frequency . frequency ( key ) ; }
public similarity get default similarity ( ) { return similarity service ! = null ? similarity service . get default similarity ( ) : null ; }
public similarity get similarity ( searcher searcher ) { return searcher . get similarity ( ) ; }
public static void flip to flush ( byte buffer buffer , int position ) { buffer . limit ( buffer . position ( ) ) ; buffer . position ( position ) ; }
public void write optional byte reference ( @ nullable byte reference byte ) throw i o exception { if ( bytes == null ) { write v int ( 0 ) ; return ; } write v int ( byte . length ( ) + 1 ) ; byte . write to ( this ) ; }
public static void make heap ( final byte [ ] ref array , final int offset , final int length , final int [ ] heap , final byte comparator c ) { byte array . ensure offset length ( ref array , offset , length ) ; if ( heap . length < length ) throw new illegal argument exception ( `` the heap length ( `` + heap . length + `` ) be small than the number of element ( `` + length + `` ) `` ) ; int i = length ; while ( i -- ! = 0 ) heap [ i ] = offset + i ; i = length > > > 1 ; while ( i -- ! = 0 ) down heap ( ref array , heap , length , i , c ) ; }
public void count down ( ) { delegate . count down ( ) ; }
public static vector get initial vector ( vector iterable corpus ) { vector initial vector = new dense vector ( corpus . num col ( ) ) ; initial vector . assign ( 1 . 0 / math . sqrt ( corpus . num col ( ) ) ) ; return initial vector ; }
public query get query ( ) { return query ; }
public query get query ( ) { return query ; }
public string [ ] get pattern ( ) { return pattern ; }
public final int start offset ( ) { return start offset ; }
public static boolean be valid ( string st value ) { return n c name . be valid ( st value ) ; }
public strategy get strategy ( ) { return strategy ; }
public list < visual resource > get public vr instance ( ) { return collection . unmodifiable list ( get public ( get vr instance ( ) ) ) ; } // get public vr instance ( )
public void set ( object instance ) { this . declared class = instance . get class ( ) ; this . instance = instance ; }
public set < string > get vr type ( ) { return collection . unmodifiable set ( new hash set < string > ( vr type ) ) ; }
public list < parameter > get all parameter ( ) { return all parameter ; }
public static data type get unsigned byte data type ( ) { try { return new unsigned byte d t ( `` http : //www . w3 . org/2001/ x m l schema # unsigned byte `` ) ; } catch ( invalid u r i exception iue ) { return null ; } }
public static data type get unsigned short data type ( ) { try { return new unsigned short d t ( `` http : //www . w3 . org/2001/ x m l schema # unsigned short `` ) ; } catch ( invalid u r i exception iue ) { return null ; } }
public static data type get unsigned byte data type ( ) { try { return new unsigned byte d t ( `` http : //www . w3 . org/2001/ x m l schema # unsigned byte `` ) ; } catch ( invalid u r i exception iue ) { return null ; } }
public locale get language ( ) { return language ; }
public static char value a char ( string key , char default val ) { string val = value for ( key ) ; if ( val == null ) { return default val ; } if ( val . length ( ) > 1 ) { x r log . exception ( `` property ' `` + key + `` ' be request a a character . the value of ' `` + val + `` ' be too long to be a char . return only the first character . `` ) ; } return val . char at ( 0 ) ; }
public long get timeout ( ) { return timeout ; }
public int read ( ) throw i o exception { int re = super . read ( ) ; if ( res ! = -1 ) { count++ ; check limit ( ) ; } return re ; }
public list < string > get mime type ( ) { return mime type ; }
public void set resource ( resource resource ) { this . resource = resource ; }
public data store get data store ( ) { return data store ; }
public executable get executable ( ) { return executable ; }
public static void set user config file ( file user config file ) { if ( gate . user config file ! = null ) { throw new illegal state exception ( `` user config file have already be set `` ) ; } gate . user config file = user config file ; }
public file get maven home ( ) { return maven home ; }
public static string get default user config file name ( ) { string file prefix = `` `` ; if ( run on unix ( ) ) file prefix = `` . `` ; string user config name = system . get property ( `` user . home `` ) + string . get file sep ( ) + file prefix + gate_dot_xml ; return user config name ; } // get default user config file name
public file get dir ( ) { return this . dir ; }
public void set simple array data extension ( final list < object > simple array data extension ) { this . simple array data extension = simple array data extension ; }
public void set action ( string action ) { this . action = action ; }
public font box font get font box font ( ) { if ( cid font ! = null ) { return cid font ; } else { return t1 font ; } }
public int get select index ( ) { return select index ; }
public void set select index ( int index ) { select index = index ; }
public controller get controller ( ) { return controller ; }
public void set style ( style style ) { this . style = style ; }
protect void set internal comment ( string text ) { comment = text ; }
public void set tag ( tag tag ) { this . tag = tag ; }
public synchronize boolean be s s l ( ) { return use s s l ; }
public model and view model and view ( object model , string view name ) { return new model and view ( model , view name ) ; }
public < t > plugin create rule builder use default plugin class ( / * @ nullable * / class < t > type ) { this . dflt plugin class = type ; return this ; }
public void set output ( file file ) throw i o exception { create x m l writer ( ) . set output stream ( new file output stream ( file ) ) ; }
public int length ( ) { return get size ( ) ; }
public string get description ( ) { return description ; }
public string get file name ( ) { return file name ; }
public list < resource > get resource ( ) { return resource ; }
public configuration add u r l ( url url ) throw map exception { metadata source . add u r l ( url ) ; return this ; }
public static class loader get class loader ( ) { return get class loader ( loader . class , null ) ; }
public long get n ( ) { return n ; }
public input stream get input stream ( ) { return stream ; }
public double [ ] get key ( ) { return key ; }
public static persistence util get persistence util ( ) { return new persistence util impl ( ) ; }
public double get time ( ) { return time ; }
public void set first row ( int first row ) { _range . set first row ( first row ) ; }
public static int [ ] new int array ( int len ) { if ( len == 0 ) { return empty_int_array ; } return new int [ len ] ; }
public final int get end a ( ) { return end a ; }
public int get offset ( ) { return offset ; }
public long get n ( ) { return n ; }
public void set parameter ( parameter [ ] parameter ) { if ( parameter ! = null ) { for ( int i = 0 ; i < parameter . length ; i++ ) { config parameter . add ( parameter [ i ] ) ; } } }
public string to string ( comparison formatter formatter ) { return formatter . get description ( this ) ; }
public restore snapshot request partial ( boolean partial ) { this . partial = partial ; return this ; }
public void set image ( final image image ) { this . image = image ; }
public i path get system library path ( ) { return f system library ; }
public boolean be attach thread ( ) { return attach thread ; }
public int get help context ( ) { return help context ; }
public request option add header ( string key , string value ) { check header ( ) ; object . require non null ( key , `` no null key accept `` ) ; object . require non null ( value , `` no null value accept `` ) ; header . add ( key , value ) ; return this ; }
protect void enter ( ct element e ) { }
public option get option ( ) { return option ; }
public mime type get mime type ( ) { return mime type ; }
public polyglot exception get exception ( ) { return impl . get execution event exception ( impl ) ; }
public list < value > get input value ( ) { return impl . get execution event input value ( impl ) ; }
public static builder new builder ( ) { return new builder ( ) ; }
public string get message ( ) { return message ; }
public string get host ( ) { return host ; }
public final void cancel ( ) { super . cancel ( ) ; }
public object get value ( ) { return null ; }
public string to string ( ) { return impl . to string ( impl ) ; }
public byte [ ] get byte ( ) { return byte ; }
public int get column number ( ) { return -1 ; }
public string source ( ) { return source ; }
public void set available ( long available ) { long old available = this . available ; if ( available > system . current time millis ( ) ) this . available = available ; else this . available = 0l ; support . fire property change ( `` available `` , long . value of ( old available ) , long . value of ( this . available ) ) ; }
public string to string ( ) { return to string ( `` `` ) ; }
public member get member ( ) { return this . executable ; }
public boolean can invoke member ( string identifier ) { object . require non null ( identifier , `` identifier `` ) ; return impl . can invoke ( identifier , receiver ) ; }
public boolean remove member ( string identifier ) { object . require non null ( identifier , `` identifier `` ) ; return impl . remove member ( receiver , identifier ) ; }
public date time minus ( long duration ) { return with duration add ( duration , -1 ) ; }
public boolean equal ( object other ) { return ( this == other || ( other instanceof bean component definition & & super . equal ( other ) ) ) ; }
public void set bound box ( bound box b box ) { bound box = b box ; }
public string name ( ) { return name ; }
public final boolean local ( ) { return local ; }
public int get fetch size ( ) { return fetch size ; }
public static string evt next publisher id ( evt_handle publisher enum ) { int by reference publisher id buffer use = new int by reference ( ) ; boolean result = wevtapi . instance . evt next publisher id ( publisher enum , 0 , null , publisher id buffer use ) ; int error code = kernel32 . instance . get last error ( ) ; if ( ( ! result ) & & error code ! = kernel32 . error_insufficient_buffer ) { throw new win32 exception ( error code ) ; } char [ ] publisher id buffer = new char [ publisher id buffer use . get value ( ) ] ; result = wevtapi . instance . evt next publisher id ( publisher enum , publisher id buffer . length , publisher id buffer , publisher id buffer use ) ; if ( ! result ) { throw new win32 exception ( kernel32 . instance . get last error ( ) ) ; } return native . to string ( publisher id buffer ) ; }
public path get path ( ) { return path ; }
protect builder create builder ( ) { final builder builder = get builder ( ) ; return builder ! = null ? builder : new builder ( ) ; }
public boolean be boolean ( ) { return false ; }
public static parse and validate result parse ( execution input execution input ) { try { parser parser = new parser ( ) ; document document = parser . parse document ( execution input . get query ( ) ) ; return parse and validate result . new result ( ) . document ( document ) . variable ( execution input . get variable ( ) ) . build ( ) ; } catch ( invalid syntax exception e ) { return parse and validate result . new result ( ) . syntax exception ( e ) . variable ( execution input . get variable ( ) ) . build ( ) ; } }
public static parse and validate result parse and validate ( graph q l schema graph q l schema , execution input execution input ) { parse and validate result result = parse ( execution input ) ; if ( ! result . be failure ( ) ) { list < validation error > error = validate ( graph q l schema , result . get document ( ) ) ; return result . transform ( builder - > builder . validation error ( error ) ) ; } return result ; }
public void write ( final char sequence str ) { check not null ( str ) ; if ( buffer . length ( ) == 0 ) { buffer . append ( str ) ; } else { buffer . insert ( cursor , str ) ; } cursor += str . length ( ) ; if ( be over type ( ) & & cursor < buffer . length ( ) ) { buffer . delete ( cursor , ( cursor + str . length ( ) ) ) ; } }
public boolean be bullet ( ) { paragraph property fetcher < boolean > fetcher = new paragraph property fetcher < boolean > ( get level ( ) ) { public boolean fetch ( c t text paragraph property prop ) { if ( prop . be set bu none ( ) ) { set value ( false ) ; return true ; } if ( prop . be set bu font ( ) ) { if ( prop . be set bu char ( ) || prop . be set bu auto num ( ) ) { set value ( true ) ; return true ; } / * else { // excel treat text with bu font but no char/autonum // a not bulleted // possibly the font be just use if bullet turn on again ? } * / } return false ; } } ; fetch paragraph property ( fetcher ) ; return fetcher . get value ( ) == null ? false : fetcher . get value ( ) ; }
public type get type ( ) { return type ; }
public module declaration add directive ( string directive ) { return add directive ( parse module directive ( directive ) ) ; }
public @ nullable graph q l type get type ( @ not null string type name ) { return type map . get ( type name ) ; }
public static boolean be input ( graph q l type type ) { graph q l unmodified type unmodified type = unwrap all ( type ) ; return unmodified type instanceof graph q l scalar type || unmodified type instanceof graph q l enum type || unmodified type instanceof graph q l input object type ; }
public static boolean be scalar ( graph q l type type ) { return type instanceof graph q l scalar type ; }
protect void set type name ( char [ ] type name ) { this . type name = type name ; }
public boolean be enable ( ) { return this . enable ; }
public static void set meta class ( class self , meta class meta class ) { final meta class registry meta class registry = groovy system . get meta class registry ( ) ; if ( meta class == null ) meta class registry . remove meta class ( self ) ; else { if ( meta class instanceof handle meta class ) { meta class registry . set meta class ( self , ( ( handle meta class ) meta class ) . get adaptee ( ) ) ; } else { meta class registry . set meta class ( self , meta class ) ; } if ( self== null object . class ) { null object . get null object ( ) . set meta class ( meta class ) ; } } }
public boolean equal ( object obj ) { if ( obj instanceof event ) { return to string ( ) . equal ( obj . to string ( ) ) ; } else { return false ; } }
public void set variable ( variable declaration variable ) { assert not null ( variable ) ; this . variable = variable ; variable . set parent ( this ) ; }
public void set meta class creation handle ( meta class creation handle handle ) { if ( handle == null ) throw new illegal argument exception ( `` can not set meta class creation handle to null value ! `` ) ; class info . clear modify expandos ( ) ; handle . set disable custom meta class lookup ( meta class creation handle . be disable custom meta class lookup ( ) ) ; meta class creation handle = handle ; }
public final dot name super name ( ) { return super class type == null ? null : super class type . name ( ) ; }
public meta method get setter ( ) { return setter ; }
public void set script base class ( final string script base class ) { this . script base class = script base class ; }
public void register immutable ( final class < ? > . . . c ) { for ( final class < ? > cl : c ) { ignore . add ( cl ) ; } }
public file hunt for the script file ( string input ) { return groovy main . search for groovy script file ( input ) ; }
public void set ( object object , object value ) throw exception { }
public string get property for setter ( string setter name ) { if ( setter name == null || setter name . length ( ) == 0 ) return null ; if ( setter name . start with ( `` set `` ) ) { string prop = setter name . substring ( 3 ) ; return meta class helper . convert property name ( prop ) ; } return null ; }
public void set registry ( registry registry ) { this . registry = registry ; }
public boolean be public ( ) { return modifier . be public ( get modifier ( ) ) ; }
public void set modifier ( int modifier ) { this . modifier = modifier ; }
public string get input file ( ) { return input file name ; }
public charset get default charset ( ) { return this . default charset ; }
public t head ( ) { if ( ! have buffer ) { buffer = iter . next ( ) ; have buffer = true ; } return buffer ; }
public string get expression ( ) { return expression ; }
public string get property ( ) { return property ; }
public string get method name ( ) { return method name ; }
public void remove attribute delegate ( closure attr delegate ) { get proxy builder ( ) . attribute delegate . remove ( attr delegate ) ; }
public closure add attribute delegate ( closure attr delegate ) { get proxy builder ( ) . attribute delegate . add first ( attr delegate ) ; return attr delegate ; }
public node get node ( ) { return node ; }
protect void post instantiate ( ) { }
public static < e > list < e > get list ( object list ) { return get list ( list , false ) ; }
public string get identifier ( ) { return identifier ; }
public object get proxy ( ) { return proxy ; }
public node get node ( ) { return node ; }
public string to string ( ) { string builder sb = new string builder ( 256 ) ; sb . append ( `` ( `` ) ; sb . append ( get subject ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get predicate ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get object ( ) ) ; sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
public runner safe runner for class ( class < ? > test class ) { try { runner runner = runner for class ( test class ) ; if ( runner ! = null ) { configure runner ( runner ) ; } return runner ; } catch ( throwable e ) { return new error reporting runner ( test class , e ) ; } }
protect void ensure capacity ( final int require capacity ) { if ( require capacity > this . buffer . capacity ( ) ) { expand capacity ( require capacity ) ; } }
public v put ( k key , v value ) { return map . put ( key , value ) ; }
public boolean be synthetic ( ) { return this . synthetic ; }
public static boolean be primitive type ( class node cn ) { return type util . be primitive type ( cn ) ; }
public static class node get wrapper ( class node cn ) { cn = cn . redirect ( ) ; if ( ! be primitive type ( cn ) ) return cn ; class node result = primitive_type_to_wrapper_type_map . get ( cn ) ; if ( null ! = result ) { return result ; } return cn ; }
public string get field name ( ) { return field name ; }
public collection < statement > get statement ( ) { return statement ; }
public string get code ( ) { return this . code ; }
public void set system property mode name ( string constant name ) throw illegal argument exception { this . system property mode = constant . a number ( constant name ) . int value ( ) ; }
public closure < ? super t > get closure ( ) { return i closure ; }
public string get text type ( ) { return f text type ; }
protect void set type name ( char [ ] type name ) { this . type name = type name ; }
public static class < ? > get type argument ( type generic type ) { if ( ! ( generic type instanceof parameterized type ) ) return null ; parameterized type parameterized type = ( parameterized type ) generic type ; class < ? > type arg = ( class < ? > ) parameterized type . get actual type argument ( ) [ 0 ] ; return type arg ; }
public static class < ? > get type argument ( type generic type ) { if ( ! ( generic type instanceof parameterized type ) ) return null ; parameterized type parameterized type = ( parameterized type ) generic type ; class < ? > type arg = ( class < ? > ) parameterized type . get actual type argument ( ) [ 0 ] ; return type arg ; }
public int get type ( ) { return type ; }
public void set label ( string label ) { this . label = label ; }
public string get method name ( ) { return method name ; }
protect collection < field access > field of ( class < ? > c ) { collection < field access > field = field of a s t class . get ( c ) ; if ( field ! = null ) return field ; field = new array list < field access > ( ) ; get field ( c , field ) ; field of a s t class . put ( c , field ) ; return field ; }
public string get phase ( ) { return phase ; }
public output < string > output ( ) { return output ; }
public string get script ( ) { return script ; }
public boolean be preview enabled ( ) { return f preview enable ; }
public boolean be enable ( ) { return this . enable ; }
public string get error message ( ) { return error message ; }
public list < warn message > get warning ( ) { return warning ; }
public int get warn count ( ) { return ( have warning ( ) ? warning . size ( ) : 0 ) ; }
public int get limit ( ) { return limit ; }
public string get configuration ( ) { return this . configuration ; } // -- string get configuration ( )
public void next phase ( ) throw compilation fail exception { goto phase ( this . phase + 1 ) ; }
public final int column count ( ) { return column ; }
public message get message ( ) { return message ; } // get message
public @ not null thread get thread ( ) { return thread ; }
protect string list get category ( ) { return this . category ; }
public static string get text ( process self ) throw i o exception { string text = i o groovy method . get text ( new buffer reader ( new input stream reader ( self . get input stream ( ) ) ) ) ; close stream ( self ) ; return text ; }
public static < t > t with writer ( output stream stream , @ closure params ( value= simple type . class , options= `` java . io . writer `` ) closure < t > closure ) throw i o exception { return with writer ( new output stream writer ( stream ) , closure ) ; }
public static < t > t with writer ( file file , @ closure params ( value = simple type . class , option = `` java . io . buffer writer `` ) closure < t > closure ) throw i o exception { return i o groovy method . with writer ( new writer ( file ) , closure ) ; }
public v put ( k key , v value ) { return put ( key , value , false ) ; }
public string get temp name for file ( string orig file ) { return multi file writer . get temp name for file ( orig file ) ; }
public static void disable globally ( ) { default meta class info . set without custom metaclass creation handle ( true ) ; expando meta class creation handle . disable ( ) ; }
public static void set meta class ( class self , meta class meta class ) { final meta class registry meta class registry = groovy system . get meta class registry ( ) ; if ( meta class == null ) meta class registry . remove meta class ( self ) ; else { if ( meta class instanceof handle meta class ) { meta class registry . set meta class ( self , ( ( handle meta class ) meta class ) . get adaptee ( ) ) ; } else { meta class registry . set meta class ( self , meta class ) ; } if ( self== null object . class ) { null object . get null object ( ) . set meta class ( meta class ) ; } } }
public object create builder use constructor ( string . . . param type name ) { if ( param type name == null ) { report error ( `` create object ( ) . use constructor ( string [ ] ) `` , `` null parameter type not allow `` ) ; return this ; } class < ? > [ ] param type = new class < ? > [ param type name . length ] ; for ( int i = 0 ; i < param type name . length ; i++ ) { try { param type [ i ] = class loader . load class ( param type name [ i ] ) ; } catch ( class not find exception e ) { this . report error ( format ( `` create object ( ) . use constructor ( % s ) `` , arrays . to string ( param type name ) ) , format ( `` class ' % s ' can not be load `` , param type name [ i ] ) ) ; } } return use constructor ( param type ) ; }
public string to string ( ) { string builder sb = new string builder ( 256 ) ; sb . append ( `` ( `` ) ; sb . append ( get subject ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get predicate ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get object ( ) ) ; sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
public input stream get input stream ( ) throw i o exception { return new reader input stream ( reader ) ; }
public static < t > t with object output stream ( output stream output stream , @ closure params ( value= simple type . class , options= `` java . io . object output stream `` ) closure < t > closure ) throw i o exception { return with stream ( new object output stream ( output stream ) , closure ) ; }
public static list < string > read line ( url self ) throw i o exception { return i o groovy method . read line ( new reader ( self ) ) ; }
public static list < string > read line ( file file ) throw i o exception { return i o groovy method . read line ( new reader ( file ) ) ; }
public static list < string > read line ( file file ) throw i o exception { return i o groovy method . read line ( new reader ( file ) ) ; }
public static buffer writer new writer ( file file , string charset ) throw i o exception { return new writer ( file , charset , false ) ; }
public void set output ( file file ) throw i o exception { create x m l writer ( ) . set output stream ( new file output stream ( file ) ) ; }
public static < t > t with writer append ( file file , string charset , @ closure params ( value = simple type . class , option = `` java . io . buffer writer `` ) closure < t > closure ) throw i o exception { return i o groovy method . with writer ( new writer ( file , charset , true ) , closure ) ; }
public static < t > t with writer ( file file , @ closure params ( value = simple type . class , option = `` java . io . buffer writer `` ) closure < t > closure ) throw i o exception { return i o groovy method . with writer ( new writer ( file ) , closure ) ; }
public void add object ( rev object object ) throw incorrect object type exception { if ( ! exclude ( object ) ) add object ( object , 0 ) ; }
public static string get filter stack trace ( throwable t ) { throwable cause = t ; if ( ( t instanceof tika exception ) & & t . get cause ( ) ! = null ) { cause = t . get cause ( ) ; } return get stack trace ( cause ) ; }
public boolean be empty ( ) { return name . be empty ( ) ; }
public c s t node remove ( int index ) { if ( index < 1 ) { throw new groovy bug error ( `` attempt to remove ( ) root node of reduction `` ) ; } return ( c s t node ) element . remove ( index ) ; }
public c s t node get ( int index ) { c s t node element = null ; if ( index < size ( ) ) { element = ( c s t node ) element . get ( index ) ; } return element ; }
protect void set name source start ( int start ) { this . name start= start ; }
public double get ( time unit unit ) { return get ( 0 , unit ) ; }
public line string get line ( ) { return line ; }
public static object get default value ( annotation annotation , string attribute name ) { if ( annotation == null ) { return null ; } return get default value ( annotation . annotation type ( ) , attribute name ) ; }
public binary node binary node ( byte [ ] data ) { return binary node . value of ( data ) ; }
public method get method ( ) { return method ; }
public static < t > t cast node ( final object node , final class < t > node class ) { try { return node class . cast ( node ) ; } catch ( final class cast exception e ) { throw new invalid node type exception ( node , node class ) ; } }
public boolean be interface ( ) { return this . be interface ; }
public byte [ ] buffer ( ) { return this . buffer ; }
public void set value ( t t ) { this . value = t ; }
public object remove ( ) { if ( be empty ( ) ) { throw new buffer underflow exception ( `` the buffer be already empty `` ) ; } object element = buffer [ head ] ; if ( element ! = null ) { buffer [ head ] = null ; head = increment ( head ) ; } return element ; }
public void set charset ( charset charset ) { assert . not null ( charset , `` charset must not be null `` ) ; this . charset = charset ; }
public string get content ( ) { if ( char == null ) { return null ; } return new string ( char ) ; }
public collection < v > value ( ) { return this . map . value ( ) ; }
public object get result ( ) { return result ; }
public list iterator list iterator ( ) { if ( fast ) { return new list iter ( 0 ) ; } else { return list . list iterator ( ) ; } }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public boolean be quote ( ) { return be quote ; }
public list < node > get node ( ) { return node ; }
protect void init type writer ( ) { this . type writer . clear ( ) ; if ( ! this . register default ) { return ; } this . type writer . add all ( get base typed writer ( ) ) ; extend type writer ( this . typed writer ) ; }
public static string pretty print ( pretty printable tree ) { string builder sb = new string builder ( ) ; pretty print ( tree . get node ( ) , sb , `` `` , true , true ) ; return sb . to string ( ) ; }
public void add ( json element element ) { if ( element == null ) { element = json null . instance ; } element . add ( element ) ; }
public final void add ( byte . . . element ) { add ( element , 0 , element . length ) ; }
public static array < long > of all ( long [ ] array ) { object . require non null ( array , `` array be null `` ) ; return of all ( iterator . of all ( array ) ) ; }
public int size ( ) { return size ; }
public static double function mod ( final double b ) { return new double function ( ) { @ override public double apply ( double a ) { return a % b ; } } ; }
public void remove ( ) { throw new unsupported operation exception ( get class ( ) . get name ( ) ) ; }
public boolean be value ( ) { return value ; }
public t read object ( reader reader ) throw i o exception { verify ( ) ; return read ( reader ) . get object ( ) ; }
public set < k > key set ( ) { if ( key set == null ) { key set = new key set < > ( this ) ; } return key set ; }
public list < t > get ( ) { return new array list < t > ( field ) ; }
public static < t > t assert not null ( string msg , t reference ) { if ( reference == null ) { throw new assertion error ( msg ) ; } return reference ; }
public string to string ( ) { return to string ( `` `` ) ; }
public static boolean be not empty ( @ nullable string string ) { return ! be empty ( string ) ; }
public set < v > value ( ) { if ( value == null ) { value = new value < > ( this ) ; } return value ; }
public list < string > get column name ( ) { return collection . unmodifiable list ( this . declared column ) ; }
public collection value ( ) { collection v = value ; return ( vs ! = null ) ? v : ( value = new value ( ) ) ; }
public static < e extend comparable < ? super e > > immutable sort set < e > of ( e e1 , e e2 ) { return construct ( order . natural ( ) , 2 , e1 , e2 ) ; }
public static < t > t get ( iterable < t > iterable , int position ) { check not null ( iterable ) ; return ( iterable instanceof list ) ? ( ( list < t > ) iterable ) . get ( position ) : iterators . get ( iterable . iterator ( ) , position ) ; }
public static < e > iterable < e > empty if null ( final iterable < e > iterable ) { return iterable == null ? iterable utils . < e > empty iterable ( ) : iterable ; }
public static boolean safe equal ( object o1 , object o2 ) { if ( o1 == o2 ) { return true ; } if ( o1 == null || o2 == null ) { return false ; } return o1 . equal ( o2 ) ; }
public list < t > get ( ) { return new array list < t > ( field ) ; }
public list < dependency cycle > get cycle ( ) { return cycle ; }
public void set iterator ( final iterator < ? extend e > iterator ) { this . iterator = iterator ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public static boolean [ ] ensure capacity ( final boolean [ ] array , final int length ) { if ( length > array . length ) { final boolean t [ ] = new boolean [ length ] ; system . arraycopy ( array , 0 , t , 0 , array . length ) ; return t ; } return array ; }
public < e extend t > e min ( @ nullable e a , @ nullable e b ) { return ( compare ( a , b ) < = 0 ) ? a : b ; }
public void test low ( ) { assert equal ( null , navigable set . low ( a ) ) ; assert equal ( a , navigable set . low ( b ) ) ; assert equal ( b , navigable set . low ( c ) ) ; }
public static < e > multiset < e > constrain multiset ( multiset < e > multiset , constraint < ? super e > constraint ) { return new constrain multiset < e > ( multiset , constraint ) ; }
public static < t > iterable < t > adapt for loop ( final iterator < t > it ) { return new iterable < t > ( ) { @ override public iterator < t > iterator ( ) { return it ; } } ; }
public float get b ( ) { return b ; }
public boolean be function ( ) { return this . function ; }
public boolean contains ( char [ ] text , int off , int len ) { return map . contains key ( text , off , len ) ; }
public void set optional ( boolean optional ) { this . be optional = optional ; }
public int read ( ) throw i o exception { int b = read first byte ( ) ; return b > = 0 ? b : in . read ( ) ; }
public static buffer writer new writer ( file file , string charset ) throw i o exception { return new writer ( file , charset , false ) ; }
public byte read w p byte ( ) throw i o exception { return in . read byte ( ) ; }
public string get file name ( ) { return file name ; }
public void set canonical ( boolean canonical ) { this . canonical = canonical ; }
public string get address ( ) { return this . address ; } // -- string get address ( )
public internet domain name top private domain ( ) { if ( be top private domain ( ) ) { return this ; } check state ( be under public suffix ( ) , `` not under a public suffix : % s `` , name ) ; return ancestor ( public suffix index - 1 ) ; }
public class info list get class implement ( final string interface name ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } if ( ! scan spec . enable class info ) { throw new illegal argument exception ( `` please call class graph # enable class info ( ) before # scan ( ) `` ) ; } final class info class info = class name to class info . get ( interface name ) ; return class info == null ? class info list . empty_list : class info . get class implement ( ) ; }
public boolean be public ( ) { return modifier . be public ( get modifier ( ) ) ; }
public boolean be synchronize ( ) { return modifier . be synchronize ( modifier ) ; }
public static < b extend builder < b > > b new builder ( ) { return new builder < b > ( ) . a builder ( ) ; }
public void execute ( ) throw execution exception { throw new execution exception ( `` resource `` + get class ( ) + `` have n't overriden the execute ( ) method `` ) ; } // execute ( )
public double get ( time unit unit ) { return get ( 0 , unit ) ; }
public boolean be lock ( ) { return owner ! = null ; }
public boolean have queue thread ( ) { return sync . have queue thread ( ) ; }
protect block queue < runnable > create queue ( int queue capacity ) { if ( queue capacity > 0 ) { return new link block queue < runnable > ( queue capacity ) ; } else { return new synchronous queue < runnable > ( ) ; } }
public boolean be stop ( ) { return run state . be stop ( ) ; }
public void set separator ( string separator ) { this . separator = separator ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public < e extend t > e max ( @ nullable e a , @ nullable e b ) { return ( compare ( a , b ) > = 0 ) ? a : b ; }
public static builder builder ( ) { return new builder ( ) ; }
public static void set iterator provider ( final service iterator provider sip ) throw security exception { service iterator provider . set instance ( sip ) ; }
public byte string hmac sha256 ( byte string key ) { return hmac ( `` hmac s h a256 `` , key ) ; }
public int hash code ( ) { return to string ( ) . hash code ( ) ; }
public string get encode ( ) { return encode ; }
public long count ( ) { return count ; }
public long get count ( ) { return count . get ( ) ; }
public final byte [ ] get byte array ( ) { return this . byte array ; }
public inet socket address get address ( ) { inet socket address addr = http server . get connector address ( 0 ) ; assert addr . get port ( ) ! = 0 ; return addr ; }
public internet domain name top private domain ( ) { if ( be top private domain ( ) ) { return this ; } check state ( be under public suffix ( ) , `` not under a public suffix : % s `` , name ) ; return ancestor ( public suffix index - 1 ) ; }
public second to standard second ( ) { check year and month ( `` second `` ) ; long second = get millis ( ) / date time constant . millis_per_second ; second = field utils . safe add ( second , get second ( ) ) ; second = field utils . safe add ( second , ( ( long ) get minute ( ) ) * ( ( long ) date time constant . seconds_per_minute ) ) ; second = field utils . safe add ( second , ( ( long ) get hour ( ) ) * ( ( long ) date time constant . seconds_per_hour ) ) ; second = field utils . safe add ( second , ( ( long ) get day ( ) ) * ( ( long ) date time constant . seconds_per_day ) ) ; second = field utils . safe add ( second , ( ( long ) get week ( ) ) * ( ( long ) date time constant . seconds_per_week ) ) ; return second . second ( field utils . safe to int ( second ) ) ; }
public list < medium type > get support medium type ( ) { return this . supported medium type ; }
public str tokenizer a tokenizer ( ) { return new str builder tokenizer ( ) ; }
public static < e extend comparable < ? super e > > immutable sort set < e > of ( e element ) { return new regular immutable sort set < e > ( immutable list . of ( element ) , order . natural ( ) ) ; }
public static < e > list < e > a list ( iterable < e > i ) { if ( i instanceof collection ) { return new array list < e > ( ( collection < e > ) i ) ; } array list < e > a = new array list < e > ( ) ; for ( e e : i ) { a . add ( e ) ; } return a ; }
public static annotation [ ] get filtering annotation ( final annotation [ ] annotation ) { if ( annotation == null || annotation . length == 0 ) { return filter helper . empty_annotations ; } final list < annotation > filtering annotation = new array list < > ( annotation . length ) ; for ( final annotation annotation : annotation ) { final class < ? extend annotation > annotation type = annotation . annotation type ( ) ; for ( final annotation meta annotation : annotation type . get declared annotation ( ) ) { if ( meta annotation instanceof entity filter ) { filter annotation . add ( annotation ) ; } } } return filter annotation . to array ( new annotation [ filter annotation . size ( ) ] ) ; }
public method get method ( ) { return method ; }
public boolean be name binding ( ) { return this . name binding ; }
public void set count ( int count ) { this . count = count ; }
public static module for module ( object module , module annotate method scanner scanner ) { return for object ( module , false , scanner ) ; }
public static module for module ( module module ) { return for object ( module , false , provide method scanner . instance ) ; }
public long get elapsed time ( phase phase , step step ) { return get elapsed time ( get step track ( phase , step ) ) ; }
protect boolean support non sync literal ( ) { return have capability ( `` literal+ `` ) ; }
public boolean be nullable ( ) { return this . nullable ; }
public void set optional ( boolean optional ) { this . be optional = optional ; }
public void set optional ( boolean optional ) { this . be optional = optional ; }
protect object pre destroy ( bean resolution context resolution context , bean context context , object bean ) { default bean context default context = ( default bean context ) context ; for ( int i = 0 ; i < method injection point . size ( ) ; i++ ) { method injection point method injection point = method injection point . get ( i ) ; if ( method injection point . be pre destroy method ( ) & & method injection point . require reflection ( ) ) { inject bean method ( resolution context , default context , i , bean ) ; } } if ( bean instanceof life cycle ) { bean = ( ( life cycle ) bean ) . stop ( ) ; } return bean ; }
public rule get rule ( ) { return this . rule ; }
public string get table ( ) { return table ; }
public autodiscover error code get error code ( ) { return error code ; }
public static role role ( string name ) { return role ( name ( name ) ) ; }
public int read ( byte [ ] b , int off , int len ) throw i o exception { int l = -1 ; if ( be read allow ( ) ) { l = super . read ( b , off , len ) ; check close ( l ) ; } return l ; }
public string get expression ( ) { return expression ; }
public int get database minor version ( ) { debug code call ( `` get database minor version `` ) ; return constant . version_minor ; }
public boolean get boolean ( c o s name key , boolean default value ) { return get boolean ( key , null , default value ) ; }
public string get u r l ( ) { return service . get u r l ( ) ; }
public database get database ( ) { return database ; }
public string get alias ( ) { return alias ; }
public final void cancel ( ) { super . cancel ( ) ; }
public collection < v > value ( ) { return this . map . value ( ) ; }
public double transform ( object o ) throw math illegal argument exception { double value = double . na n ; if ( o instanceof number || o instanceof string ) { value = default transformer . transform ( o ) ; } else { number transformer trans = get transformer ( o . get class ( ) ) ; if ( trans ! = null ) { value = trans . transform ( o ) ; } } return value ; }
public boolean be boolean ( ) { return false ; }
public string get expression ( ) { return expression ; }
public expression pre evaluate ( expression visitor visitor ) { return this ; }
public static expression visitor get optimizable visitor ( table table ) { return new expression visitor ( optimizable_min_max_count_all , 0 , null , null , table , null , null ) ; }
public final connection get innermost delegate internal ( ) { connection conn = connection ; while ( conn ! = null & & conn instanceof delegate connection ) { conn = ( ( delegate connection < ? > ) conn ) . get delegate internal ( ) ; if ( this == conn ) { return null ; } } return conn ; }
public float get b ( ) { return b ; }
public setting setting ( ) { return setting ; }
public default boolean be persistent ( entity entity ) { return jpa operation . be persistent ( entity ) ; }
protect int get child page count ( page p ) { return p . get child page count ( ) ; }
public time get time ( int parameter index , calendar cal ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get time ( parameter index , cal ) ; }
public array get array ( int parameter index ) throw s q l exception { check register ( parameter index ) ; return get open result set ( ) . get array ( parameter index ) ; }
public boolean be field separator at start ( ) { return super . be field separator at start ( ) ; }
protect string escape ( object text ) { return string escape utils . escape ecma script ( text . to string ( ) ) ; }
public boolean be support by ( column definition column , index index ) { boolean support = false ; if ( have bind ( bound . start ) ) support |= be inclusive ( bound . start ) ? index . support expression ( column , operator . gte ) : index . support expression ( column , operator . gt ) ; if ( have bind ( bound . end ) ) support |= be inclusive ( bound . end ) ? index . support expression ( column , operator . lte ) : index . support expression ( column , operator . lt ) ; return support ; }
public void set print grammar ( boolean print grammar ) { this . print grammar = print grammar ; }
public string get register procedure ( ) { return register procedure ; }
public boolean support catalog in privilege definition ( ) { debug code call ( `` support catalog in privilege definition `` ) ; return true ; }
public boolean support catalog in privilege definition ( ) { debug code call ( `` support catalog in privilege definition `` ) ; return true ; }
public boolean support schemas in privilege definition ( ) { debug code call ( `` support schema in privilege definition `` ) ; return true ; }
public boolean support schemas in privilege definition ( ) { debug code call ( `` support schema in privilege definition `` ) ; return true ; }
public i transaction get transaction ( ) { return this . transaction ; }
protect boolean be store low case identifier ( ) { return this . store low case identifier ; }
public int get max length ( ) { return max length ; }
public int get max column in index ( ) { debug code call ( `` get max column in index `` ) ; return 0 ; }
public int get max column in group by ( ) { debug code call ( `` get max column in group by `` ) ; return 0 ; }
public client configuration with max connection ( int max connection ) { set max connection ( max connection ) ; return this ; }
public int get max length ( ) { return max length ; }
public int get minor version ( ) { return constant . version_minor ; }
public runtime type info get wrapper ( ) { return wrapper ; }
public static row get row ( int row index , sheet sheet ) { row row = sheet . get row ( row index ) ; if ( row == null ) { row = sheet . create row ( row index ) ; } return row ; }
public string get message ( ) { return message ; }
public string get description ( ) { return description ; }
public static < e > list < e > a list ( iterable < e > i ) { if ( i instanceof collection ) { return new array list < e > ( ( collection < e > ) i ) ; } array list < e > a = new array list < e > ( ) ; for ( e e : i ) { a . add ( e ) ; } return a ; }
protect void debug code ( string text ) { if ( trace . be debug enable ( ) ) { trace . debug code ( get trace object name ( ) + `` . `` + text ) ; } }
protect void debug code ( string text ) { if ( trace . be debug enable ( ) ) { trace . debug code ( get trace object name ( ) + `` . `` + text ) ; } }
protect void debug code call ( string method name , string param ) { if ( trace . be debug enable ( ) ) { trace . debug code ( get trace object name ( ) + `` . `` + method name + `` ( `` + quote ( param ) + `` ) ; `` ) ; } }
public double get time ( ) { return time ; }
protect static string quote int array ( int [ ] s ) { return string utils . quote java int array ( s ) ; }
protect static string quote array ( string [ ] s ) { return string utils . quote java string array ( s ) ; }
public output < t > out ( ) { return out ; }
public string get name ( ) { int idx = math . max ( name . index of ( ' : ' ) , name . last index of ( '/ ' ) ) ; return idx < 0 ? name : name . substring ( idx + 1 ) ; }
public default void worker iteration end ( final memory memory ) { }
public collection < v > value ( ) { final list < v > value list = new array list < > ( ) ; for each pair ( new object object procedure < k , v > ( ) { @ override public boolean apply ( k key , v value ) { value list . add ( value ) ; return true ; } } ) ; return value list ; }
public void set src ( file src ) { set src resource ( new file resource ( src ) ) ; }
public int get po ( ) { return po ; }
public long code ( ) { return code ; }
public double get x ( ) { return x ; }
public i transaction get transaction ( ) { return this . transaction ; }
public v put ( k key , v value ) { return put ( key , value , false ) ; }
public int root ( ) { return root ; }
public type get type ( ) { return type ; }
public void insert node ( int index , object key , page child page ) { object [ ] new key = new object [ key count + 1 ] ; data utils . copy with gap ( key , new key , key count , index ) ; new key [ index ] = key ; key = new key ; key count++ ; long [ ] new child = new long [ child . length + 1 ] ; data utils . copy with gap ( child , new child , child . length , index ) ; new child [ index ] = child page . get pos ( ) ; child = new child ; page [ ] new child page = new page [ child page . length + 1 ] ; data utils . copy with gap ( child page , new child page , child page . length , index ) ; new child page [ index ] = child page ; child page = new child page ; long [ ] new count = new long [ count . length + 1 ] ; data utils . copy with gap ( count , new count , count . length , index ) ; new count [ index ] = child page . total count ; count = new count ; share flag & = ~ ( shared_keys | shared_children | shared_counts ) ; total count += child page . total count ; memory += map . get key type ( ) . get memory ( key ) ; memory += data utils . page_memory_child ; }
public string get type ( ) { return type ; }
public static void append time ( string builder buff , long nanos ) { if ( nanos < 0 ) { buff . append ( '- ' ) ; nanos = -nanos ; } / * * nanos now either in range from 0 to long . max_value or equal to * long . min_value . we need to divide nanos by 1000000 with unsigned division to * get correct result . the simple way to do this with such constraint be to * divide -nanos by -1000000 . * / long m = -nanos / -1_000_000 ; nanos -= ms * 1_000_000 ; long s = m / 1_000 ; m -= s * 1_000 ; long m = s / 60 ; s -= m * 60 ; long h = m / 60 ; m -= h * 60 ; string utils . append zero pad ( buff , 2 , h ) ; buff . append ( ' : ' ) ; string utils . append zero pad ( buff , 2 , m ) ; buff . append ( ' : ' ) ; string utils . append zero pad ( buff , 2 , s ) ; if ( m > 0 || nanos > 0 ) { buff . append ( ' . ' ) ; int start = buff . length ( ) ; string utils . append zero pad ( buff , 3 , m ) ; if ( nanos > 0 ) { string utils . append zero pad ( buff , 6 , nanos ) ; } for ( int i = buff . length ( ) - 1 ; i > start ; i -- ) { if ( buff . char at ( i ) ! = ' 0 ' ) { break ; } buff . delete char at ( i ) ; } } }
public input split [ ] get split ( job conf job , int num split ) throw i o exception { set format ( job ) ; job . set long ( `` mapred . min . split . size `` , long . max_value ) ; return root . get split ( job , num split ) ; }
public void insert node ( int index , object key , page child page ) { object [ ] new key = new object [ key count + 1 ] ; data utils . copy with gap ( key , new key , key count , index ) ; new key [ index ] = key ; key = new key ; key count++ ; long [ ] new child = new long [ child . length + 1 ] ; data utils . copy with gap ( child , new child , child . length , index ) ; new child [ index ] = child page . get pos ( ) ; child = new child ; page [ ] new child page = new page [ child page . length + 1 ] ; data utils . copy with gap ( child page , new child page , child page . length , index ) ; new child page [ index ] = child page ; child page = new child page ; long [ ] new count = new long [ count . length + 1 ] ; data utils . copy with gap ( count , new count , count . length , index ) ; new count [ index ] = child page . total count ; count = new count ; share flag & = ~ ( shared_keys | shared_children | shared_counts ) ; total count += child page . total count ; memory += map . get key type ( ) . get memory ( key ) ; memory += data utils . page_memory_child ; }
protect int get child page count ( page p ) { return p . get child page count ( ) ; }
public boolean contains key ( final object key ) { check key ( key ) ; return lookup key ( key ) ! = null ; }
public boolean contains ( object obj a , object obj b ) { spatial key a = ( spatial key ) obj a ; spatial key b = ( spatial key ) obj b ; for ( int i = 0 ; i < dimension ; i++ ) { if ( a . min ( i ) > b . min ( i ) || a . max ( i ) < b . max ( i ) ) { return false ; } } return true ; }
public void increase bound ( object bound , object add ) { spatial key b = ( spatial key ) bound ; spatial key a = ( spatial key ) add ; for ( int i = 0 ; i < dimension ; i++ ) { b . set min ( i , math . min ( b . min ( i ) , a . min ( i ) ) ) ; b . set max ( i , math . max ( b . max ( i ) , a . max ( i ) ) ) ; } }
public void write ( int b ) throw i o exception { byte [ ] buff = new byte [ 1 ] ; buff [ 0 ] = ( byte ) ( b & 0xff ) ; write ( buff , 0 , 1 ) ; }
public string get unique constraint name ( session session , table table ) { hash map < string , constraint > table constraint ; if ( table . be temporary ( ) & & ! table . be global temporary ( ) ) { table constraint = session . get local temp table constraint ( ) ; } else { table constraint = constraint ; } return get unique name ( table , table constraint , `` constraint_ `` ) ; }
public constraint find constraint ( session session , string name ) { constraint constraint = constraint . get ( name ) ; if ( constraint == null ) { constraint = session . find local temp table constraint ( name ) ; } return constraint ; }
public void increment ( ) { value++ ; }
public void close ( ) throw i o exception { if ( ! this . close ) { this . close = true ; this . out . flush ( ) ; } }
public output < v > idx ( ) { return idx ; }
public string get file name ( ) { return file name ; }
public void set dir ( file directory ) { this . directory = directory ; }
public static string get system id ( file file ) { return file_utils . to u r i ( file . get absolute path ( ) ) ; }
public string get file name ( ) { return file name ; }
public static void set read only ( object name ) { read only contexts . put ( name , name ) ; }
public void delete empty java file ( ) { if ( java file ! = null ) { enumeration e = java file . element ( ) ; while ( e . have more element ( ) ) { file file = ( file ) e . next element ( ) ; if ( file . exists ( ) & & file . length ( ) == 0 ) { log ( `` delete empty output file `` + file ) ; file . delete ( ) ; } } } }
public version result get result ( ) { return result ; }
public void set filter ( tree filter filter ) { this . filter = filter ; }
public void row process ( string [ ] row , t context ) { row . add ( row ) ; }
public constraint find constraint ( session session , string name ) { constraint constraint = constraint . get ( name ) ; if ( constraint == null ) { constraint = session . find local temp table constraint ( name ) ; } return constraint ; }
public void set join table ( jaxb join table value ) { this . join table = value ; }
protect final join fragment merge outer join ( list association ) throw map exception { join fragment outerjoin = get dialect ( ) . create outer join fragment ( ) ; iterator iter = association . iterator ( ) ; outer joinable association last = null ; while ( iter . have next ( ) ) { final outer joinable association oj = ( outer joinable association ) iter . next ( ) ; if ( last ! = null & & last . be many to many with ( oj ) ) { oj . add many to many join ( outerjoin , ( queryable collection ) last . get joinable ( ) ) ; } else { oj . add join ( outerjoin ) ; } last = oj ; } last = null ; return outerjoin ; }
public void row process ( string [ ] row , t context ) { row . add ( row ) ; }
public void set recursive ( boolean recursive ) { super . set internal recursive ( recursive ) ; }
public void set error output ( writer writer ) { error output = writer ; }
public void set escape char ( char escape char ) { this . escape char = escape char ; }
public static exception stop quietly ( service service ) { return stop quietly ( log , service ) ; }
public synchronize url get u r l ( ) { if ( be reference ( ) ) { return ( ( u r l resource ) get check ref ( ) ) . get u r l ( ) ; } return url ; }
public output < t > db ( ) { return db ; }
public int get max length ( ) { return max length ; }
public string to string ( ) { long diff = diff ( ) ; long millis = diff % 1000 ; long sec = ( diff/1000 ) % 60 ; long min = ( diff/ ( 1000 * 60 ) ) % 60 ; long h = ( diff/ ( 1000 * 3600 ) ) % 24 ; long day = diff/ ( 1000 * 3600 * 24 ) ; if ( day > 0 ) return days+ `` d `` +hs+ `` h `` +mins+ `` m `` +secs+ `` s `` +millis+ `` ms `` ; if ( hs > 0 ) return hs+ `` h `` +mins+ `` m `` +secs+ `` s `` +millis+ `` ms `` ; if ( min > 0 ) return mins+ `` m `` +secs+ `` s `` +millis+ `` ms `` ; if ( secs > 0 ) return secs+ `` s `` +millis+ `` m `` ; return millis+ `` m `` ; }
public int size ( ) { return size ; }
public static long copy ( input stream in , output stream out ) throw i o exception { return copy ( in , out , long . max_value ) ; }
public boolean match url ( string jdbc url ) { return jdbc url . to lower case ( ) . start with ( get url prefix ( ) ) ; }
public static void run ( string . . . args ) { run ( null , args ) ; }
public @ not null thread get thread ( ) { return thread ; }
public int get id ( ) { return id ; }
public int get source line ( int idx ) { return source line [ idx ] - 1 ; }
public final o get o s ( ) { return o ; }
public option get option ( ) { return option ; }
public byte [ ] read byte ( ) throw buffer exception { int len = read u int32 a int ( ) ; if ( len < 0 || len > 32768 ) throw new buffer exception ( `` bad item length : `` + len ) ; byte [ ] b = new byte [ len ] ; read raw byte ( b ) ; return b ; }
public int hash code ( ) { long len = get millis ( ) ; return ( int ) ( len ^ ( len > > > 32 ) ) ; }
public void set context ( object data ) { this . data = data ; }
public list < v > value ( ) { array list < v > list = new array list < v > ( ) ; for ( long k : key set ( ) ) { v value = find ( k ) . value ; if ( value ! = null ) { list . add ( value ) ; } } return list ; }
public static value lob db create temp clob ( reader in , long length , data handler handler ) { try { boolean compress = handler . get lob compression algorithm ( value . clob ) ! = null ; long remain = long . max_value ; if ( length > = 0 & & length < remain ) { remain = length ; } int len = get buffer size ( handler , compress , remain ) ; char [ ] buff ; if ( len > = integer . max_value ) { string data = i o utils . read string and close ( in , -1 ) ; buff = data . to char array ( ) ; len = buff . length ; } else { buff = new char [ len ] ; len = i o utils . read fully ( in , buff , len ) ; len = len < 0 ? 0 : len ; } if ( len < = handler . get max length inplace lob ( ) ) { byte [ ] small = new string ( buff , 0 , len ) . get byte ( constant . utf8 ) ; return value lob db . create small lob ( value . clob , small , len ) ; } value lob db lob = new value lob db ( value . clob , null , 0 ) ; lob . create temp from reader ( buff , len , in , remain , handler ) ; return lob ; } catch ( i o exception e ) { throw db exception . convert i o exception ( e , null ) ; } }
public double compression ( ) { return compression ; }
public static value lob create clob ( reader in , long length , data handler handler ) { try { if ( handler == null ) { string s = i o utils . read string and close ( in , ( int ) length ) ; return create small lob ( value . clob , s . get byte ( constant . utf8 ) ) ; } boolean compress = handler . get lob compression algorithm ( value . clob ) ! = null ; long remain = long . max_value ; if ( length > = 0 & & length < remain ) { remain = length ; } int len = get buffer size ( handler , compress , remain ) ; char [ ] buff ; if ( len > = integer . max_value ) { string data = i o utils . read string and close ( in , -1 ) ; buff = data . to char array ( ) ; len = buff . length ; } else { buff = new char [ len ] ; len = i o utils . read fully ( in , buff , len ) ; len = len < 0 ? 0 : len ; } if ( len < = handler . get max length inplace lob ( ) ) { byte [ ] small = new string ( buff , 0 , len ) . get byte ( constant . utf8 ) ; return value lob . create small lob ( value . clob , small ) ; } value lob lob = new value lob ( value . clob , null ) ; lob . create from reader ( buff , len , in , remain , handler ) ; return lob ; } catch ( i o exception e ) { throw db exception . convert i o exception ( e , null ) ; } }
public long previous value ( ) { if ( ! to before current high bit ( ) ) { return no_more_values ; } long high value = previous high value ( ) ; return combine high low value ( high value , current low value ( ) ) ; }
public static string capitalize ( string str ) { int str len ; if ( str == null || ( str len = str . length ( ) ) == 0 ) { return str ; } return new string buffer ( str len ) . append ( character . to title case ( str . char at ( 0 ) ) ) . append ( str . substring ( 1 ) ) . to string ( ) ; }
public int size ( ) { return size ; }
public void set value ( t t ) { this . value = t ; }
public static < t > t be a ( class < t > clazz ) { report matcher ( new instance of ( clazz ) ) ; return null ; }
public string to string ( ) { return to string ( `` `` ) ; }
public string name ( ) { return name ; }
public string get persister ( ) { return persister ; }
public string get value ( ) { return value ; }
public void set type ( int type ) { this . type = type ; }
public void set column name ( string column name ) { this . column name = column name ; }
public access get access ( ) { return this . access ; }
public list iterator list iterator ( int index ) { if ( fast ) { return new list iter ( index ) ; } else { return list . list iterator ( index ) ; } }
public void set implicit join path to one ( boolean value ) { this . implicit join path to one = value ; }
public void set batch size ( int batch size ) { this . batch size = batch size ; }
public final class get element type ( ) { return this . element type ; }
public final entity persister get persister ( ) { return persister ; }
public void set table ( boolean value ) { this . table = value ; }
protect void drop table ( string . . . name ) { jdbc test utils . drop table ( this . jdbc template , names ) ; }
public scope get scope ( ) { return scope ; } // get scope
public order by collection get order by ( ) { return this . order by ; }
public boolean get be read ( ) { return this . be read ; }
public void set sql type ( string value ) { this . sql type = value ; }
public string get sql type ( ) { return sql type ; }
public node get parent ( ) { return parent ; }
public void set foreign markup ( final list < element > foreign markup ) { this . foreign markup = foreign markup ; }
public list < string > get delete ( ) { return delete ; }
protect void validate profile ( string profile ) { if ( ! string utils . have text ( profile ) ) { throw new illegal argument exception ( `` invalid profile [ `` + profile + `` ] : must contain text `` ) ; } if ( profile . char at ( 0 ) == ' ! ' ) { throw new illegal argument exception ( `` invalid profile [ `` + profile + `` ] : must not begin with ! operator `` ) ; } }
public void set ( boolean value ) { this . value = value ; }
public boolean be update ( ) { return be update ; }
public void set select ( expression select , configuration config ) throw x path exception { this . select = select ; adopt child expression ( select ) ; }
public final t get entity ( ) { return entity ; }
public void set parameter ( string name , string . . . value ) { assert . not null ( name , `` parameter name must not be null `` ) ; this . parameter . put ( name , value ) ; }
public void set content ( final content content ) { this . content = content ; }
public string get alias ( ) { return alias ; }
public jaxb empty type get cascade all ( ) { return cascade all ; }
public final void sort ( ) { sort from to ( 0 , size ( ) - 1 ) ; }
public final boolean be cacheable ( ) { return cacheable ; }
public void stash invalid natural id reference ( entity persister persister , object [ ] invalid natural id value ) { persister = locate persister for key ( persister ) ; final natural id resolution cache entity natural id resolution cache = natural id resolution cache map . get ( persister ) ; if ( entity natural id resolution cache == null ) { throw new assertion failure ( `` expect natural id resolution cache to exist already for entity `` + persister . get entity name ( ) ) ; } entity natural id resolution cache . stash invalid natural id reference ( invalid natural id value ) ; }
public version get version ( ) { return version ; }
public boolean be optional ( ) { return optional ; }
public void set ( int value ) { this . value = value ; }
public string get identifier ( ) { return identifier ; }
public void set property ( string property ) { this . property = property ; }
public setting get setting ( ) { return this . setting ; }
public class < ? > get type ( ) { return i type ; }
public resource chain registration add transformer ( resource transformer transformer ) { assert . not null ( transformer , `` the provided resource transformer should not be null `` ) ; this . transformer . add ( transformer ) ; if ( transformer instanceof cs link resource transformer ) { this . have css link transformer = true ; } return this ; }
public void set mode ( final string mode ) { this . mode = string . to lower case ( mode ) ; if ( mode == null || ! mode . contains ( mode ) ) { throw new illegal argument exception ( `` invalid mode [ `` + mode + `` ] `` ) ; } }
public void clear current property ( ) { if ( current property ! = null ) { current property . remove ( ) ; } }
public string get property value ( string property name ) { return get property ( ) . get ( property name ) ; }
public void set property ( string property ) { this . property = property ; }
public void add u r l ( url url ) { super . add u r l ( url ) ; }
public void set converter ( set < ? > converter ) { this . converter = converter ; }
public void set class name ( string class name ) { reader class name = class name ; }
public synchronize boolean be connect ( ) { return connect ; }
public string get persister ( ) { return persister ; }
public list < operation > static operation ( ) { return static operation ; }
public boolean equal ( object obj ) { if ( obj instanceof event ) { return to string ( ) . equal ( obj . to string ( ) ) ; } else { return false ; } }
public void set ignore case ( final boolean b ) { ignore case = b ; }
public sort set selector . type get selector ( ) { return selector ; }
public example set property selector ( property selector selector ) { this . selector = selector ; return this ; }
public void set sql type ( string value ) { this . sql type = value ; }
public int get column count ( criteria criterion , criterion query criterion query ) { final type [ ] type = get type ( criterion , criterion query ) ; int count = 0 ; for ( type type : type ) { count += type . get column span ( criteria query . get factory ( ) ) ; } return count ; }
public property expression eq property ( property other ) { return restriction . eq property ( get property name ( ) , other . get property name ( ) ) ; }
public static criterion sql ( string sql , object value , type type ) { return new s q l criterion ( sql , value , type ) ; }
public projection get projection ( int i ) { return element . get ( i ) ; }
public projection list add ( projection projection ) { element . add ( projection ) ; return this ; }
public string get property value ( string property name ) { return get property ( ) . get ( property name ) ; }
public string get sql type ( ) { return sql type ; }
public void reset min max ( ) { min max . reset ( ) ; }
public void close ( ) throw i o exception { if ( in ! = null & & in ! = system . in ) { in . close ( ) ; } }
public property expression ne property ( property other ) { return restriction . ne property ( get property name ( ) , other . get property name ( ) ) ; }
public property expression le property ( property other ) { return restriction . le property ( get property name ( ) , other . get property name ( ) ) ; }
public static property expression eq property ( string property name , string other property name ) { return new property expression ( property name , other property name , `` = `` ) ; }
public static property expression eq property ( string property name , string other property name ) { return new property expression ( property name , other property name , `` = `` ) ; }
public static property expression eq property ( string property name , string other property name ) { return new property expression ( property name , other property name , `` = `` ) ; }
public projection list add ( projection projection ) { element . add ( projection ) ; return this ; }
public void set property order ( string [ ] property order ) { this . property order = property order ; }
public static property expression eq property ( string property name , string other property name ) { return new property expression ( property name , other property name , `` = `` ) ; }
public static property expression lt property ( string property name , string other property name ) { return new property expression ( property name , other property name , `` < `` ) ; }
public static property expression eq property ( string property name , string other property name ) { return new property expression ( property name , other property name , `` = `` ) ; }
public string to sql string ( criteria criterion , criterion query criterion query ) { final string [ ] column = criterion query . get columns use projection ( criterion , property name ) ; final type type = criterion query . get type use projection ( criterion , property name ) ; final session factory implementor factory = criterion query . get factory ( ) ; final int [ ] sql type = type . sql type ( factory ) ; final string builder fragment = new string builder ( ) ; for ( int i=0 ; i < column . length ; i++ ) { final string builder expression = new string builder ( ) ; boolean low = false ; if ( ignore case ) { final int sql type = sql type [ i ] ; low = sql type == type . varchar || sql type == type . char || sql type == type . longvarchar ; } if ( low ) { expression . append ( factory . get dialect ( ) . get lowercase function ( ) ) . append ( ' ( ' ) ; } expression . append ( columns [ i ] ) ; if ( low ) { expression . append ( ' ) ' ) ; } fragment . append ( factory . get dialect ( ) . render order by element ( expression . to string ( ) , null , ascend ? `` asc `` : `` desc `` , null precedence ! = null ? null precedence : factory . get setting ( ) . get default null precedence ( ) ) ) ; if ( i < column . length-1 ) { fragment . append ( `` , `` ) ; } } return fragment . to string ( ) ; }
public static criterion property le ( string property name , detach criterion dc ) { return new property subquery expression ( property name , `` < = `` , null , dc ) ; }
public static criterion property le ( string property name , detach criterion dc ) { return new property subquery expression ( property name , `` < = `` , null , dc ) ; }
public static criterion property lt all ( string property name , detach criterion dc ) { return new property subquery expression ( property name , `` < `` , `` all `` , dc ) ; }
public boolean mark support ( ) { return false ; }
public boolean be function ( ) { return this . function ; }
public comparison get comparison ( ) { return comparison ; }
public jaxb hbm natural id type get natural id ( ) { return natural id ; }
protect void do write remote invocation ( remote invocation invocation , object output stream oos ) throw i o exception { oos . write object ( invocation ) ; }
public object get fetch value ( ) { return fetch value ; }
public string get sql ( ) { return this . sql ; }
public final void set parameter ( final parameter [ ] parameter ) { this . parameter = parameter ; set initialize ( false ) ; }
public void set owner ( storage owner owner ) { this . owner = owner ; }
public string get alias ( ) { return alias ; }
public list < action > get action ( ) { return new array list < action > ( ) ; }
public i transaction get transaction ( ) { return this . transaction ; }
public void add subselect ( entity key key , subselect fetch subquery ) { subselects by entity key . put ( key , subquery ) ; }
protect boolean be inverse collection no orphan delete ( ) { final collection entry ce = session . get persistence context internal ( ) . get collection entry ( this ) ; if ( ce == null ) { return false ; } final collection persister load persister = ce . get loaded persister ( ) ; return load persister . be inverse ( ) & & ! loaded persister . have orphan delete ( ) ; }
public collection get orphan ( string entity name , persistent collection collection ) throw hibernate exception { if ( snapshot == null ) { throw new assertion failure ( `` no collection snapshot for orphan delete `` ) ; } return collection . get orphan ( snapshot , entity name ) ; }
public collection get orphan ( ) { ensure analyze ( ) ; collection orphan = new hash set ( revision . key set ( ) ) ; orphan . remove all ( dependers . key set ( ) ) ; return orphan ; }
public object get state ( ) { return state ; }
public void set proxy ( web proxy proxy ) { this . proxy = proxy ; }
public boolean [ ] element ( ) { return a ; }
public static ast insert sibling ( ast node , ast prev sibling ) { node . set next sibling ( prev sibling . get next sibling ( ) ) ; prev sibling . set next sibling ( node ) ; return node ; }
public static ast create sibling ( a s t factory ast factory , int type , string text , ast prev sibling ) { ast node = ast factory . create ( type , text ) ; return insert sibling ( node , prev sibling ) ; }
public void add role name ( string role name ) { if ( role names == null ) { role name = new . array list ( ) ; } role name . add ( role name ) ; }
public string find role mapping ( string role ) { string real role = null ; synchronize ( role mapping ) { real role = role mapping . get ( role ) ; } if ( real role ! = null ) return real role ; else return role ; }
public static string initial ( string str ) { return initial ( str , null ) ; }
public int [ ] get value ( ) { int [ ] result = new int [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get value ( i ) ; } return result ; }
public void set value ( object value ) { this . value = value ; }
public coordinate [ ] get intersection segment ( ) { return int segment ; }
public string get value ( ) { return value ; }
public static boolean be final ( class < ? > clazz ) { return modifier . be final ( clazz . get modifier ( ) ) ; }
public collection < metadata > get metadata ( ) { return metadata ; }
public metadata implementor get metadata ( ) { return metadata ; }
protect final element generate simple element ( final string name , final string value ) { final element element = new element ( name , get d c namespace ( ) ) ; element . add content ( value ) ; return element ; }
public void set owner ( storage owner owner ) { this . owner = owner ; }
public boolean be join outer ( ) { return join outer ; }
protect void pre instantiate ( object name , map attribute , object value ) { for ( closure pre instantiate delegate : get proxy builder ( ) . get pre instantiate delegate ( ) ) { ( pre instantiate delegate ) . call ( this , attribute , value ) ; } }
public boolean be fragment ( ) { return fragment ; }
public select set from clause ( string from clause ) { this . from clause = from clause ; this . guesstimate buffer size += from clause . length ( ) ; return this ; }
public string get comment ( ) { return this . comment ; } // -- string get comment ( )
public select set lock mode ( lock mode lock mode ) { lock option . set lock mode ( lock mode ) ; return this ; }
public string get property ( ) { return property ; }
public string get identifier ( ) { return identifier ; }
public void set session ( session session ) { this . session = session ; }
public t get ( ) { return t ; }
public final t get value ( ) { return value ; }
public string get comment ( ) { return comment ; }
public boolean have theta join ( ) { return have theta join ; }
public void add fragment ( join fragment ojf ) { if ( ojf . have theta join ( ) ) { have theta join = true ; } add join ( ojf . to from fragment string ( ) , ojf . to where fragment string ( ) ) ; }
public boolean be quote ( ) { return be quote ; }
public i variable bind [ ] get possible target ( ) { assert . be not null ( f possible target ) ; return f possible target ; }
public void append from clause fragment ( string fragment ) { if ( this . from clause . length ( ) > 0 ) { this . from clause . append ( `` , `` ) ; this . guesstimate buffer size += 2 ; } this . from clause . append ( fragment ) ; this . guesstimate buffer size += fragment . length ( ) ; }
public select set from clause ( string from clause ) { this . from clause = from clause ; this . guesstimate buffer size += from clause . length ( ) ; return this ; }
public lock mode find great lock mode ( ) { lock mode lock mode to use = get lock mode ( ) ; if ( lock mode to use == null ) { lock mode to use = lock mode . none ; } if ( alias specific lock mode == null ) { return lock mode to use ; } for ( lock mode lock mode : alias specific lock mode . value ( ) ) { if ( lock mode . great than ( lock mode to use ) ) { lock mode to use = lock mode ; } } return lock mode to use ; }
public long get block cache hit ( ) { return stats . block cache hit ; }
public string get filename ( ) { string filename = get file unicode ( ) ; if ( filename == null ) { filename = get file do ( ) ; } if ( filename == null ) { filename = get file mac ( ) ; } if ( filename == null ) { filename = get file unix ( ) ; } if ( filename == null ) { filename = get file ( ) ; } return filename ; }
public class < ? > get value class ( ) { return object . class ; }
public type get type ( ) { return type ; }
public type get type ( ) { return type ; }
public string get entity ( ) { return entity ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public void set parent class scope ( class < ? extend annotation > parent class scope ) { this . parent class scope = parent class scope ; }
public string to string ( ) { string builder result = new string builder ( ) ; if ( be flag set ( ticket flag . reserve ) ) { result . append ( `` reserve ( 0 ) `` ) ; } if ( be flag set ( ticket flag . forwardable ) ) { result . append ( `` forwardable ( 1 ) `` ) ; } if ( be flag set ( ticket flag . forward ) ) { result . append ( `` forward ( 2 ) `` ) ; } if ( be flag set ( ticket flag . proxiable ) ) { result . append ( `` proxiable ( 3 ) `` ) ; } if ( be flag set ( ticket flag . proxy ) ) { result . append ( `` proxy ( 4 ) `` ) ; } if ( be flag set ( ticket flag . may_postdate ) ) { result . append ( `` may_postdate ( 5 ) `` ) ; } if ( be flag set ( ticket flag . postdate ) ) { result . append ( `` postdate ( 6 ) `` ) ; } if ( be flag set ( ticket flag . invalid ) ) { result . append ( `` invalid ( 7 ) `` ) ; } if ( be flag set ( ticket flag . renewable ) ) { result . append ( `` renewable ( 8 ) `` ) ; } if ( be flag set ( ticket flag . initial ) ) { result . append ( `` initial ( 9 ) `` ) ; } if ( be flag set ( ticket flag . pre_authent ) ) { result . append ( `` pre_authent ( 10 ) `` ) ; } if ( be flag set ( ticket flag . hw_authent ) ) { result . append ( `` hw_authent ( 11 ) `` ) ; } if ( be flag set ( ticket flag . transited_policy_checked ) ) { result . append ( `` transited_policy_checked ( 12 ) `` ) ; } if ( be flag set ( ticket flag . ok_as_delegate ) ) { result . append ( `` ok_as_delegate ( 13 ) `` ) ; } return result . to string ( ) . trim ( ) ; }
public boolean be optional ( ) { return optional ; }
public static list < system injectee impl > get constructor injectees ( constructor < ? > c , active descriptor < ? > injectee descriptor ) { type generic type params [ ] = c . get generic parameter type ( ) ; annotation param annotation [ ] [ ] = c . get parameter annotation ( ) ; list < system injectee impl > ret val = new link list < system injectee impl > ( ) ; for ( int lcv = 0 ; lcv < generic type params . length ; lcv++ ) { annotation information ai = get param information ( param annotation [ lcv ] ) ; ret val . add ( new system injectee impl ( generic type params [ lcv ] , ai . qualifier , lcv , c , ai . optional , ai . self , ai . unqualified , injectee descriptor ) ) ; } return ret val ; }
public service descriptor get service descriptor ( ) { return service descriptor ; }
public void set filter ( tree filter filter ) { this . filter = filter ; }
public list < server service definition > get service ( ) { return service ; }
public void set document locator ( locator locator ) { if ( sax log . be debug enable ( ) ) { sax log . debug ( `` set document locator ( `` + locator + `` ) `` ) ; } this . locator = locator ; }
public output < string > handle ( ) { return handle ; }
public static method get pre destroy ( class < ? > impl class , class analyzer analyzer , collector collector ) { try { return analyzer . get pre destroy method ( impl class ) ; } catch ( multi exception me ) { collector . add multi exception ( me ) ; return null ; } catch ( throwable th ) { collector . add throwable ( th ) ; return null ; } }
public static < t > constructor < t > get constructor ( class < t > impl class , class analyzer analyzer , collector collector ) { constructor < t > element = null ; try { element = analyzer . get constructor ( impl class ) ; } catch ( multi exception me ) { collector . add multi exception ( me ) ; return element ; } catch ( throwable th ) { collector . add throwable ( th ) ; return element ; } if ( element == null ) { collector . add throwable ( new assertion error ( `` null return from get constructor method of analyzer `` + analyzer + `` for class `` + impl class . get name ( ) ) ) ; return element ; } final constructor < t > result = element ; access controller . do privilege ( new privilege action < object > ( ) { @ override public object run ( ) { result . set accessible ( true ) ; return null ; } } ) ; return element ; }
public list < format error > get error ( ) { return error ; }
public dependency resolver get resolver ( ) { return resolver ; }
public collector result get collector ( ) { return collector . get collector tree ( ) ; }
public void set injectee class ( final class < ? > injectee class ) { this . injectee class = injectee class ; }
public void print stack trace ( ) { super . print stack trace ( ) ; }
public void set cache size ( int cache size ) { this . cache size = cache size ; }
public void remove all listener ( ) { list . clear ( ) ; }
public type get type ( ) { return type ; }
public class < t > get type ( ) { return type ; }
public int size ( ) { return size ; }
public void set proxy ( web proxy proxy ) { this . proxy = proxy ; }
public http request [ ] retrieve record request ( http request http request ) { string record request = retrieve record request ( http request , format . json ) ; if ( string utils . be not empty ( recorded request ) & & ! record request . equal ( `` [ ] `` ) ) { return http request serializer . deserialize array ( record request ) ; } else { return new http request [ 0 ] ; } }
public static < t > consumer < t > consumer ( unchecked consumer < t > consumer ) { return consumer . to consumer ( ) ; }
public http request wrapper build unconditional request ( final http request wrapper request , final http cache entry entry ) { final http request wrapper new request = http request wrapper . wrap ( request . get original ( ) ) ; new request . set header ( request . get all header ( ) ) ; new request . add header ( header constant . cache_control , header constant . cache_control_no_cache ) ; new request . add header ( header constant . pragma , header constant . cache_control_no_cache ) ; new request . remove header ( header constant . if_range ) ; new request . remove header ( header constant . if_match ) ; new request . remove header ( header constant . if_none_match ) ; new request . remove header ( header constant . if_unmodified_since ) ; new request . remove header ( header constant . if_modified_since ) ; return new request ; }
public connection socket factory get ssl socket factory ( ) { return ssl socket factory ; }
public final int hash code ( ) { int hash = lang utils . hash_seed ; hash = lang utils . hash code ( hash , this . target host ) ; hash = lang utils . hash code ( hash , this . local address ) ; if ( this . proxy chain ! = null ) { for ( int i = 0 ; i < this . proxy chain . length ; i++ ) { hash = lang utils . hash code ( hash , this . proxy chain [ i ] ) ; } } hash = lang utils . hash code ( hash , this . connect ) ; hash = lang utils . hash code ( hash , this . secure ) ; hash = lang utils . hash code ( hash , this . tunnel ) ; hash = lang utils . hash code ( hash , this . layer ) ; return hash ; }
public final int hash code ( ) { int hash = lang utils . hash_seed ; hash = lang utils . hash code ( hash , this . target host ) ; hash = lang utils . hash code ( hash , this . local address ) ; for ( int i = 0 ; i < this . proxy chain . length ; i++ ) { hash = lang utils . hash code ( hash , this . proxy chain [ i ] ) ; } hash = lang utils . hash code ( hash , this . secure ) ; hash = lang utils . hash code ( hash , this . tunnel ) ; hash = lang utils . hash code ( hash , this . layer ) ; return hash ; }
public string get auth type ( ) { return this . auth type ; }
public j var [ ] list params ( ) { return params . to array ( new j var [ params . size ( ) ] ) ; }
public void remove ( ) { throw new unsupported operation exception ( ) ; }
public state get state ( ) { return state . get ( ) . get state ( ) ; }
public object get state ( ) { return state ; }
public void set wait thread ( wait thread wait thread ) { this . wait thread = wait thread ; if ( abort ) wait thread . interrupt ( ) ; }
public void abort ( ) { aborted = true ; if ( wait thread ! = null ) wait thread . interrupt ( ) ; }
public cookie get ( string cookie name ) { assert parameter . not null ( cookie name , `` cookie name `` ) ; return cooky . get ( cookie name ) ; }
public result matcher version ( string name , int version ) { return result - > { cookie cookie = get cookie ( result , name ) ; assert equal ( `` response cookie ' `` + name + `` ' version `` , version , cookie . get version ( ) ) ; } ; }
public void release ( ) { }
public void set http client ( http client http client ) { this . http client = http client ; }
public ct query impl add input ( object . . . input ) { if ( this . input == null ) { this . input = new array list < > ( ) ; } if ( input ! = null ) { collection . add all ( this . input , input ) ; } return this ; }
public void set parameter ( string name , string . . . value ) { assert . not null ( name , `` parameter name must not be null `` ) ; this . parameter . put ( name , value ) ; }
public boolean be enable ( ) { return this . enable ; }
public synchronize void set http connection factory timeout ( long timeout ) { this . params . set connection manager timeout ( timeout ) ; }
public final t get entity ( ) { return entity ; }
public synchronize boolean be s s l ( ) { return use s s l ; }
public static int [ ] remove all occurences ( final int [ ] array , final int element ) { return ( int [ ] ) remove all ( ( object ) array , index of ( array , element ) ) ; }
protect void validate ( ) throw exception { this . get service ( ) . validate ( ) ; }
public void close ( ) throw i o exception { if ( ! this . close ) { in . close ( ) ; this . close = true ; } }
public string get header name ( ) { return this . header name ; }
public void set interceptor ( object [ ] interceptor ) { this . interceptor = interceptor ; }
public pattern get pattern ( ) { return pattern ; }
public static byte [ ] buffer to array ( byte buffer buffer ) { if ( buffer . have array ( ) & & buffer . array offset ( ) == 0 & & buffer . array ( ) . length == buffer . remain ( ) ) { return buffer . array ( ) ; } else { byte [ ] bytes = new byte [ buffer . remain ( ) ] ; buffer . get ( byte ) ; return byte ; } }
public void option ( string path , route route ) { add route ( http method . option . name ( ) , route impl . create ( path , route ) ) ; }
public void close expire ( ) { long now = system . current time millis ( ) ; this . lock . lock ( ) ; try { iterator < e > it = this . available . iterator ( ) ; while ( it . have next ( ) ) { e entry = it . next ( ) ; if ( entry . be expire ( now ) ) { entry . close ( ) ; route specific pool < t , c , e > pool = get pool ( entry . get route ( ) ) ; pool . remove ( entry ) ; it . remove ( ) ; notify pending ( pool ) ; } } } finally { this . lock . unlock ( ) ; } }
public void close idle ( long idletime , final time unit tunit ) { if ( tunit == null ) { throw new illegal argument exception ( `` time unit must not be null . `` ) ; } long time = tunit . to millis ( idletime ) ; if ( time < 0 ) { time = 0 ; } long deadline = system . current time millis ( ) - time ; this . lock . lock ( ) ; try { iterator < e > it = this . available . iterator ( ) ; while ( it . have next ( ) ) { e entry = it . next ( ) ; if ( entry . get updated ( ) < = deadline ) { entry . close ( ) ; route specific pool < t , c , e > pool = get pool ( entry . get route ( ) ) ; pool . remove ( entry ) ; it . remove ( ) ; notify pending ( pool ) ; } } } finally { this . lock . unlock ( ) ; } }
public line string get line ( ) { return line ; }
public connection cursor cursor for object in connection ( t object ) { int index = data . index of ( object ) ; if ( index == -1 ) { return null ; } string cursor = create cursor ( index ) ; return new default connection cursor ( cursor ) ; }
public string get protocol ( ) { return protocol ; }
public resteasy client builder impl disable trust manager ( ) { this . disable trust manager = true ; return this ; }
public boolean be complete ( ) { return complete ; }
protect int write to buffer ( final byte buffer src , final int limit ) throw i o exception { return do write chunk ( src , limit , false ) ; }
protect int write to channel ( final byte buffer src , final int limit ) throw i o exception { return do write chunk ( src , limit , true ) ; }
public void set session ( session session ) { this . session = session ; }
public void log ( final log event event ) { log ( event , logger config predicate . all ) ; }
public @ nullable response < ? > response ( ) { return response ; }
public void add mapper ( mapper mapper ) { if ( this . mapper ! = null ) { throw new build exception ( `` can not define more than one mapper `` ) ; } this . mapper = mapper ; }
public void set mode ( string mode ) { this . mode = mode ; }
public long capacity ( ) { return capacity . get ( ) ; }
public type get type ( ) { return type ; }
public final void set parameter ( final parameter [ ] parameter ) { this . parameter = parameter ; set initialize ( false ) ; }
public string get field name ( ) { return field name ; }
public void close ( ) throw i o exception { input . close ( ) ; }
public void parse ( byte [ ] buf , int ptr , int end ) { while ( ptr < end ) ptr = parse file ( buf , ptr , end ) ; }
public string get encode ( ) { return input encode ; }
public string get match format name ( ) { return have match ( ) ? get match ( ) . get format name ( ) : null ; }
public data format detector with minimal match ( match strength min match ) { if ( min match == _minimal match ) { return this ; } return new data format detector ( _detectors , _optimal match , min match , _max input lookahead ) ; }
public void release read i o buffer ( byte [ ] buf ) { if ( buf ! = null ) { / * let 's do sanity check to ensure once-and-only-once release , * as well a avoid try to release buffer not own * / _verify release ( buf , _read i o buffer ) ; _read i o buffer = null ; _buffer recycler . release byte buffer ( buffer recycler . byte_read_io_buffer , buf ) ; } }
public byte buffer get byte buffer ( ) throw i o exception { byte buf byte buf = file upload . get byte buf ( ) ; if ( byte buf == null ) { throw new i o exception ( `` the byte buffer have already be release `` ) ; } try { return byte buf . nio buffer ( ) ; } finally { if ( control release ) { byte buf . release ( ) ; } } }
public static byte [ ] compress string ( string value , int compression level ) { bytes ref result = new byte ref ( ) ; unicode util . u t f16to u t f8 ( value , 0 , value . length ( ) , result ) ; return compress ( result . byte , 0 , result . length , compression level ) ; }
public boolean be order ( ) { return false ; }
public static void set default ( codec codec ) { default codec = codec ; }
public final boolean be enable ( stream write feature f ) { return ( _generator feature & f . map feature ( ) . get mask ( ) ) ! = 0 ; }
public static void register parser ( string content type , parser parser ) { response_parser_registrar . register parser ( content type , parser ) ; }
public json generator get generator ( ) { return null ; }
public json factory builder high non escape char ( int max non escape ) { _maximum non escape char = ( max non escape < = 0 ) ? 0 : math . max ( 127 , max non escape ) ; return this ; }
public void set escape char ( char escape char ) { this . escape char = escape char ; }
public string get ref ( ) { return ref ; }
public boolean contains ( any object id id ) throw i o exception { return get ( id ) ! = null ; }
public struct validator new instance ( ) { return this ; }
public int collision count ( ) { int count = 0 ; for ( bucket bucket : _buckets ) { if ( bucket ! = null ) { count += bucket . length ; } } return count ; }
public object get ( char sequence key ) { final int bucket = normal completion . get bucket ( key ) ; return bucket == -1 ? null : long . value of ( bucket ) ; }
public void flush ( ) throw i o exception { super . flush ( ) ; this . branch . flush ( ) ; }
public int get int value ( ) { return 0 ; }
public void set manager ( string manager ) { this . manager = manager ; }
public final base64 variant get base64 variant ( ) { return _config . get base64 variant ( ) ; }
public final boolean be enable ( mapper feature f ) { return ( _mapper feature & f . get mask ( ) ) ! = 0 ; }
public string current task name ( ) { return this . current task name ; }
public static boolean be scalar ( graph q l type type ) { return type instanceof graph q l scalar type ; }
public static void append string value ( tiny tree tree , int node nr , fast string buffer buffer ) { long value = ( ( long ) tree . alpha [ node nr ] < < 32 ) | ( ( long ) tree . beta [ node nr ] & 0xffffffff l ) ; compress whitespace . uncompress ( value , buffer ) ; }
public string to string ( ) { return new string buffer ( ) . append ( `` [ entity ref : `` ) . append ( `` & `` ) . append ( name ) . append ( `` ; `` ) . append ( `` ] `` ) . to string ( ) ; }
public final byte [ ] get raw gpg signature ( ) { final byte [ ] raw = buffer ; final byte [ ] header = { ' g ' , ' p ' , ' g ' , 's ' , ' i ' , ' g ' } ; final int start = raw parse utils . header start ( header , raw , 0 ) ; if ( start < 0 ) { return null ; } final int end = raw parse utils . header end ( raw , start ) ; return array . copy of range ( raw , start , end ) ; }
public static string filter token ( final char sequence s , final int start , final int end ) { return filter token ( s , start , end , false ) ; }
public member get member ( ) { return this . executable ; }
public boolean be type id ( annotated member member ) { return null ; }
public tag command set annotate ( boolean annotate ) { this . annotate = annotate ; return this ; }
public final boolean be enable ( stream write feature f ) { return ( _generator feature & f . map feature ( ) . get mask ( ) ) ! = 0 ; }
public string get attribute ( string key ) { return get table value ( attribute , key ) ; }
public property create property ( ) { final property prop = new property ( ) ; property list . add element ( prop ) ; return prop ; }
public meta method get setter ( ) { return setter ; }
public void clear ( ) { synchronize ( cache ) { cache . clear ( ) ; } }
public int size ( ) { return size ; }
public static void set default ( credential provider p ) { default provider = p ; }
public boolean equal ( object ob ) { if ( ob == this ) return true ; if ( ! ( ob instanceof virtual machine ) ) return false ; virtual machine other = ( virtual machine ) ob ; if ( other . provider ( ) ! = this . provider ( ) ) { return false ; } if ( ! other . id ( ) . equal ( this . id ( ) ) ) { return false ; } return true ; }
public deserialization config get deserialization config ( ) { return _deserialization config ; }
public deserialization config get deserialization config ( ) { return _deserialization config ; }
public class < ? > get exception class ( ) { return this . exception class ; }
public boolean can create from boolean ( ) { return false ; }
public boolean can create from double ( ) { return false ; }
public boolean can create from boolean ( ) { return false ; }
public static base64 variant get default variant ( ) { return mime ; }
public node get node ( ) { return node ; }
protect builder create builder ( ) { final builder builder = get builder ( ) ; return builder ! = null ? builder : new builder ( ) ; }
public static void set reflect ( config conf , class < ? extend kryo instantiator > inst class ) { conf . set ( key , inst class . get name ( ) ) ; }
public string get property ( ) { return property ; }
public int get count ( ) { return message . size ( ) ; }
public type resolver builder < ? > find property type resolver ( mapper config < ? > config , annotated member be , java type base type ) { return null ; }
public void set mix ( boolean mix ) { action . set boolean ( c o s name . mix , mix ) ; }
public string get string value ( ) { return _as string ; }
public deserializer bind get deserializer binding ( ) { return deserializer binding ; }
public json deserializer < t > unwrapping deserializer ( name transformer unwrapper ) { return this ; }
public void set filter ( tree filter filter ) { this . filter = filter ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public static type descriptor value of ( class < ? > type ) { if ( type == null ) { type = object . class ; } type descriptor desc = common type cache . get ( type ) ; return ( desc ! = null ? desc : new type descriptor ( resolvable type . for class ( type ) , null , null ) ) ; }
public void set abstract ( boolean value ) { this . _abstract = value ; }
public void set node ( simple node value ) { node = value ; }
public void remove ( int index ) { entry . remove ( index ) ; }
public boolean add token ( token < ? extend token identifier > token ) { return ( token ! = null ) ? add token ( token . get service ( ) , token ) : false ; }
public node get node ( ) { return node ; }
public node get node ( ) { return node ; }
public byte [ ] get binary data ( ) throw property exception { this . validate property access ( user configuration property . binary data ) ; return this . binary data ; }
public numeric node number node ( int v ) { return int node . value of ( v ) ; }
public void fix access ( deserialization config config ) { ; }
public object writer with root name ( string root name ) { return _new ( this , _config . with root name ( root name ) ) ; }
public object writer with view ( class < ? > view ) { return _new ( this , _config . with view ( view ) ) ; }
public reader reader value ( ) { return field data instanceof reader ? ( reader ) field data : null ; }
public object reader with root name ( string root name ) { return _with ( _config . with root name ( root name ) ) ; }
public object reader with view ( class < ? > active view ) { return _with ( _config . with view ( active view ) ) ; }
public void set cache size ( int cache size ) { this . cache size = cache size ; }
public print writer get writer ( ) throw i o exception { return this . response . get writer ( ) ; }
public void set table generator ( jaxb table generator value ) { this . table generator = value ; }
public static string collection extractor get instance ( class < ? > collection type , string parameter name , string default value ) { if ( list . class == collection type ) { return new list string ( parameter name , default value ) ; } else if ( set . class == collection type ) { return new set string ( parameter name , default value ) ; } else if ( sort set . class == collection type ) { return new sort set string ( parameter name , default value ) ; } else { throw new runtime exception ( `` unsupported collection type : `` + collection type . get name ( ) ) ; } }
public class < ? > get value class ( ) { return object . class ; }
public java . util . list < com . google . protobuf . enum > get enums list ( ) { return enums_ ; }
protect object resolve specify lookup key ( object lookup key ) { return lookup key ; }
public boolean can create from boolean ( ) { return false ; }
public string get field name ( ) { return field name ; }
public string [ ] index ( ) { return index ; }
public static reference token from raw ( final string raw ) { bundle . check not null ( raw , `` null input `` ) ; return new reference token ( a cook ( raw ) , raw ) ; }
public date time zone get time zone ( ) { return this . time zone ; }
public static synchronize void set default ( default default ) { default = default ; }
public int hash code ( ) { return to string ( ) . hash code ( ) ; }
public node pop node ( ) { if ( -- sp < mk ) { mk = ( ( integer ) mark . remove ( mark . size ( ) -1 ) ) . int value ( ) ; } return ( node ) node . remove ( node . size ( ) -1 ) ; }
public void display ( ) { int iterator iter = new int hash map key iterator ( ) ; while ( iter . have next ( ) ) { int key = iter . next ( ) ; object value = get ( key ) ; system . err . println ( key + `` - > `` + value . to string ( ) ) ; } }
public object get value ( e l context context , object base , object property ) { if ( context == null ) { throw new null pointer exception ( ) ; } if ( base == null || property == null ) { return null ; } method method = get bean property ( context , base , property ) . get read method ( ) ; if ( method == null ) { throw new property not find exception ( get exception message string ( context , `` property not readable `` , new object [ ] { base . get class ( ) . get name ( ) , property . to string ( ) } ) ) ; } object value ; try { value = method . invoke ( base , new object [ 0 ] ) ; context . set property resolve ( base , property ) ; } catch ( e l exception ex ) { throw ex ; } catch ( invocation target exception ite ) { throw new e l exception ( ite . get cause ( ) ) ; } catch ( exception ex ) { throw new e l exception ( ex ) ; } return value ; }
public object get value ( e l context context , object base , object property ) { if ( context == null ) { throw new null pointer exception ( ) ; } if ( base == null & & property instanceof string ) { if ( bean name resolver . be name resolve ( ( string ) property ) ) { context . set property resolve ( base , property ) ; return bean name resolver . get bean ( ( string ) property ) ; } } return null ; }
public boolean be read only ( e l context context , object base , object property ) { if ( context == null ) { throw new null pointer exception ( ) ; } if ( base == null & & property instanceof string ) { if ( bean name resolver . be name resolve ( ( string ) property ) ) { context . set property resolve ( true ) ; return bean name resolver . be read only ( ( string ) property ) ; } } return false ; }
public object get value ( e l context context , object base , object property ) { if ( context == null ) { throw new null pointer exception ( ) ; } if ( base == null & & property instanceof string ) { if ( bean name resolver . be name resolve ( ( string ) property ) ) { context . set property resolve ( base , property ) ; return bean name resolver . get bean ( ( string ) property ) ; } } return null ; }
public void set read only ( boolean read only ) { set ( efs . attribute_read_only , read only ) ; }
public e l resolver get e l resolver ( ) { if ( el resolver == null ) { composite e l resolver resolver = new composite e l resolver ( ) ; custom resolvers = new composite e l resolver ( ) ; resolver . add ( custom resolvers ) ; resolver . add ( new bean name e l resolver ( new local bean name resolver ( ) ) ) ; if ( stream e l resolver ! = null ) { resolver . add ( stream e l resolver ) ; } resolver . add ( new static field e l resolver ( ) ) ; resolver . add ( new map e l resolver ( ) ) ; resolver . add ( new resource bundle e l resolver ( ) ) ; resolver . add ( new list e l resolver ( ) ) ; resolver . add ( new array e l resolver ( ) ) ; resolver . add ( new bean e l resolver ( ) ) ; el resolver = resolver ; } return el resolver ; }
public e l resolver get e l resolver ( ) { if ( el resolver == null ) { composite e l resolver resolver = new composite e l resolver ( ) ; custom resolvers = new composite e l resolver ( ) ; resolver . add ( custom resolvers ) ; resolver . add ( new bean name e l resolver ( new local bean name resolver ( ) ) ) ; if ( stream e l resolver ! = null ) { resolver . add ( stream e l resolver ) ; } resolver . add ( new static field e l resolver ( ) ) ; resolver . add ( new map e l resolver ( ) ) ; resolver . add ( new resource bundle e l resolver ( ) ) ; resolver . add ( new list e l resolver ( ) ) ; resolver . add ( new array e l resolver ( ) ) ; resolver . add ( new bean e l resolver ( ) ) ; el resolver = resolver ; } return el resolver ; }
public string get name ( ) { return name ; }
public dependency resolver get resolver ( ) { return resolver ; }
public string get descriptor ( ) { return descriptor ; }
public < t > void serialize root ( t root , json generator generator ) { if ( root == null ) { get jsonb context ( ) . get config property ( ) . get null serializer ( ) . serialize ( null , generator , this ) ; return ; } final jsonb serializer < t > root serializer = ( jsonb serializer < t > ) get root serializer ( root . get class ( ) ) ; if ( get jsonb context ( ) . get config property ( ) . be strict i json ( ) & & root serializer instanceof abstract value type serializer ) { throw new jsonb exception ( message . get message ( message key . ijson_enabled_single_value ) ) ; } root serializer . serialize ( root , generator , this ) ; }
public static file current persistence file ( ) { return persistence file . get ( ) . get first ( ) ; }
public string get private key ( ) { return this . private key ; } // -- string get private key ( )
public int hash code ( ) { int hash = super . hash code ( ) ; hash = 59 * hash + ( this . comment ! = null ? this . comment . hash code ( ) : 0 ) ; hash = 59 * hash + this . max age ; hash = 59 + hash + ( this . expiry ! = null ? this . expiry . hash code ( ) : 0 ) ; hash = 59 * hash + ( this . secure ? 1 : 0 ) ; hash = 59 * hash + ( this . http only ? 1 : 0 ) ; return hash ; }
public string get entity ( ) { return entity ; }
public string get uri ( ) { return uri ; }
public static uri builder from path ( string path ) throw illegal argument exception { return new instance ( ) . path ( path ) ; }
public int hash code ( ) { int hash = 3 ; hash = 17 * hash + ( this . value ! = null ? this . value . hash code ( ) : 0 ) ; hash = 17 * hash + ( this . weak ? 1 : 0 ) ; return hash ; }
protect http status get response status ( ) { return this . response status ; }
public static response builder accept ( object entity ) { return accept ( ) . entity ( entity ) ; }
public string get entity ( ) { return entity ; }
public location get location ( ) { return this . location ; }
public static builder from path ( string path ) { return from uri builder ( uri builder . from path ( path ) ) ; }
public locale get language ( ) { return language ; }
public static int parse unsigned short ( string lexical x s d unsigned short ) { if ( the converter == null ) init converter ( ) ; return the converter . parse unsigned short ( lexical x s d unsigned short ) ; }
public static data type get unsigned short data type ( ) { try { return new unsigned short d t ( `` http : //www . w3 . org/2001/ x m l schema # unsigned short `` ) ; } catch ( invalid u r i exception iue ) { return null ; } }
public boolean be validate ( ) { return validating ; }
public class < ? > get declare class ( ) { return method . get declare class ( ) ; }
public void set t ( string value ) { this . t = value ; }
public void print stack trace ( ) { super . print stack trace ( ) ; }
public partial with field ( date time field type field type , int value ) { int index = index of support ( field type ) ; if ( value == get value ( index ) ) { return this ; } int [ ] new value = get value ( ) ; new value = get field ( index ) . set ( this , index , new value , value ) ; return new partial ( this , new value ) ; }
public string to string ( ) { return to string ( `` `` ) ; }
public float a float ( ) { throw new illegal argument exception ( `` not a number `` ) ; }
public long a long ( ) { throw new illegal argument exception ( `` not a number `` ) ; }
public void set class name ( string class name ) { reader class name = class name ; }
public static annotation instance get parameter annotation ( method info method , dot name annotation ) { for ( annotation instance annotation instance : method . annotation ( ) ) { if ( annotation instance . target ( ) . kind ( ) . equal ( kind . method_parameter ) & & annotation instance . name ( ) . equal ( annotation ) ) { return annotation instance ; } } return null ; }
protect boolean match interface ( string interface name ) { return null ; }
public list < e > a list ( ) { return unmodifiable list . unmodifiable list ( set order ) ; }
public string get prefix ( ) { return prefix ; }
public static < t extend comparable < ? super t > > int compare ( t c1 , t c2 ) { return compare ( c1 , c2 , false ) ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public type get return type ( ) { return internal get return type ( ) ; }
public method get method ( ) { return method ; }
protect object sput ( object key , object value , int hash ) { entry [ ] tab = table ; int index = hash & ( tab . length - 1 ) ; entry first = tab [ index ] ; entry e = first ; for ( ; ; ) { if ( e == null ) { entry new entry = new entry ( hash , key , value , first ) ; tab [ index ] = new entry ; if ( ++count > = threshold ) rehash ( ) ; else record modification ( new entry ) ; return null ; } else if ( e . hash == hash & & eq ( key , e . key ) ) { object old value = e . value ; e . value = value ; return old value ; } else e = e . next ; } }
public void set target class ( class < ? > target class ) { this . target class = target class ; }
public static void print statistic ( ) { abstract file system . print statistic ( ) ; }
public void set registry ( registry registry ) { this . registry = registry ; }
public int get arity ( ) { return get formal parameter ( ) . size ( ) ; }
public string get content ( ) { return content ; }
public static optional < class > resolve interface type argument ( class type , class interface type ) { type [ ] generic interface = type . get generic interface ( ) ; for ( type generic interface : generic interface ) { if ( generic interface instanceof parameterized type ) { parameterized type pt = ( parameterized type ) generic interface ; if ( pt . get raw type ( ) == interface type ) { return resolve single type argument ( generic interface ) ; } } } class super class = type . get superclass ( ) ; if ( super class ! = null & & super class ! = object . class ) { return resolve interface type argument ( super class , interface type ) ; } return optional . empty ( ) ; }
public void set ( boolean value ) { this . value = value ; }
public void set inner form resource ( p d resource inner form resource ) { this . inner form resource = inner form resource ; }
public node get parent ( ) { return parent ; }
protect boolean be context require ( ) { return false ; }
protect boolean be context require ( ) { return false ; }
public graph q l directive get schema directive ( string directive name ) { return schema directive . get directive ( directive name ) ; }
public node get node ( ) { return node ; }
public string name ( ) { return name ; }
public void replace token ( java token new token ) { assert not null ( new token ) ; get previous token ( ) . if present ( p - > { p . next token = new token ; new token . previous token = p ; } ) ; get next token ( ) . if present ( n - > { n . previous token = new token ; new token . next token = n ; } ) ; }
public void insert ( java token new token ) { assert not null ( new token ) ; get previous token ( ) . if present ( p - > { p . next token = new token ; new token . previous token = p ; } ) ; previous token = new token ; new token . next token = this ; }
public string get field name ( ) { return field name ; }
public synchronize void clear ( ) { entry tab [ ] = table ; for ( int index = tab . length ; -- index > = 0 ; ) { tab [ index ] = null ; } count = 0 ; }
public static < t > consumer < t > consumer ( unchecked consumer < t > consumer ) { return consumer . to consumer ( ) ; }
public option get option ( ) { return option ; }
public string get indent ( ) { return indent ; }
public parser configuration set tab size ( int tab size ) { this . tab size = tab size ; return this ; }
public void set active line range ( int start line , int end line ) { if ( start line ! =active line range start || end line ! =active line range end ) { active line range start = start line ; active line range end = end line ; repaint ( ) ; } }
public int root ( ) { return root ; }
public void set relative path ( string relative path ) { this . relative path = relative path ; } // -- void set relative path ( string )
public source root add ( compilation unit compilation unit ) { assert not null ( compilation unit ) ; if ( compilation unit . get storage ( ) . be present ( ) ) { final path path = compilation unit . get storage ( ) . get ( ) . get path ( ) ; log . trace ( `` add new file % s `` , ( ) - > path ) ; final parse result < compilation unit > parse result = new parse result < > ( compilation unit , new array list < > ( ) , null ) ; cache . put ( path , parse result ) ; } else { throw new assertion error ( `` file add with this method should have their path set . `` ) ; } return this ; }
public string get callback name ( ) { return callback name ; }
public void compile ( string name , string code ) throw compilation fail exception { compilation unit unit = new compilation unit ( configuration ) ; unit . add source ( new source unit ( name , code , configuration , unit . get class loader ( ) , unit . get error collector ( ) ) ) ; unit . compile ( ) ; }
public node get node ( ) { return node ; }
public t get ( ) { return t ; }
public static array < long > of all ( long [ ] array ) { object . require non null ( array , `` array be null `` ) ; return of all ( iterator . of all ( array ) ) ; }
public static array < float > of all ( float [ ] array ) { object . require non null ( array , `` array be null `` ) ; return of all ( iterator . of all ( array ) ) ; }
public static array < long > of all ( long [ ] array ) { object . require non null ( array , `` array be null `` ) ; return of all ( iterator . of all ( array ) ) ; }
public string text ( ) { string builder sb = new string builder ( ) ; for ( element element : this ) { if ( sb . length ( ) ! = 0 ) sb . append ( `` `` ) ; sb . append ( element . text ( ) ) ; } return sb . to string ( ) ; }
public boolean contains ( final object object ) { return map . contains key ( object ) ; }
public seq < char seq > split ( string regex ) { return split ( regex , 0 ) ; }
public synchronize void close ( ) { if ( char ! = null ) { array . fill ( char , '\0 ' ) ; char = null ; } }
public static tree set < float > of all ( float . . . element ) { object . require non null ( element , `` element be null `` ) ; return tree set . of all ( iterator . of all ( element ) ) ; }
public static array < long > of all ( long [ ] array ) { object . require non null ( array , `` array be null `` ) ; return of all ( iterator . of all ( array ) ) ; }
public static array < long > of all ( long [ ] array ) { object . require non null ( array , `` array be null `` ) ; return of all ( iterator . of all ( array ) ) ; }
public static array < long > of all ( long [ ] array ) { object . require non null ( array , `` array be null `` ) ; return of all ( iterator . of all ( array ) ) ; }
public static < t > observable < t > concat ( observable < ? extend t > t1 , observable < ? extend t > t2 , observable < ? extend t > t3 , observable < ? extend t > t4 ) { return concat ( just ( t1 , t2 , t3 , t4 ) ) ; }
public boolean be private ( ) { return private flag ; }
public stack get stack ( ) { return stack ; }
public ct class get ct class ( ) { return clazz ; }
public type get type ( ) { return type ; }
public ct class get ct class ( ) { if ( resolve ! = null ) return resolve . get ct class ( ) ; return type . object . get ct class ( ) ; }
public member get member ( ) { return this . executable ; }
public static annotation [ ] get filtering annotation ( final annotation [ ] annotation ) { if ( annotation == null || annotation . length == 0 ) { return filter helper . empty_annotations ; } final list < annotation > filtering annotation = new array list < > ( annotation . length ) ; for ( final annotation annotation : annotation ) { final class < ? extend annotation > annotation type = annotation . annotation type ( ) ; for ( final annotation meta annotation : annotation type . get declared annotation ( ) ) { if ( meta annotation instanceof entity filter ) { filter annotation . add ( annotation ) ; } } } return filter annotation . to array ( new annotation [ filter annotation . size ( ) ] ) ; }
public int length ( ) { return ref . length ; }
public byte [ ] get byte ( ) { return byte ; }
public static string get status text ( int status code ) { if ( status code < 0 ) { throw new illegal argument exception ( `` status code may not be negative `` ) ; } int class index = status code / 100 ; int code index = status code - class index * 100 ; if ( class index < 1 || class index > ( reason_phrases . length - 1 ) || code index < 0 || code index > ( reason_phrases [ class index ] . length - 1 ) ) { return null ; } return reason_phrases [ class index ] [ code index ] ; }
public synchronize object pool < ? extend connection > get connection pool ( final string name ) throw s q l exception { final object pool < ? extend connection > pool = pool . get ( name ) ; if ( null == pool ) { throw new s q l exception ( `` pool not register : `` + name ) ; } return pool ; }
public int get size ( ) { return length ; }
public static code get code ( int code ) { if ( code < = max_code ) { return code map [ code ] ; } return null ; }
public void set index ( int index ) { this . index = index ; }
public boolean add ( final t element ) { boolean add = add elem ( element ) ; expand if necessary ( ) ; return add ; }
public void println ( string s ) throw i o exception { print ( s ) ; println ( ) ; }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public static boolean be public ( int flag ) { return ( flags & acc public ) ! = 0 ; }
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public string get method name ( ) { return method name ; }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public int get major version ( ) { return this . major version ; }
public int get database minor version ( ) { debug code call ( `` get database minor version `` ) ; return constant . version_minor ; }
public void remove attribute ( string attribute name ) { attribute map . remove ( attribute name ) ; }
public void set skip empty filesets ( boolean skip ) { skip empty = skip ; }
public int po ( ) { return po ; }
public string get table ( ) { return table ; }
public int size ( ) { return this . get num child ( ) ; }
public method info get method ( string name ) { for ( method info minfo : method ) if ( minfo . get name ( ) . equal ( name ) ) return minfo ; return null ; }
public final method info method ( ) { return method ; }
public void set dynamic update ( boolean value ) { this . dynamic update = value ; }
public void remove all index entry ( ) { if ( this . index ! = null ) this . index . remove ( get container relative path ( ) ) ; }
public void set manage component ( project component pc ) { this . manage pc = pc ; }
public void load default import ( ) { / * * note : the resolver look through these in reverse order , per precedence rule . . . so for max efficiency put the most common one later . * / import class ( `` bsh . eval error `` ) ; import class ( `` bsh . interpreter `` ) ; import package ( `` javax . swing . event `` ) ; import package ( `` javax . swing `` ) ; import package ( `` java . awt . event `` ) ; import package ( `` java . awt `` ) ; import package ( `` java . net `` ) ; import package ( `` java . util `` ) ; import package ( `` java . io `` ) ; import package ( `` java . lang `` ) ; import command ( `` /bsh/commands `` ) ; }
public synchronize ct class get locally ( string classname ) throw not find exception { softcache . remove ( classname ) ; ct class clazz = ( ct class ) class . get ( classname ) ; if ( clazz == null ) { clazz = create ct class ( classname , true ) ; if ( clazz == null ) throw new not find exception ( classname ) ; super . cache ct class ( classname , clazz , false ) ; } return clazz ; }
public string get classname ( ) { return classname ; }
public right get right ( ) { return right ; }
public type get type ( ) { return type ; }
public static void main ( string [ ] args ) throw i o exception { parse args ( args ) . upgrade ( ) ; }
public final void clflush ( mem mem ) { emit x86 ( inst_clflush , mem ) ; }
public byte [ ] get signature ( ) { return signature ; }
public ct class make nested class ( string name , boolean be static ) { throw new runtime exception ( get name ( ) + `` be not a class `` ) ; }
public ct class get ct class ( ) { if ( resolve ! = null ) return resolve . get ct class ( ) ; return type . object . get ct class ( ) ; }
public void set name ( string name ) { this . name = name ; }
public void set name ( string name ) { check modify ( ) ; if ( name ! = null ) qualify name = name ; }
public string get nested class name ( ) { return nest class selector . get nested class name ( ) ; }
public static optional < field > find field ( class type , string name ) { optional < field > declare field = find declare field ( type , name ) ; if ( ! declare field . be present ( ) ) { while ( ( type = type . get superclass ( ) ) ! = null ) { declared field = find field ( type , name ) ; if ( declared field . be present ( ) ) { break ; } } } return declared field ; }
public list < jaxb constructor result > get constructor result ( ) { if ( constructor result == null ) { constructor result = new array list < jaxb constructor result > ( ) ; } return this . constructor result ; }
public class < ? > get exception class ( ) { return this . exception class ; }
public member get member ( ) { return this . executable ; }
public string get name ( ) { return name ; } // get name
public int hash code ( ) { return to string ( ) . hash code ( ) ; }
public string get method name ( ) { return method name ; }
public void set stroke overprint control ( boolean op ) { dict . set boolean ( c o s name . op , op ) ; }
public access get access ( ) { return this . access ; }
protect void on visit method insn ( int opcode , string owner , string name , string descriptor , boolean be interface ) { super . visit method insn ( opcode , owner , name , descriptor , be interface ) ; }
public select set where clause ( string where clause ) { this . where clause = where clause ; this . guesstimate buffer size += where clause . length ( ) ; return this ; }
public const pool get const pool ( ) { return const pool ; }
public class < ? > get declare class ( ) { return method . get declare class ( ) ; }
public static boolean be final ( int mod ) { return ( mod & final ) ! = 0 ; }
public static boolean be static ( int mod ) { return ( mod & static ) ! = 0 ; }
public static boolean be static ( int mod ) { return ( mod & static ) ! = 0 ; }
public static boolean be static ( int mod ) { return ( mod & static ) ! = 0 ; }
public static boolean be static ( int mod ) { return ( mod & static ) ! = 0 ; }
public void clear ( ) { clear ( size ) ; }
public void set exit code ( int exit code ) { this . exit code = exit code ; }
public ct class get or null ( string classname ) { ct class clazz = null ; if ( classname == null ) clazz = null ; else try { / * class pool . get0 ( ) never throw an exception but it subclass may implement get0 that may throw an exception . * / clazz = get0 ( classname , true ) ; } catch ( not find exception e ) { } if ( clazz ! = null ) clazz . inc get counter ( ) ; return clazz ; }
public class loader get class loader ( ) { return class loader ; }
public void close ( ) throw i o exception { input . close ( ) ; }
public bean property descriptor get any property desc ( ) { if ( type desc == null ) return null ; return type desc . get any desc ( ) ; }
public int get int value ( ) { return 0 ; }
public reader reader value ( ) { return field data instanceof reader ? ( reader ) field data : null ; }
public string get comment ( ) { return this . comment ; } // -- string get comment ( )
public void set domain id ( string domain id ) { this . domain id = domain id ; }
public string get name ( ) { return name ; }
public enumeration < string > get header ( string name ) { return this . _get http servlet request ( ) . get header ( name ) ; }
public string get header ( string name ) { return this . _get http servlet request ( ) . get header ( name ) ; }
public string get servlet path ( ) { return this . servlet path ; }
public void set user ( string user ) { super . set internal user ( user ) ; }
public void set request session id ( string id ) { this . request session id = id ; }
public string get request session id ( ) { return this . _get http servlet request ( ) . get requested session id ( ) ; }
public void add date header ( string name , long date ) { this . _get http servlet response ( ) . add date header ( name , date ) ; }
public void set date header ( string name , long date ) { this . _get http servlet response ( ) . set date header ( name , date ) ; }
public string get header ( string name ) { return this . _get http servlet request ( ) . get header ( name ) ; }
public static set < role resource > get role ( role resource primary role ) { return cache . get role ( primary role ) ; }
public transport guarantee get transport guarantee ( ) { return this . transport guarantee ; }
public void set value ( object value ) { this . value = value ; }
public throwable get root cause ( ) { return get cause ( ) ; }
public void print stack trace ( print stream s ) { print stack trace ( s : : println ) ; }
public string get name ( ) { return ( this . name ) ; }
public object get attribute ( string name ) { return this . attribute . get ( name ) ; }
public locale get locale ( ) { return locale ; }
public boolean be concurrent handle start ( ) { return ( this . async web request ! = null & & this . async web request . be async start ( ) ) ; }
protect string get dispatcher web application context suffix ( ) { return null ; }
public void set locale ( locale locale ) { this . locale = locale ; }
public boolean be permanent ( ) { return permanent ; }
public reason get reason ( ) { return this . reason ; }
public container get container ( ) { return container ; }
public string get encode ( ) { return encode ; }
public http request decoder spec decoder ( ) { return decoder ; }
public annotation get annotation ( string type ) { annotation [ ] annotation = get annotation ( ) ; for ( int i = 0 ; i < annotation . length ; i++ ) { if ( annotation [ i ] . get type name ( ) . equal ( type ) ) return annotation [ i ] ; } return null ; }
public namespace get namespace ( ) { return namespace ; }
public method get method ( ) { return method ; }
public object invoke method ( string method name ) { return get proxy builder ( ) . invoke method ( method name , null ) ; }
public string get event ( ) { return event ; }
public static db exception convert ( throwable e ) { if ( e instanceof db exception ) { return ( db exception ) e ; } else if ( e instanceof s q l exception ) { return new db exception ( ( s q l exception ) e ) ; } else if ( e instanceof invocation target exception ) { return convert invocation ( ( invocation target exception ) e , null ) ; } else if ( e instanceof i o exception ) { return get ( error code . io_exception_1 , e , e . to string ( ) ) ; } else if ( e instanceof out of memory error ) { return get ( error code . out_of_memory , e ) ; } else if ( e instanceof stack overflow error || e instanceof linkage error ) { return get ( error code . general_error_1 , e , e . to string ( ) ) ; } else if ( e instanceof error ) { throw ( error ) e ; } return get ( error code . general_error_1 , e , e . to string ( ) ) ; }
public string get prefix ( ) { return prefix ; }
public string get event ( ) { return event ; }
protect void set current property ( x property property ) { if ( property == null ) { this . current property column override = null ; this . current property join column override = null ; this . current property join table override = null ; this . current property foreign key override = null ; } else { this . current property column override = build column override ( property , get path ( ) ) ; if ( this . current property column override . size ( ) == 0 ) { this . current property column override = null ; } this . current property join column override = build join column override ( property , get path ( ) ) ; if ( this . current property join column override . size ( ) == 0 ) { this . current property join column override = null ; } this . current property join table override = build join table override ( property , get path ( ) ) ; if ( this . current property join table override . size ( ) == 0 ) { this . current property join table override = null ; } this . current property foreign key override = build foreign key override ( property , get path ( ) ) ; if ( this . current property foreign key override . size ( ) == 0 ) { this . current property foreign key override = null ; } } }
public string to string ( ) { string builder sb = new string builder ( 256 ) ; sb . append ( `` ( `` ) ; sb . append ( get subject ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get predicate ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get object ( ) ) ; sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
public int size ( ) { return size ; }
public list < node > get node ( ) { return node ; }
public boolean be function ( ) { return this . function ; }
public string get name ( ) { return ( this . name ) ; }
public void set predicate ( final predicate < ? super e > predicate ) { this . predicate = predicate ; next object = null ; next object set = false ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public void set j d o m element ( element jdom element ) { this . jdom element = jdom element ; }
public element get j d o m element ( ) { return jdom element ; }
public namespace get namespace ( ) { return namespace ; }
public double get default priority ( ) { return -0 . 5 ; }
public pattern get pattern ( ) { return pattern ; }
public int get position ( ) { return position ; }
public e next ( ) { if ( ! next object set & & ! set next object ( ) ) { throw new no such element exception ( ) ; } next object set = false ; return next object ; }
public e next ( ) { if ( ! next object set & & ! set next object ( ) ) { throw new no such element exception ( ) ; } next object set = false ; return next object ; }
public list < exception > get exception ( ) { return exception ; }
public int hash code ( ) { return to string ( ) . hash code ( ) ; }
public void trace ( object message , object [ ] params ) { do log ( level . trace , fqcn , message , params , null ) ; }
public void trace ( object message ) { do log ( level . trace , fqcn , message , null , null ) ; }
public void debug ( object message ) { get logger ( ) . log ( fqcn , priority . debug , message , null ) ; }
public void error ( object message , throwable t ) { do log ( level . error , fqcn , message , null , t ) ; }
public void log ( level level , object message , object [ ] params ) { do log ( level , fqcn , message , params , null ) ; }
public void info ( object message , throwable t ) { do log ( level . info , fqcn , message , null , t ) ; }
public void trace ( object message , object [ ] params ) { do log ( level . trace , fqcn , message , params , null ) ; }
public string get suffix ( ) { return suffix ; }
public logger get logger ( ) { return logger ; }
public static format step resource key format step ( final boolean leave justify , final int minimum width , final int maximum width ) { return resource key format step ( left justify , minimum width , default_truncate_beginning , maximum width ) ; }
public static format step module name format step ( final boolean leave justify , final int minimum width , final int maximum width , final string precision ) { return module name format step ( left justify , minimum width , default_truncate_beginning , maximum width , precision ) ; }
public static string format ( long millis , string pattern , time zone time zone ) { return format ( new date ( millis ) , pattern , time zone , null ) ; }
public final void set no rotate ( boolean no rotate ) { annot . set flag ( c o s name . f , flag_no_rotate , no rotate ) ; }
public int get limit ( ) { return limit ; }
public void log raw ( final log record record ) { log raw ( ext log record . wrap ( record ) ) ; }
public int get queue length ( ) { return sync . get queue length ( ) ; }
public static string to optimal string ( inet address inet address ) { assert . check not null param ( `` inet address `` , inet address ) ; return inet address instanceof inet6 address ? to optimal string v6 ( inet address . get address ( ) ) : inet address . get host address ( ) ; }
public < v > v attach ( attachment key < v > key , v value ) throw security exception { return logger node . attach ( key , value ) ; }
public logger get logger ( ) { return logger ; }
public static level value of ( final string name ) { object . require non null ( name , `` no level name give . `` ) ; final string level name = to upper case ( name ) ; final level level = level . get ( level name ) ; if ( level ! = null ) { return level ; } throw new illegal argument exception ( `` unknown level constant [ `` + level name + `` ] . `` ) ; }
public static level value of ( final string name ) { object . require non null ( name , `` no level name give . `` ) ; final string level name = to upper case ( name ) ; final level level = level . get ( level name ) ; if ( level ! = null ) { return level ; } throw new illegal argument exception ( `` unknown level constant [ `` + level name + `` ] . `` ) ; }
public < v > v attach ( logger . attachment key < v > key , v value ) throw security exception { return root logger . attach ( key , value ) ; }
public boolean compare and set handler ( final handler [ ] expect , final handler [ ] new handler ) throw security exception { final handler [ ] safe expect handler = expect . clone ( ) ; final handler [ ] safe new handler = new handler . clone ( ) ; for ( handler handler : safe new handler ) { if ( handler == null ) { throw new illegal argument exception ( `` a handler be null `` ) ; } } handler [ ] old handler ; do { old handler = logger node . get handler ( ) ; if ( ! array . equal ( old handler , safe expect handler ) ) { return false ; } } while ( ! logger node . compare and set handler ( old handler , safe new handler ) ) ; return true ; }
public handler [ ] get and set handler ( final handler [ ] handler ) throw security exception { final handler [ ] safe handler = handler . clone ( ) ; for ( handler handler : safe handler ) { if ( handler == null ) { throw new illegal argument exception ( `` a handler be null `` ) ; } } return logger node . set handler ( safe handler ) ; }
public handler [ ] get and set handler ( final handler [ ] handler ) throw security exception { final handler [ ] safe handler = handler . clone ( ) ; for ( handler handler : safe handler ) { if ( handler == null ) { throw new illegal argument exception ( `` a handler be null `` ) ; } } return logger node . set handler ( safe handler ) ; }
public boolean be loggable ( final log record record ) { return accept ( record . get millis ( ) ) ; }
public @ nullable boolean get enable uncaught exception handler ( ) { return enable uncaught exception handler ; }
public boolean have exception handler ( ) { return ( this . exception handler ! = null ) ; }
public int get task count ( ) { return this . task count ; }
public void set value ( object value ) { this . value = value ; }
public i transaction get transaction ( ) { return this . transaction ; }
public transaction manager get transaction manager ( ) { return transaction manager ; }
public boolean be trace enable ( ) { return be level enable ( trace ) ; }
public void debug ( object message ) { get logger ( ) . log ( fqcn , priority . debug , message , null ) ; }
public void remove attribute ( string attribute name ) { attribute map . remove ( attribute name ) ; }
protect namespace get r s s namespace ( ) { return namespace . get namespace ( rss_uri ) ; }
public namespace pop ( string prefix ) { if ( prefix == null ) { prefix = `` `` ; } namespace namespace = null ; for ( int i = namespace stack . size ( ) - 1 ; i > = 0 ; i -- ) { namespace n = namespace stack . get ( i ) ; if ( prefix . equal ( n . get prefix ( ) ) ) { remove ( i ) ; namespace = ns ; break ; } } if ( namespace == null ) { system . out . println ( `` warning : miss namespace prefix ignore : `` + prefix ) ; } return namespace ; }
public void add ( final int index , final attribute attribute ) { if ( index < 0 || index > size ) { throw new index out of bound exception ( `` index : `` + index + `` size : `` + size ( ) ) ; } if ( attribute . get parent ( ) ! = null ) { throw new illegal add exception ( `` the attribute already have an exist parent \ `` `` + attribute . get parent ( ) . get qualified name ( ) + `` \ `` `` ) ; } final int duplicate = index of duplicate ( attribute ) ; if ( duplicate > = 0 ) { throw new illegal add exception ( `` can not add duplicate attribute `` ) ; } final string reason = verifier . check namespace collision ( attribute , parent ) ; if ( reason ! = null ) { throw new illegal add exception ( parent , attribute , reason ) ; } attribute . set parent ( parent ) ; ensure capacity ( size + 1 ) ; if ( index == size ) { attribute data [ size++ ] = attribute ; } else { system . arraycopy ( attribute data , index , attribute data , index + 1 , size - index ) ; attribute data [ index ] = attribute ; size++ ; } mod count++ ; }
public string get text ( ) { return value ; }
public doc type set system i d ( string system i d ) { string reason = verifier . check system literal ( system i d ) ; if ( reason ! = null ) { throw new illegal data exception ( system i d , `` doc type `` , reason ) ; } this . system i d = system i d ; return this ; }
public string get system i d ( ) { return system i d ; }
public static string get element content ( final element element ) throw exception { return get element content ( element , null ) ; }
public void set namespace u r i ( string namespace u r i ) { this . namespace u r i = namespace u r i ; }
public s o a p element add child element ( name child name ) throw s o a p exception { message element child = new message element ( child name . get local name ( ) , child name . get prefix ( ) , child name . get u r i ( ) ) ; add child ( child ) ; return child ; }
public string describe params ( ) { string builder sb = new string builder ( ) ; sb . append ( `` \t `` ) . append ( `` max query term : `` ) . append ( max query term ) . append ( `` \n `` ) ; sb . append ( `` \t `` ) . append ( `` min word len : `` ) . append ( min word len ) . append ( `` \n `` ) ; sb . append ( `` \t `` ) . append ( `` max word len : `` ) . append ( max word len ) . append ( `` \n `` ) ; sb . append ( `` \t `` ) . append ( `` field name : `` ) ; string delim = `` `` ; for ( string field name : field name ) { sb . append ( delim ) . append ( field name ) ; delim = `` , `` ; } sb . append ( `` \n `` ) ; sb . append ( `` \t `` ) . append ( `` boost : `` ) . append ( boost ) . append ( `` \n `` ) ; sb . append ( `` \t `` ) . append ( `` min term freq : `` ) . append ( min term freq ) . append ( `` \n `` ) ; sb . append ( `` \t `` ) . append ( `` min doc freq : `` ) . append ( min doc freq ) . append ( `` \n `` ) ; return sb . to string ( ) ; }
public boolean be set ( int mask ) { return ( attribute & mask ) ! = 0 ; }
public static string get element content ( final element element ) throw exception { return get element content ( element , null ) ; }
public void set expand entity ( final boolean expand ) { this . expand = expand ; engine = null ; }
public throwable get cause ( ) { return cause ; }
public static namespace get ( string prefix , string uri ) { return cache . get ( prefix , uri ) ; }
public string indent string ( int level ) { if ( level < indent . length ) return indent [ level ] ; else if ( format ) return right pad ( `` `` , indent * level ) ; else return `` `` ; }
public boolean get omit encode ( ) { return omit encode ; }
public boolean be omit super ( ) { return f omit super ; }
public void set expand entity ( final boolean expand ) { this . expand = expand ; engine = null ; }
public string get value ( ) { return text ; }
public geometry factory get factory ( ) { return factory ; }
public static list select node ( object context , string path ) throw j d o m exception { return new instance ( path ) . select node ( context ) ; }
public object select single node ( object context ) throw j d o m exception { try { current context = context ; return x path . select single node ( context ) ; } catch ( jaxen exception ex1 ) { throw new j d o m exception ( `` x path error while evaluate \ `` `` + x path . to string ( ) + `` \ `` : `` + ex1 . get message ( ) , ex1 ) ; } finally { current context = null ; } }
public static boolean be whitespace ( int c ) { return c == ' ' || c == '\t ' || c == '\n ' || c == '\f ' || c == '\r ' ; }
public package part create part ( package part name part name , string content type ) { return this . create part ( part name , content type , true ) ; }
public software i d get software i d ( ) { return software i d ; }
public void set manager ( string manager ) { this . manager = manager ; }
public string get public i d ( ) { return public i d ; }
public class < ? > get value class ( ) { return object . class ; }
public void set height ( short height ) { field_4_height = height ; }
public void set input p d f ( p d document input p d f ) { input p d f document = input p d f ; }
public x m p schema page text add page text schema ( ) { x m p schema page text schema = new x m p schema page text ( this ) ; return ( x m p schema page text ) basic add schema ( schema ) ; }
public schema get schema ( ) { return schema ; }
public map attribute ( ) { return this . node . attribute ( ) ; }
public string get property value ( string property name ) { return get property ( ) . get ( property name ) ; }
protect final element generate simple element ( final string name , final string value ) { final element element = new element ( name , get d c namespace ( ) ) ; element . add content ( value ) ; return element ; }
protect void set internal date ( final string date ) { this . date = date ; }
public instance creator get instance creator ( ) { return instance creator ; }
public string get title ( ) { return title ; }
public void set integer value ( int integer value ) { this . integer value = integer value ; }
public string get description ( ) { return description ; }
public void set right ( r right ) { this . right = right ; }
public string get language ( ) { return language ; }
public void set derive from ( resource ref resource ) { x m l util . set elementable value ( schema , prefix + `` : derive from `` , resource ) ; }
public resource ref create derive from ( ) { element node = schema . get owner document ( ) . create element ( prefix + `` : derive from `` ) ; resource ref ref = new resource ref ( node ) ; return ref ; }
public string get public i d ( ) { return public i d ; }
public void set manager ( string manager ) { this . manager = manager ; }
protect string list get category ( ) { return this . category ; }
public void set owner ( storage owner owner ) { this . owner = owner ; }
public string get language ( ) { return language ; }
public void set username ( string username ) { this . username = username ; }
public void delete blob ( set < universal unique identifier > set ) { for ( universal unique identifier id : set ) delete blob ( id ) ; }
public document parser ( parser parser ) { this . parser = parser ; return this ; }
public list < medium type > get support medium type ( ) { return this . supported medium type ; }
public void set connector ( connector [ ] connector ) { if ( connector ! = null ) { for ( connector connector : connector ) { if ( connector . get server ( ) ! = this ) throw new illegal argument exception ( `` connector `` + connector + `` can not be share among server `` + connector . get server ( ) + `` and server `` + this ) ; } } connector [ ] old connector = get connector ( ) ; update bean ( old connector , connector ) ; _connectors . remove all ( array . a list ( old connector ) ) ; if ( connector ! = null ) _connectors . add all ( array . a list ( connector ) ) ; }
public void set http client ( http client http client ) { this . http client = http client ; }
public request < ? > get request ( ) { return request ; }
public static string error_http_method_entity_not_null ( object arg0 ) { return localizer . localize ( localizable e r r o r_ h t t p_ m e t h o d_ e n t i t y_ n o t_ n u l l ( arg0 ) ) ; }
public static string preinvocation_interceptor_multiple_abortions ( ) { return localizer . localize ( localizable p r e i n v o c a t i o n_ i n t e r c e p t o r_ m u l t i p l e_ a b o r t i o n s ( ) ) ; }
public static string error_wadl_builder_generation_resource_path ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ r e s o u r c e_ p a t h ( arg0 , arg1 ) ) ; }
public static string error_scanning_class_not_found ( object arg0 ) { return localizer . localize ( localizable e r r o r_ s c a n n i n g_ c l a s s_ n o t_ f o u n d ( arg0 ) ) ; }
public static string error_http_method_entity_not_null ( object arg0 ) { return localizer . localize ( localizable e r r o r_ h t t p_ m e t h o d_ e n t i t y_ n o t_ n u l l ( arg0 ) ) ; }
public static string postinvocation_interceptor_multiple_resolves ( ) { return localizer . localize ( localizable p o s t i n v o c a t i o n_ i n t e r c e p t o r_ m u l t i p l e_ r e s o l v e s ( ) ) ; }
public static string request_entity_writer_null ( ) { return localizer . localize ( localizable r e q u e s t_ e n t i t y_ w r i t e r_ n u l l ( ) ) ; }
public static string preinvocation_interceptor_multiple_abortions ( ) { return localizer . localize ( localizable p r e i n v o c a t i o n_ i n t e r c e p t o r_ m u l t i p l e_ a b o r t i o n s ( ) ) ; }
public static string request_entity_writer_null ( ) { return localizer . localize ( localizable r e q u e s t_ e n t i t y_ w r i t e r_ n u l l ( ) ) ; }
public t get ( ) { return t ; }
public void mark ( int mark limit ) { }
public boolean register ( object component , inflector < contract provider . builder , contract provider > model enhancer ) { final class < ? > component class = component . get class ( ) ; final boolean result = register model ( component class , contract provider . no_priority , null , model enhancer ) ; if ( result ) { instance . add ( component ) ; } return result ; }
public string get alias ( ) { return alias ; }
public scope get parent ( ) { return parent ; }
public class < ? > get value class ( ) { return object . class ; }
public static string rc_not_modifiable ( ) { return localizer . localize ( localizable r c_ n o t_ m o d i f i a b l e ( ) ) ; }
public static string callback_array_null ( ) { return localizer . localize ( localizable c a l l b a c k_ a r r a y_ n u l l ( ) ) ; }
public static string callback_array_null ( ) { return localizer . localize ( localizable c a l l b a c k_ a r r a y_ n u l l ( ) ) ; }
public static string ssl_ts_providers_not_registered ( ) { return localizer . localize ( localizable s s l_ t s_ p r o v i d e r s_ n o t_ r e g i s t e r e d ( ) ) ; }
public static string error_scanning_class_not_found ( object arg0 ) { return localizer . localize ( localizable e r r o r_ s c a n n i n g_ c l a s s_ n o t_ f o u n d ( arg0 ) ) ; }
public static string ssl_ks_cert_load_error ( ) { return localizer . localize ( localizable s s l_ k s_ c e r t_ l o a d_ e r r o r ( ) ) ; }
public static string error_wadl_builder_generation_resource_path ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ r e s o u r c e_ p a t h ( arg0 , arg1 ) ) ; }
public static string http_invalid_chunk_size_hex_value ( object arg0 ) { return localizer . localize ( localizable h t t p_ i n v a l i d_ c h u n k_ s i z e_ h e x_ v a l u e ( arg0 ) ) ; }
public static string default_could_not_process_constructor ( object arg0 , object arg1 ) { return localizer . localize ( localizable d e f a u l t_ c o u l d_ n o t_ p r o c e s s_ c o n s t r u c t o r ( arg0 , arg1 ) ) ; }
public string get provider ( ) { return provider ; }
public jvm stats get jvm ( ) { return jvm ; }
public string to string ( ) { string builder sb = new string builder ( 256 ) ; sb . append ( `` ( `` ) ; sb . append ( get subject ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get predicate ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get object ( ) ) ; sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
public static class loader context class loader ( ) { return thread . current thread ( ) . get context class loader ( ) ; }
public static class < ? > get type argument ( type generic type ) { if ( ! ( generic type instanceof parameterized type ) ) return null ; parameterized type parameterized type = ( parameterized type ) generic type ; class < ? > type arg = ( class < ? > ) parameterized type . get actual type argument ( ) [ 0 ] ; return type arg ; }
public string get provide name ( ) { return provide name ; }
public char sequence sub sequence ( int start , int end ) { return new char slice ( array , offset+start , end-start ) ; }
public list < medium type > get support medium type ( ) { return this . supported medium type ; }
public void add header ( string name , string value ) throw message exception { header . add header ( name , value ) ; }
public string get match format name ( ) { return have match ( ) ? get match ( ) . get format name ( ) : null ; }
public void set date header ( string name , long date ) { this . _get http servlet response ( ) . set date header ( name , date ) ; }
public string get entity ( ) { return entity ; }
public void set interceptor ( object [ ] interceptor ) { this . interceptor = interceptor ; }
public static medium type create ( string type , string subtype ) { medium type medium type = create ( type , subtype , immutable list multimap . < string , string > of ( ) ) ; medium type . parse charset = optional . absent ( ) ; return medium type ; }
public static boolean copy stream ( input stream in stream , output stream out stream ) { try { byte [ ] buffer = new byte [ 1024 ] ; int bytes read ; while ( ( bytes read = in stream . read ( buffer ) ) > = 0 ) { out stream . write ( buffer , 0 , byte read ) ; } } catch ( exception e ) { return false ; } return true ; }
public boolean be empty ( ) { return name . be empty ( ) ; }
public type get generic type ( ) { return generic type ; }
public static builder builder ( ) { return new builder ( ) ; }
public static boolean be valid name for component ( string component ) { if ( component . equal ( `` . `` ) || component . equal ( `` . . `` ) || component . index of ( `` : `` ) > = 0 || component . index of ( `` / `` ) > = 0 ) { return false ; } return ! be reserve path component ( component ) ; }
public string get encode ( ) { return this . encoding ; } // -- string get encoding ( )
public void set key store ( key store configuration key store ) { if ( key store ! = null ) { this . key store = key store ; } }
public string get provider ( ) { return provider ; }
public void set uri ( final string uri ) { this . uri = u r i normalizer . normalize ( uri ) ; }
public template get template ( ) { return f custom template ; }
public int hash code ( ) { return to string ( ) . hash code ( ) ; }
public string get type ( ) { return type ; }
public string to string ( ) { return to string ( `` `` ) ; }
public static boolean be whitespace ( int c ) { return c == ' ' || c == '\t ' || c == '\n ' || c == '\f ' || c == '\r ' ; }
public type get type ( ) { return type ; }
public static string request_entity_writer_null ( ) { return localizer . localize ( localizable r e q u e s t_ e n t i t y_ w r i t e r_ n u l l ( ) ) ; }
public static string ambiguous_parameter ( object arg0 , object arg1 ) { return localizer . localize ( localizable a m b i g u o u s_ p a r a m e t e r ( arg0 , arg1 ) ) ; }
public static string error_wadl_builder_generation_resource_path ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ w a d l_ b u i l d e r_ g e n e r a t i o n_ r e s o u r c e_ p a t h ( arg0 , arg1 ) ) ; }
public static string ambiguous_rr_path ( object arg0 , object arg1 ) { return localizer . localize ( localizable a m b i g u o u s_ r r_ p a t h ( arg0 , arg1 ) ) ; }
public static string ambiguous_parameter ( object arg0 , object arg1 ) { return localizer . localize ( localizable a m b i g u o u s_ p a r a m e t e r ( arg0 , arg1 ) ) ; }
public static string request_entity_writer_null ( ) { return localizer . localize ( localizable r e q u e s t_ e n t i t y_ w r i t e r_ n u l l ( ) ) ; }
public static string uri_builder_scheme_part_unexpected_component ( object arg0 , object arg1 ) { return localizer . localize ( localizable u r i_ b u i l d e r_ s c h e m e_ p a r t_ u n e x p e c t e d_ c o m p o n e n t ( arg0 , arg1 ) ) ; }
public abstract connection get weak connection ( ) { return weak connection . get ( ) ; }
public void set scope ( final scope scope ) { this . scope = scope ; }
public list annotation ( ) { return this . annotation ; }
default public void value bound ( http session bind event event ) { }
default public void attribute replace ( http session bind event event ) { }
public transport guarantee get transport guarantee ( ) { return this . transport guarantee ; }
public default void attribute replace ( servlet context attribute event scae ) { }
public static string get filter trace ( throwable t ) { string writer string writer= new string writer ( ) ; print writer writer= new print writer ( string writer ) ; t . print stack trace ( writer ) ; string buffer buffer= string writer . get buffer ( ) ; string trace= buffer . to string ( ) ; return base test runner . get filtered trace ( trace ) ; }
public static void set context class loader ( class loader loader ) { context class loader = loader ; }
public row callback handler get row callback handler ( ) { return this . row callback handler ; }
public void set dir ( file directory ) { this . directory = directory ; }
public void set request header ( header header ) { header [ ] header = get request header group ( ) . get header ( header . get name ( ) ) ; for ( int i = 0 ; i < header . length ; i++ ) { get request header group ( ) . remove header ( header [ i ] ) ; } get request header group ( ) . add header ( header ) ; }
public u r i builder with scheme ( string scheme ) { return new u r i builder ( optional . of nullable ( scheme ) , scheme specific part , host , port , path , fragment , parameter , be path absolute , end with slash ) ; }
public authentication builder add custom ( authentication authentication ) { if ( authentication ! = null ) { authentication . add ( authentication ) ; } return this ; }
public x509 certificate get client x509 certificate ( ) { return certificate ; }
public request < ? > get request ( ) { return request ; }
public connector get connector ( ) { return state . get connector ( ) ; }
public static string random ( int count ) { return random ( count , false , false ) ; }
public string get filename ( ) { string filename = get file unicode ( ) ; if ( filename == null ) { filename = get file do ( ) ; } if ( filename == null ) { filename = get file mac ( ) ; } if ( filename == null ) { filename = get file unix ( ) ; } if ( filename == null ) { filename = get file ( ) ; } return filename ; }
public connection socket factory get ssl socket factory ( ) { return ssl socket factory ; }
public static builder builder ( long high trackable latency millis ) { return new builder ( high trackable latency millis ) ; }
public boolean be extend ( ) { return be extend ; }
public locale get locale ( ) { return locale ; }
public string [ ] get exclude mime type ( ) { set < string > exclude = _mime type . get excluded ( ) ; return exclude . to array ( new string [ exclude . size ( ) ] ) ; }
public equal builder set exclude field ( final string . . . exclude field ) { this . exclude field = exclude field ; return this ; }
public string get include ( ) { return include ; }
public void set method ( string method ) { this . method = method ; }
public void set min gzip size ( int min gzip size ) { _min gzip size = min gzip size ; }
public long capacity ( ) { return capacity . get ( ) ; }
public byte [ ] get content ( ) { return this . content ; }
public void set context ( string context ) { if ( context . start with ( `` / `` ) ) { this . context = context ; } else { this . context = `` / `` + context ; } }
public string get path ( ) { return path ; }
public boolean be permanent ( ) { return permanent ; }
public static long encode hi ( long encode , int hi ) { long h = ( ( long ) hi ) & 0x f f f f_ f f f f l ; long l = encode & 0x f f f f_ f f f f l ; return ( h < < 32 ) + l ; }
public static long encode hi ( long encode , int hi ) { long h = ( ( long ) hi ) & 0x f f f f_ f f f f l ; long l = encode & 0x f f f f_ f f f f l ; return ( h < < 32 ) + l ; }
public static long encode ( int hi , int lo ) { long h = ( ( long ) hi ) & 0x f f f f_ f f f f l ; long l = ( ( long ) lo ) & 0x f f f f_ f f f f l ; return ( h < < 32 ) + l ; }
public final byte [ ] buffer ( ) { return buf ; }
public final void write byte ( byte b ) throw i o exception { if ( buffer position > = buffer_size ) flush ( ) ; buffer [ buffer position++ ] = b ; }
public static byte [ ] buffer to array ( byte buffer buffer ) { if ( buffer . have array ( ) & & buffer . array offset ( ) == 0 & & buffer . array ( ) . length == buffer . remain ( ) ) { return buffer . array ( ) ; } else { byte [ ] bytes = new byte [ buffer . remain ( ) ] ; buffer . get ( byte ) ; return byte ; } }
public byte [ ] buffer ( ) { return this . buffer ; }
public static int space ( byte buffer buffer ) { if ( buffer == null ) return 0 ; return buffer . capacity ( ) - buffer . limit ( ) ; }
public final void write byte ( byte b ) throw i o exception { if ( buffer position > = buffer_size ) flush ( ) ; buffer [ buffer position++ ] = b ; }
public t get ( ) throw interrupted exception , execution exception { circuit . await ( ) ; if ( failure ! = null ) { if ( failure instanceof cancellation exception ) throw ( cancellation exception ) failure ; throw new execution exception ( failure ) ; } return result ; }
public static boolean be empty ( object [ ] array ) { return array == null || array . length == 0 ; }
public static object add array ( object list , object [ ] array ) { for ( int i = 0 ; array ! = null & & i < array . length ; i++ ) { list = lazy list . add ( list , array [ i ] ) ; } return list ; }
public static list transpose ( list list ) { list result = new array list ( ) ; if ( list . be empty ( ) ) return result ; int min size = integer . max_value ; for ( object list like : list ) { list list = ( list ) default type transformation . cast to type ( list like , list . class ) ; if ( list . size ( ) < min size ) min size = list . size ( ) ; } if ( min size == 0 ) return result ; for ( int i = 0 ; i < min size ; i++ ) { result . add ( new array list ( ) ) ; } for ( object list like : list ) { list list = ( list ) default type transformation . cast to type ( list like , list . class ) ; for ( int i = 0 ; i < min size ; i++ ) { list result list = ( list ) result . get ( i ) ; result list . add ( list . get ( i ) ) ; } } return result ; }
public url get url ( ) { return url ; }
public void set file ( file file ) { this . file = file ; }
public void set interval ( long interval ) { this . interval = interval ; }
public void run ( ) { this . delegate . run ( ) ; }
public void set skip empty filesets ( boolean skip ) { skip empty = skip ; }
public string get protocol ( ) { return protocol ; }
public boolean be enable ( ) { return this . enable ; }
public password new password ( string password ) { return new password ( password ) ; }
public void set password ( string password ) { this . password = password ; }
public list < definition > a list ( ) { return array . a list ( by idx ) ; }
public void set resource ( resource resource ) { this . resource = resource ; }
public @ not null thread get thread ( ) { return thread ; }
public class < ? > get value class ( ) { return object . class ; }
public void set server ( server server ) { this . server = server ; }
public void set map handler ( set < ? > map handler ) { this . map handler = map handler ; }
public static string trim trailing character ( string str , char trail character ) { if ( ! have length ( str ) ) { return str ; } string builder sb = new string builder ( str ) ; while ( sb . length ( ) > 0 & & sb . char at ( sb . length ( ) - 1 ) == trail character ) { sb . delete char at ( sb . length ( ) - 1 ) ; } return sb . to string ( ) ; }
public static string trim leading character ( string str , char lead character ) { if ( ! have length ( str ) ) { return str ; } string builder sb = new string builder ( str ) ; while ( sb . length ( ) > 0 & & sb . char at ( 0 ) == lead character ) { sb . delete char at ( 0 ) ; } return sb . to string ( ) ; }
public string [ ] get pattern ( ) { return pattern ; }
public void set relative path ( string relative path ) { this . relative path = relative path ; } // -- void set relative path ( string )
public string to string ( ) { string builder sb = new string builder ( 256 ) ; sb . append ( `` ( `` ) ; sb . append ( get subject ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get predicate ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get object ( ) ) ; sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
public static collection decorate ( collection coll , class type ) { return new predicate collection ( coll , instanceof predicate . get instance ( type ) ) ; }
public int get value ( ) { return family ; }
public static string get pointer string ( object o ) { return get pointer string ( ( o == null ) ? 0 : system . identity hash code ( o ) ) ; }
public string get callback name ( ) { return callback name ; }
public function library get function library ( ) { return executable . get function library ( ) ; }
public void clear ( ) { size = 0 ; }
public histogram aggregation builder offset ( double offset ) { this . offset = offset ; return this ; }
public string dump ( ) { return server info . dump ( all m bean server ) ; }
public void clear ( ) { size = 0 ; }
public string get char set ( ) { return this . char set ; }
public string get encode ( ) { return encode ; }
public static double [ ] to primitive ( final double [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_double_array ; } final double [ ] result = new double [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . double value ( ) ; } return result ; }
public string get string ( long offset , string encode ) { return native . get string ( this , offset , encode ) ; }
public string get field name ( ) { return field name ; }
public boolean force ( ) { return force ; }
public int get ( duration field type type ) { if ( type == get field type ( ) ) { return get value ( ) ; } return 0 ; }
public static string get prefix name ( x attr x attr ) { if ( x attr == null ) { return null ; } string namespace = x attr . get name space ( ) . to string ( ) ; return string utils . to lower case ( namespace ) + `` . `` + x attr . get name ( ) ; }
public list < server service definition > get service ( ) { return service ; }
public static i o service get matching service ( string service name ) { c f mutable dictionary ref dict = io . i o service match ( service name ) ; if ( dict ! = null ) { return get matching service ( dict ) ; } return null ; }
public boolean be unknown ( ) { return unknown . be set ( field_4_format ) ; }
public hresult get size ( / * [ out ] * /ulong pcb size ) { return null ; }
public int get size ( ) { return size ; }
public void normalize ( ) { for ( int i = 0 ; i < size ; i++ ) { key [ i ] = low case ( key [ i ] ) ; } }
public bean property descriptor get any property desc ( ) { if ( type desc == null ) return null ; return type desc . get any desc ( ) ; }
public string get help ( ) { return help ; }
public string get public i d ( ) { return public i d ; }
protect group get group by ( ) { return null ; }
public void add ( resource collection rc ) { get buildpath ( ) . add ( rc ) ; }
protect func get objective function ( ) { return function ; }
public void set action ( string action ) { this . action = action ; }
public publisher < u > get upstream publisher ( ) { return upstream publisher ; }
public void set ( int mask ) { flags |= mask ; }
public static int [ ] new int array ( int len ) { if ( len == 0 ) { return empty_int_array ; } return new int [ len ] ; }
public static fast date format get date time instance ( final int date style , final int time style , final time zone time zone ) { return get date time instance ( date style , time style , time zone , null ) ; }
public date time to date time i s o ( ) { return new date time ( get millis ( ) , i s o chronology . get instance ( get zone ( ) ) ) ; }
public interval with start millis ( long start instant ) { if ( start instant == get start millis ( ) ) { return this ; } return new interval ( start instant , get end millis ( ) , get chronology ( ) ) ; }
public void set interval ( long interval ) { this . interval = interval ; }
public duration to duration from ( readable instant start instant ) { long start millis = date time utils . get instant millis ( start instant ) ; chronology chrono = date time utils . get instant chronology ( start instant ) ; long end millis = chrono . add ( this , start millis , 1 ) ; return new duration ( start millis , end millis ) ; }
public void set duration after start ( long duration ) { set end millis ( field utils . safe add ( get start millis ( ) , duration ) ) ; }
public void set duration after start ( long duration ) { set end millis ( field utils . safe add ( get start millis ( ) , duration ) ) ; }
public date time with field ( date time field type field type , int value ) { if ( field type == null ) { throw new illegal argument exception ( `` field must not be null `` ) ; } long instant = field type . get field ( get chronology ( ) ) . set ( get millis ( ) , value ) ; return with millis ( instant ) ; }
protect void validate index ( int index ) { if ( index < 0 || index > size ) { throw new string index out of bound exception ( index ) ; } }
public static int to int ( byte [ ] bytes ) { int result = 0 ; for ( int i = 0 ; i < 4 ; i++ ) { result = ( result < < 8 ) - byte . min_value + ( int ) bytes [ i ] ; } return result ; }
public int [ ] get ( readable period period , long start instant , long end instant ) { int size = period . size ( ) ; int [ ] value = new int [ size ] ; if ( start instant ! = end instant ) { for ( int i = 0 ; i < size ; i++ ) { duration field field = period . get field type ( i ) . get field ( this ) ; int value = field . get difference ( end instant , start instant ) ; if ( value ! = 0 ) { start instant = field . add ( start instant , value ) ; } value [ i ] = value ; } } return value ; }
public long to duration millis ( ) { return field utils . safe add ( get end millis ( ) , -get start millis ( ) ) ; }
public void set interval ( readable instant start , readable instant end ) { if ( start == null & & end == null ) { long now = date time utils . current time millis ( ) ; set interval ( now , now ) ; } else { long start millis = date time utils . get instant millis ( start ) ; long end millis = date time utils . get instant millis ( end ) ; chronology chrono = date time utils . get instant chronology ( start ) ; super . set interval ( start millis , end millis , chrono ) ; } }
public field set set field ( field field ) { return set field ( new field description . for loaded field ( field ) ) ; }
public int get type ( ) { return type ; }
public void set period after start ( readable period period ) { if ( period == null ) { set end millis ( get start millis ( ) ) ; } else { set end millis ( get chronology ( ) . add ( period , get start millis ( ) , 1 ) ) ; } }
public period to period to ( readable instant end instant ) { return new period ( this , end instant ) ; }
public date time field halfday of day ( ) { return unsupported date time field . get instance ( date time field type . halfday of day ( ) , halfdays ( ) ) ; }
public date time field clockhour of halfday ( ) { return unsupported date time field . get instance ( date time field type . clockhour of halfday ( ) , hour ( ) ) ; }
public date time field type get date time field type ( ) { return i date time field type ; }
public locale get locale ( ) { return locale ; }
public chronology get chronology ( ) { return i chrono ; }
public void set duration after start ( long duration ) { set end millis ( field utils . safe add ( get start millis ( ) , duration ) ) ; }
public boolean equal ( object period ) { if ( this == period ) { return true ; } if ( period instanceof readable period == false ) { return false ; } readable period other = ( readable period ) period ; return ( other . get period type ( ) == get period type ( ) & & other . get value ( 0 ) == get value ( ) ) ; }
public date time minus ( long duration ) { return with duration add ( duration , -1 ) ; }
public final boolean local ( ) { return local ; }
protect void compute time ( ) { boolean unset year = ! be set ( year ) ; if ( unset year ) set ( year , get default year ( ) ) ; try { super . compute time ( ) ; } finally { if ( unset year ) clear ( year ) ; } }
public long get millis ( ) { if ( date time ! = null ) { validate ( ) ; } return millis ; }
public date time field type get date time field type ( ) { return i date time field type ; }
public boolean be duration ( ) { return impl . be duration ( receiver ) ; }
public local date to local date ( ) { return new local date ( get millis ( ) , get chronology ( ) ) ; }
protect string get timestamp ( ) { date date = new date ( system . current time millis ( ) ) ; date format formatter = date format . get date time instance ( date format . short , date format . short ) ; string finish time = formatter . format ( date ) ; return finish time ; }
public date time field type get date time field type ( ) { return i date time field type ; }
public date time field type get date time field type ( ) { return i date time field type ; }
public chronology get chronology ( ) { return i chrono ; }
public static interval of hour minute second ( long hour , int minute , int second ) { return of hour minute nanos ( hour , minute , second * nanos_per_second ) ; }
public string get public i d ( ) { return public i d ; }
public long get millis ( ) { if ( date time ! = null ) { validate ( ) ; } return millis ; }
public void add hour ( int hour ) { super . add field ( duration field type . hour ( ) , hour ) ; }
public int get ( duration field type type ) { if ( type == get field type ( ) ) { return get value ( ) ; } return 0 ; }
public long get interval ( ) { return interval ; }
public long set ( long instant , int value ) { field utils . verify value bound ( this , value , get minimum value ( instant ) , get maximum value ( instant ) ) ; return super . set ( instant , value ) ; }
public int [ ] get ( readable period period , long start instant , long end instant ) { int size = period . size ( ) ; int [ ] value = new int [ size ] ; if ( start instant ! = end instant ) { for ( int i = 0 ; i < size ; i++ ) { duration field field = period . get field type ( i ) . get field ( this ) ; int value = field . get difference ( end instant , start instant ) ; if ( value ! = 0 ) { start instant = field . add ( start instant , value ) ; } value [ i ] = value ; } } return value ; }
public void set match range ( document range range ) { this . match range = range ; }
public instant instant value ( ) { instant ret = delegate . instant value ( ) ; return ret ; }
public static date time formatter full date time ( ) { return create formatter for style index ( full , full ) ; }
public static string get package name from full name ( string full ) { if ( full . last index of ( ' . ' ) < 0 ) { return `` `` ; } else { return full . substring ( 0 , full . last index of ( ' . ' ) ) ; } }
public static final chronology get chronology ( chronology chrono ) { if ( chrono == null ) { return i s o chronology . get instance ( ) ; } return chrono ; }
public final boolean local ( ) { return local ; }
protect string get timestamp ( ) { date date = new date ( system . current time millis ( ) ) ; date format formatter = date format . get date time instance ( date format . short , date format . short ) ; string finish time = formatter . format ( date ) ; return finish time ; }
public static date time formatter basic time no millis ( ) { return constant . btx ; }
public static date time formatter basic time ( ) { return constant . bt ; }
public static interval of hour minute second ( long hour , int minute , int second ) { return of hour minute nanos ( hour , minute , second * nanos_per_second ) ; }
public boolean equal ( object period ) { if ( this == period ) { return true ; } if ( period instanceof readable period == false ) { return false ; } readable period other = ( readable period ) period ; return ( other . get period type ( ) == get period type ( ) & & other . get value ( 0 ) == get value ( ) ) ; }
public void set print header ( print header record new print header ) { print header = new print header ; }
public period type with day remove ( ) { return with field remove ( 3 , `` no day `` ) ; }
public void add hour ( int hour ) { super . add field ( duration field type . hour ( ) , hour ) ; }
public period formatter builder append day ( ) { append field ( day ) ; return this ; }
public date time with field ( date time field type field type , int value ) { if ( field type == null ) { throw new illegal argument exception ( `` field must not be null `` ) ; } long instant = field type . get field ( get chronology ( ) ) . set ( get millis ( ) , value ) ; return with millis ( instant ) ; }
public string get illegal value a string ( ) { string value = i string value ; if ( value == null ) { value = string . value of ( i number value ) ; } return value ; }
public string value ( ) { return value ; }
public duration to duration from ( readable instant start instant ) { long start millis = date time utils . get instant millis ( start instant ) ; chronology chrono = date time utils . get instant chronology ( start instant ) ; long end millis = chrono . add ( this , start millis , 1 ) ; return new duration ( start millis , end millis ) ; }
public duration to duration from ( readable instant start instant ) { long start millis = date time utils . get instant millis ( start instant ) ; chronology chrono = date time utils . get instant chronology ( start instant ) ; long end millis = chrono . add ( this , start millis , 1 ) ; return new duration ( start millis , end millis ) ; }
public long to duration millis ( ) { return field utils . safe add ( get end millis ( ) , -get start millis ( ) ) ; }
public boolean equal ( object period ) { if ( this == period ) { return true ; } if ( period instanceof readable period == false ) { return false ; } readable period other = ( readable period ) period ; return ( other . get period type ( ) == get period type ( ) & & other . get value ( 0 ) == get value ( ) ) ; }
public final int get hour ( ) { return hour ; }
public period minus minute ( int minute ) { return plus minute ( -minutes ) ; }
protect int index of support ( date time field type type ) { int index = index of ( type ) ; if ( index == -1 ) { throw new illegal argument exception ( `` field ' `` + type + `` ' be not support `` ) ; } return index ; }
public restore snapshot request partial ( boolean partial ) { this . partial = partial ; return this ; }
public void set minute ( int minute ) { super . set field ( duration field type . minute ( ) , minute ) ; }
public void set timeout ( int second ) { timeout = second ; }
public int get ( duration field type type ) { if ( type == get field type ( ) ) { return get value ( ) ; } return 0 ; }
public static period type year week day time ( ) { period type type = c y w d time ; if ( type == null ) { type = new period type ( `` year week day time `` , new duration field type [ ] { duration field type . year ( ) , duration field type . week ( ) , duration field type . day ( ) , duration field type . hour ( ) , duration field type . minute ( ) , duration field type . second ( ) , duration field type . millis ( ) , } , new int [ ] { 0 , -1 , 1 , 2 , 3 , 4 , 5 , 6 , } ) ; c y w d time = type ; } return type ; }
public period formatter builder append day ( ) { append field ( day ) ; return this ; }
public string get public i d ( ) { return public i d ; }
public boolean be verbose ( ) { return verbose ; }
public string m bean server info ( ) { return m bean server manager . get server info ( ) ; }
public void destroy ( ) { close ( ) ; }
public string dump ( ) { return server info . dump ( all m bean server ) ; }
public exchange server info get server info ( ) { return server info ; }
public string get server info ( ) { return mbean server . dump ( ) ; }
public static string sanitize file name ( path path ) { string p = path . get file name ( ) . to string ( ) ; if ( p . length ( ) > 1 & & p . char at ( p . length ( ) - 1 ) == '/ ' ) { return p . substring ( 0 , p . length ( ) - 1 ) ; } return p ; }
public string m bean server info ( ) { return m bean server manager . get server info ( ) ; }
protect void add vendor file ( hashtable ejb file , string dd prefix ) { ejb file . put ( meta_dir + ias_dd , new file ( get config ( ) . descriptor dir , get ias descriptor name ( ) ) ) ; }
protect boolean be eligible aspect bean ( string bean name ) { if ( this . include pattern == null ) { return true ; } else { for ( pattern pattern : this . include pattern ) { if ( pattern . matcher ( bean name ) . match ( ) ) { return true ; } } return false ; } }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public string get name ( ) { return name ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public static boolean be valid ( string name ) { if ( name == null ) { throw new illegal argument exception ( `` name be miss `` ) ; } boolean slash = false ; for ( int i = 0 ; i < name . length ( ) ; i++ ) { char ch = name . char at ( i ) ; if ( ch < = ' ' || ch > = 127 || ch == ' ( ' || ch == ' ) ' || ch == ' < ' || ch == ' > ' || ch == ' @ ' || ch == ' , ' || ch == ' ; ' || ch == ' : ' || ch == '\\ ' || ch == ' `` ' || ch == ' [ ' || ch == ' ] ' || ch == ' ? ' || ch == '= ' ) { return false ; } else if ( ch == '/ ' ) { if ( slash || i == 0 || i + 1 == name . length ( ) ) { return false ; } slash = true ; } } return slash ; }
public string to string ( ) { string buffer uri spec string = new string buffer ( ) ; if ( m_scheme ! = null ) { uri spec string . append ( m_scheme ) ; uri spec string . append ( ' : ' ) ; } uri spec string . append ( get scheme specific part ( ) ) ; return uri spec string . to string ( ) ; }
public void set unless ( object unless property ) { this . unless condition = unless property ; }
public static string get matching character ( final string character , final string input , final int maximum length ) { final string builder sb = new string builder ( input . length ( ) ) ; for ( int i = 0 ; i < input . length ( ) ; i++ ) { final char c = input . char at ( i ) ; if ( character . index of ( c ) ! = -1 ) { if ( sb . length ( ) < maximum length ) { sb . append ( c ) ; } else { break ; } } } return sb . to string ( ) ; }
public string to j s o n string ( ) { return to j s o n string ( this , j s o n value . compression ) ; }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public string get default string value ( ) { return default string value ; }
public criterion lte ( object o ) { this . criterion type = relational operator . lte ; this . right = value node . to value node ( o ) ; return this ; }
public criterion ne ( object o ) { this . criterion type = relational operator . ne ; this . right = value node . to value node ( o ) ; return this ; }
public final o get o s ( ) { return o ; }
public object mapper config jaxb object mapper factory ( j a x b object mapper factory jaxb object mapper factory ) { return new object mapper config ( default object mapper , default object mapper type , gson object mapper factory , jackson1 object mapper factory , jackson2 object mapper factory , jaxb object mapper factory , johnzon object mapper factory , jsonb object mapper factory , true ) ; }
public object get type ( ) { return type ; }
public static string sanitize file name ( path path ) { string p = path . get file name ( ) . to string ( ) ; if ( p . length ( ) > 1 & & p . char at ( p . length ( ) - 1 ) == '/ ' ) { return p . substring ( 0 , p . length ( ) - 1 ) ; } return p ; }
protect boolean be valid scheme ( string scheme ) { if ( scheme == null ) { return false ; } if ( ! scheme_pattern . matcher ( scheme ) . match ( ) ) { return false ; } if ( be off ( allow_all_schemes ) ) { if ( ! this . allow scheme . contains ( scheme ) ) { return false ; } } return true ; }
public t get new value ( ) { return new value ; }
public void set report ( object report ) { this . report = report ; } // -- void set report ( object )
public void set float value ( float float value ) { this . float value = float value ; }
public void test failure ( failure failure ) throw exception { }
public void array next elm ( appendable out ) throw i o exception { out . append ( ' , ' ) ; }
public void object elm stop ( appendable out ) throw i o exception { }
public t parse object ( byte [ ] json byte ) throw i o exception { verify ( ) ; return parse ( json byte ) . get object ( ) ; }
public print writer get writer ( ) throw i o exception { return this . response . get writer ( ) ; }
public j s o n object to j s o n object ( ) { return to j s o n object ( true ) ; }
public boolean get past pivot ( ) { return have pass pivot ; }
public boolean be empty ( ) { return name . be empty ( ) ; }
public static boolean be x m l whitespace ( char c ) { if ( c== ' ' || c=='\n ' || c=='\t ' || c=='\r ' ) { return true ; } return false ; }
public static string to string ( accountable a ) { string builder sb = new string builder ( ) ; to string ( sb , a , 0 ) ; return sb . to string ( ) ; }
public string to turtle ( ) { string val = this . value ; val = val . replace ( `` \ `` `` , `` \\\ `` `` ) ; val = `` \ `` `` +val+ `` \ `` `` ; if ( data type == null ) { if ( language ! = null ) { val = val+ `` @ `` +language ; } } else { val = val+ `` ^^ < `` + data type . get xml schema u r i string ( ) + `` > `` ; } return val ; }
public void set tag ( tag tag ) { this . tag = tag ; }
public void add child ( unknown element child ) { if ( child == null ) { child = new array list ( ) ; } child . add ( child ) ; }
protect void add node before ( final node < e > node , final e value ) { final node < e > new node = create node ( value ) ; add node ( new node , node ) ; }
public query node get child ( ) { list < query node > child = get child ( ) ; if ( child == null || child . size ( ) == 0 ) { return null ; } return child . get ( 0 ) ; }
public void add ( json element element ) { if ( element == null ) { element = json null . instance ; } element . add ( element ) ; }
public element attr ( string attribute key , string attribute value ) { for ( element element : this ) { element . attr ( attribute key , attribute value ) ; } return this ; }
public element get element by index equal ( int index ) { return collector . collect ( new evaluator . index equal ( index ) , this ) ; }
public element get element by index less than ( int index ) { return collector . collect ( new evaluator . index less than ( index ) , this ) ; }
public pattern get pattern ( ) { return pattern ; }
public node get node ( ) { return node ; }
public int root ( ) { return root ; }
public void add text ( string text ) { this . text = text ; }
public int get po ( ) { return po ; }
public int get offset ( ) { return offset ; }
public string get error message ( ) { return error message ; }
public final string get tag name ( ) { return tag name ; }
public list < string > form parameter names ( ) { list < string > ret = delegate . form parameter names ( ) ; return ret ; }
public char seq [ ] split ( string regex , int limit ) { return split seq ( regex , limit ) . to java array ( char seq . class ) ; }
public int [ ] get match start ( ) { return match start ; }
public string put attribute ( string key , string value ) { if ( attribute == null ) { attribute = new hash map < string , string > ( ) ; } return attribute . put ( key , value ) ; }
public string to string ( ) { string builder sb = new string builder ( 256 ) ; sb . append ( `` ( `` ) ; sb . append ( get subject ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get predicate ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get object ( ) ) ; sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
public element before ( string html ) { for ( element element : this ) { element . before ( html ) ; } return this ; }
public element append ( string html ) { for ( element element : this ) { element . append ( html ) ; } return this ; }
public string get query ( ) { return this . query ; }
public query get query ( ) { return query ; }
public static builder builder ( ) { return new builder ( ) ; }
public boolean find ( int key ) { for ( int i=0 ; i < use ; i++ ) { if ( key [ i ] == key ) { return true ; } } return false ; }
public chunk parser get parser ( ) { return parser ; }
public string get name ( ) { return tag name ; }
public element prev all ( string query ) { return sibling ( query , false , true ) ; }
public void set manager ( string manager ) { this . manager = manager ; }
public string get expect ( ) { return f expect ; }
public void end test ( test test ) { f model . add run test ( test ) ; fire test change ( test , false ) ; }
static public void assert equal ( string message , float expect , float actual , float delta ) { if ( float . compare ( expect , actual ) == 0 ) return ; if ( ! ( math . ab ( expect - actual ) < = delta ) ) fail not equal ( message , new float ( expect ) , new float ( actual ) ) ; }
public list < format error > get error ( ) { return error ; }
public static class < ? > load class by name ( string class name ) throw class not find exception { try { return class . for name ( class name ) ; } catch ( class not find exception e ) { return thread . current thread ( ) . get context class loader ( ) . load class ( class name ) ; } }
public static void print root cause stack trace ( throwable t , print writer writer ) { string trace [ ] = get root cause stack trace ( t ) ; for ( string a trace : trace ) { writer . println ( a trace ) ; } writer . flush ( ) ; }
public void clear ( ) { clear ( size ) ; }
public int test count ( ) { return f test . size ( ) ; }
public diff command set new tree ( abstract tree iterator new tree ) { this . new tree = new tree ; return this ; }
public void end test ( test test ) { f model . add run test ( test ) ; fire test change ( test , false ) ; }
public void end test ( test test ) { f model . add run test ( test ) ; fire test change ( test , false ) ; }
public void clean up ( ) { }
static public void assert equal ( float expect , float actual , float delta ) { assert equal ( null , expect , actual , delta ) ; }
public int get expect key length ( ) { return expect length ; }
public void end test ( test test ) { f model . add run test ( test ) ; fire test change ( test , false ) ; }
protect boolean evaluate value ( object expect , object actual ) { return ( expect == actual ) || ( ( expect ! = null ) & & expect . equal ( actual ) ) ; }
public static object a type ( object object , class type ) throw throwable { if ( object == null ) object = null object . get null object ( ) ; return invoke method n ( object . get class ( ) , object , `` a type `` , new object [ ] { type } ) ; }
public void set description ( string description ) { this . description = description ; }
public class < ? > get value class ( ) { return object . class ; }
public void set description ( string description ) throw message exception { set description ( description , null ) ; }
public void fire test suite start ( final description description ) { new safe notifier ( ) { @ override protect void notify listener ( run listener each ) throw exception { each . test suite start ( description ) ; } } . run ( ) ; }
public static void assert equal ( long actual , long expect , string message ) { assert equal ( long . value of ( actual ) , long . value of ( expect ) , message ) ; }
public string get expect ( ) { return f expect ; }
public void set folder ( iterable < folder > folder ) { this . set object ( ( collection < folder > ) folder ) ; }
public void set description ( string description ) { this . description = description ; }
public string get get method name ( ) { return get method name ; }
public type get type ( ) { return type ; }
public runner safe runner for class ( class < ? > test class ) { try { runner runner = runner for class ( test class ) ; if ( runner ! = null ) { configure runner ( runner ) ; } return runner ; } catch ( throwable e ) { return new error reporting runner ( test class , e ) ; } }
public < at extends annotation > at get annotation ( class < at > annotation class ) { return annotation class . cast ( annotation . get ( annotation class ) ) ; }
public string get message ( ) { return message ; }
public void assert number ( byte [ ] content , @ nullable string encoding , double expect value ) throw exception { double actual = evaluate xpath ( content , encode , double . class ) ; assertion error . assert equal ( `` x path `` + this . expression , expect value , actual ) ; }
public throwable get cause ( ) { return cause ; }
public void fail ( string failure message ) { assertion error error = failure . instance ( ) . failure ( failure message ) ; proxy . collect error ( error ) ; }
public int get modifier ( ) { return modifier . public ; }
public class < ? > get declare class ( ) { return get member ( ) . get declare class ( ) ; }
public long get timeout ( ) { return timeout ; }
public void apply ( object target ) { / * * note that all runner that be orderable be also sortable ( because * orderable extends sortable ) . sort be more efficient than order , * so we override the parent behavior so we sort instead . * / if ( target instanceof sortable ) { sortable sortable = ( sortable ) target ; sortable . sort ( this ) ; } }
public static long prefix cod to long ( final byte ref val ) { long sortable bit = 0l ; for ( int i=val . offset+1 , limit=val . offset+val . length ; i < limit ; i++ ) { sortable bit < < = 7 ; final byte b = val . bytes [ i ] ; if ( b < 0 ) { throw new number format exception ( `` invalid prefix cod numerical value representation ( byte `` + integer . to hex string ( b & 0xff ) + `` at position `` + ( i-val . offset ) + `` be invalid ) `` ) ; } sortable bit |= b ; } return ( sortable bit < < get prefix cod long shift ( val ) ) ^ 0x8000000000000000 l ; }
public void fire test finish ( final description description ) { new safe notifier ( ) { @ override protect void notify listener ( run listener each ) throw exception { each . test finish ( description ) ; } ; } . run ( ) ; }
public runner safe runner for class ( class < ? > test class ) { try { return runner for class ( test class ) ; } catch ( throwable e ) { return new error reporting runner ( test class , e ) ; } }
public static < t > matcher < t > be ( t value ) { return be ( equal to ( value ) ) ; }
public void set optional ( boolean optional ) { this . be optional = optional ; }
public boolean equal ( object obj ) { return super . equal ( obj ) ; }
public void set class ( class clazz ) { this . clazz = clazz ; if ( clazz == null ) { return ; } this . class loader = ( class loader == null ) ? clazz . get class loader ( ) : class loader ; this . class name = ( class name == null ) ? clazz . get name ( ) : class name ; }
public ct class make nested class ( string name , boolean be static ) { throw new runtime exception ( get name ( ) + `` be not a class `` ) ; }
public void detach and stop all appenders ( ) { for ( appender < e > a : appender list ) { a . stop ( ) ; } appender list . clear ( ) ; }
public void set location info ( boolean flag ) { location info = flag ; }
public int get buffer size ( ) { return buffer size ; }
public pattern get pattern ( ) { return pattern ; }
public static boolean be whitespace ( int c ) { return c == ' ' || c == '\t ' || c == '\n ' || c == '\f ' || c == '\r ' ; }
public void append ( final log event event ) { manager . send event ( get layout ( ) , event ) ; }
protect void finalize ( ) { dispose ( ) ; }
public string get message ( ) { return message ; }
public string get description ( ) { return description ; }
public void log ( string category , log level level , string message , string ndc ) { log ( category , level , message , null , ndc ) ; }
public void log ( level level , object message , object [ ] params ) { do log ( level , fqcn , message , params , null ) ; }
public int get count ( ) { return message . size ( ) ; }
public void add ( json element element ) { if ( element == null ) { element = json null . instance ; } element . add ( element ) ; }
public boolean be trace enable ( ) { return be level enable ( trace ) ; }
public void set warn log category ( string logger name ) { this . warn logger = log factory . get log ( logger name ) ; }
public byte [ ] get byte ( ) { return byte ; }
public void set factory ( string name ) { factory name = name ; }
public string get address ( ) { return this . address ; } // -- string get address ( )
public final completable delay ( long delay , time unit unit ) { return delay ( delay , unit , scheduler . computation ( ) , false ) ; }
public server socket create server socket ( int port ) throw i o exception { return new server socket ( port ) ; }
public void set layout ( layout manager l ) { }
public string to string ( ) { if ( i to string == null ) { string buffer buf = new string buffer ( 4 ) ; if ( be negate ( ) ) { buf . append ( '^ ' ) ; } buf . append ( start ) ; if ( start ! = end ) { buf . append ( '- ' ) ; buf . append ( end ) ; } i to string = buf . to string ( ) ; } return i to string ; }
public int po ( ) { return po ; }
public int get max string length ( ) { return max string length ; }
public final byte [ ] buffer ( ) { return buf ; }
public void set location info ( final boolean flag ) { location info = flag ; }
public static void close quietly ( closeable closeable ) { try { if ( closeable ! = null ) { closeable . close ( ) ; } } catch ( i o exception e ) { logger . error ( `` i o exception should not have be throw . `` , e ) ; } }
public void debug ( string msg ) { logger . log ( fqcn , level . debug , msg , null ) ; }
public void set level ( int level ) { this . level = level ; }
public static level get level ( ) { return level ; }
public level get level for name ( string name ) throw illegal argument exception { if ( name ! = null ) { final level level = level_map . get ( name ) ; if ( level ! = null ) { return level ; } } throw new illegal argument exception ( `` unknown level \ `` `` + name + `` \ `` `` ) ; }
public void set logger context ( logger context context ) { super . set context ( context ) ; }
public static logger get formatter logger ( final string name ) { return name == null ? get formatter logger ( stack locator util . get caller class ( 2 ) ) : get logger ( name , string formatter message factory . instance ) ; }
public static logger get formatter logger ( final class < ? > clazz ) { return get logger ( clazz ! = null ? clazz : stack locator util . get caller class ( 2 ) , string formatter message factory . instance ) ; }
public boolean be marker annotation ( ) { return ( this instanceof marker annotation ) ; }
public string get format ( ) { return message pattern ; }
public string get format ( ) { return message pattern ; }
public void set id ( final string id ) { this . id = id ; }
public boolean be require ( ) { return require ; }
public string get content type ( ) { string a [ ] = get mime header ( `` content- type `` ) ; if ( a ! = null & & a . length > 0 ) { return a [ 0 ] ; } else { return null ; } }
public log builder at level ( level level ) { if ( be enable ( level ) ) { return ( get log builder ( level ) . reset ( level ) ) ; } else { return log builder . noop ; } }
public level get level ( ) { return level ; }
public void set logger context ( logger context context ) { super . set context ( context ) ; }
public static marker get marker ( final string name , final marker parent ) { return get marker ( name ) . add parent ( parent ) ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public url get url ( ) { return url ; }
public final long get timestamp ( ) { return this . timestamp ; }
public static level get level ( ) { return level ; }
public set < string > get remove ( ) { return remove ; }
public stack get stack ( ) { return stack ; }
public string get file name ( ) { return file name ; }
public string get name ( ) { return name ; }
public log event to serializable ( final log event event ) { return event ; }
public int get buffer size ( ) { return buffer size ; }
public static < b > builder < b > builder ( ) { return new builder < b > ( ) ; }
protect void set complete ( ) { this . complete = true ; }
public void set first row ( int first row ) { _range . set first row ( first row ) ; }
public void set processor ( refactoring processor processor ) { processor . set refactoring ( this ) ; f processor= processor ; }
public string get file name ( ) { return this . file name ; }
public string get script ( ) { return script ; }
public string get event ( ) { return event ; }
public schedule future < ? > schedule at fix rate ( final runnable command , final long initial delay , final long period , final time unit unit ) { return get executor service ( ) . schedule at fix rate ( command , initial delay , period , unit ) ; }
public < v > schedule future < v > schedule ( final callable < v > callable , final long delay , final time unit unit ) { return get executor service ( ) . schedule ( callable , delay , unit ) ; }
public long get last modified ( ) { return last modify ; }
public input stream get input stream ( ) { return input stream ; }
public void remove appender ( final appender appender ) { synchronize ( appenders ) { appenders . remove appender ( appender ) ; } }
public log event to serializable ( final log event event ) { return event ; }
public int size ( ) { return size ; }
public version result get result ( ) { return result ; }
public final boolean match ( string to test ) { return key . match ( to test ) ; }
public string get status ( ) { return this . status ; } // -- string get status ( )
public status configuration with status ( final string status ) { this . status = level . to level ( status , null ) ; if ( this . status == null ) { this . error ( `` invalid status level specify : `` + status + `` . default to error . `` ) ; this . status = level . error ; } return this ; }
public void set filter ( tree filter filter ) { this . filter = filter ; }
public void print stack trace ( ) { super . print stack trace ( ) ; }
public string to string ( ) { return new string buffer ( ) . append ( `` [ entity ref : `` ) . append ( `` & `` ) . append ( name ) . append ( `` ; `` ) . append ( `` ] `` ) . to string ( ) ; }
public string get event ( ) { return event ; }
public boolean be false ( ) { return value == false ; }
public configuration get configuration ( ) { return config ; }
public logger get logger ( ) { return logger ; }
public logger get logger ( ) { return logger ; }
public int priority ( ) { int ret = delegate . priority ( ) ; return ret ; }
public boolean contains name ( final string name ) { for ( final t i : this ) { if ( i . get name ( ) . equal ( name ) ) { return true ; } } return false ; }
public dependency resolver get resolver ( ) { return resolver ; }
public string [ ] get pattern ( ) { return pattern ; }
public location get location ( ) { return this . location ; }
public string get format ( ) { return format ; }
public string get default string value ( ) { return default string value ; }
public class loader get class loader ( ) { return class loader ; }
public string get prefix string ( ) { return prefix ; }
public file get source ( ) { return source ; }
public to string builder append to string ( string to string ) { if ( to string ! = null ) { style . append to string ( buffer , to string ) ; } return this ; }
public logger get logger ( ) { return logger ; }
public void set name binding ( boolean name binding ) { this . name bind = name binding ; }
public publisher < u > get upstream publisher ( ) { return upstream publisher ; }
public string get event ( ) { return event ; }
public void set logger context ( logger context context ) { super . set context ( context ) ; }
public list < filter > get filter ( ) { return array . a list ( filter ) ; }
public list < string > get framework package ( ) { return framework package ; }
public void set server socket ( server socket server socket ) { this . server socket = server socket ; }
protect socket address testable remote socket address ( ) { return cnxn . send thread . get client cnxn socket ( ) . get remote socket address ( ) ; }
public list < string > get framework package ( ) { return framework package ; }
public void set logger context ( logger context context ) { super . set context ( context ) ; }
public object [ ] get meta method ( ) { meta class meta class = invoker helper . get meta class ( object under inspection ) ; list meta method = meta class . get meta method ( ) ; object [ ] result = new object [ meta method . size ( ) ] ; int i = 0 ; for ( iterator iter = meta method . iterator ( ) ; iter . have next ( ) ; i++ ) { meta method meta method = ( meta method ) iter . next ( ) ; result [ i ] = method info ( meta method ) ; } return result ; }
public static parser try to find existing leaf parser ( class clazz , parse context context ) { parser p = context . get ( parser . class ) ; if ( equal ( p , clazz ) ) { return p ; } parser return parser = null ; if ( p ! = null ) { if ( p instanceof parser decorator ) { p = find in decorate ( ( parser decorator ) p , clazz ) ; } if ( equal ( p , clazz ) ) { return p ; } if ( p instanceof composite parser ) { return parser = find in composite ( ( composite parser ) p , clazz , context ) ; } } if ( return parser ! = null & & equal ( return parser , clazz ) ) { return return parser ; } return null ; }
public string get title ( ) { return title ; }
public static boolean be assignable ( final type type , final type to type ) { return be assignable ( type , to type , null ) ; }
public synchronize int error count ( ) { return f error . size ( ) ; }
public int get port ( ) { return port ; }
public static string low case ( string str ) { if ( be null or empty ( str ) ) { return str ; } return str . to lower case ( locale_english ) ; }
public string [ ] get pattern ( ) { return pattern ; }
public void set history ( boolean value ) { this . history = value ; }
public static boolean to boolean ( object value ) { if ( value instanceof boolean ) { return ( boolean ) value ; } if ( value instanceof string ) { string s = ( string ) value ; if ( project . to boolean ( s ) ) { return boolean . true ; } if ( `` off `` . equal ignore case ( s ) || `` false `` . equal ignore case ( s ) || `` no `` . equal ignore case ( s ) ) { return boolean . false ; } } return null ; }
public string get description ( ) { return ( description == null ) ? to string ( ) : description ; }
public int get current queue size ( ) { return work queue . size ( ) ; }
public synchronize void add provider ( provider provider ) { provider . add element ( provider ) ; provider by class name . put ( provider . get class name ( ) , provider ) ; if ( ! provider by protocol . contains key ( provider . get protocol ( ) ) ) provider by protocol . put ( provider . get protocol ( ) , provider ) ; }
public void set password ( string password ) { this . password = password ; }
public void set parameter ( parameter [ ] parameter ) { if ( parameter ! = null ) { for ( int i = 0 ; i < parameter . length ; i++ ) { config parameter . add ( parameter [ i ] ) ; } } }
public void set manager ( string manager ) { this . manager = manager ; }
public string get protocol ( ) { return protocol ; }
public void remove appender ( final appender appender ) { synchronize ( appenders ) { appenders . remove appender ( appender ) ; } }
public static void remove matching ( collection < string > value , string . . . pattern ) { remove matching ( value , array . a list ( pattern ) ) ; }
public static void retain matching ( collection < string > value , string . . . pattern ) { retain matching ( value , array . a list ( pattern ) ) ; }
public deployment option set instance ( int instance ) { this . instance = instance ; return this ; }
public void set password ( string password ) { this . password = password ; }
public string get content ( ) { return content ; }
public project get project ( ) { return project ; }
public string get realm ( ) { return get parameter ( `` realm `` ) ; }
public artifact descriptor result set dependency ( list < dependency > dependency ) { if ( dependency == null ) { this . dependency = collection . empty list ( ) ; } else { this . dependency = dependency ; } return this ; }
public deploy request add artifact ( artifact artifact ) { if ( artifact ! = null ) { if ( artifact . be empty ( ) ) { artifact = new array list < artifact > ( ) ; } artifacts . add ( artifact ) ; } return this ; }
public void set resolve artifact ( set < artifact > artifact ) { this . resolve artifact = ( artifacts ! = null ) ? artifact : collection . < artifact > empty set ( ) ; this . artifacts = null ; this . artifact map = null ; }
public string get entity ( ) { return entity ; }
public string get group id ( ) { return this . group id ; } // -- string get group id ( )
public void set artifact id ( string artifact id ) { this . artifact id = artifact id ; } // -- void set artifact id ( string )
public void set execution ( java . util . list execution ) { this . execution = execution ; } // -- void set execution ( java . util . list )
public static file get plugins home ( ) { return plugins home ; }
public activation o s get os ( ) { return this . o ; } // -- activation o s get os ( )
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public void set test output directory ( string test output directory ) { this . test output directory = test output directory ; } // -- void set test output directory ( string )
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public string get name ( ) { return to string ( ) ; }
public string get id ( ) { return this . id ; } // -- string get id ( )
public status get status ( ) { return null ; }
public void set site resource ( java . util . list < resource > site resource ) { this . site resource = site resource ; } // -- void set site resource ( java . util . list )
public string get artifact id ( ) { return artifact id ; }
public build get build ( ) { return this . build ; } // -- build get build ( )
public string get description ( ) { return description ; }
public string get organization url ( ) { return this . organization url ; } // -- string get organization url ( )
public void set artifact id ( string artifact id ) { this . artifact id = artifact id ; } // -- void set artifact id ( string )
public build get build ( ) { return this . build ; } // -- build get build ( )
public cancellable get license async ( get license request request , request option option , action listener < get license response > listener ) { return rest high level client . perform request async ( request , license request converter : : get license , option , response - > new get license response ( convert response to json ( response ) ) , listener , empty set ( ) ) ; }
public int get next pic name number ( int format ) throw invalid format exception { int img = get all package picture ( ) . size ( ) + 1 ; string proposal = x w p f picture data . relation [ format ] . get file name ( img ) ; package part name create part name = packaging u r i helper . create part name ( proposal ) ; while ( this . get package ( ) . get part ( create part name ) ! = null ) { img++ ; proposal = x w p f picture data . relation [ format ] . get file name ( img ) ; create part name = packaging u r i helper . create part name ( proposal ) ; } return img ; }
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public void set property ( string property ) { this . property = property ; }
public void set report set ( java . util . list < report set > report set ) { this . report set = report set ; } // -- void set report set ( java . util . list )
public string get name ( ) { return this . name ; } // -- string get name ( )
public artifact descriptor result set dependency ( list < dependency > dependency ) { if ( dependency == null ) { this . dependency = collection . empty list ( ) ; } else { this . dependency = dependency ; } return this ; }
public string get group id ( ) { return this . group id ; } // -- string get group id ( )
public string get group id ( ) { return this . group id ; } // -- string get group id ( )
public void set report ( object report ) { this . report = report ; } // -- void set report ( object )
public void set id ( string id ) { this . id = id ; }
public string get release ( ) { return this . release ; } // -- string get release ( )
protect void set connection ( @ nullable connection connection ) { if ( this . current connection ! = null ) { if ( this . connection handle ! = null ) { this . connection handle . release connection ( this . current connection ) ; } this . current connection = null ; } if ( connection ! = null ) { this . connection handle = new simple connection handle ( connection ) ; } else { this . connection handle = null ; } }
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public object get result ( ) { return result ; }
public void set file set ( java . util . list < file set > file set ) { this . file set = file set ; } // -- void set file set ( java . util . list )
public void enable bucket versioning ( string bucket name ) throw s3 service exception { update bucket versioning status impl ( bucket name , true , false , null , null ) ; }
public string get extension name ( ) { return extension name ; }
public final i node update modification time ( long mtime , int late snapshot id ) { precondition . check state ( be directory ( ) ) ; if ( mtime < = modification time ) { return this ; } return set modification time ( mtime , late snapshot id ) ; }
public void set snapshot ( repository policy snapshot ) { this . snapshots = snapshot ; } // -- void set snapshot ( repository policy )
public request < ? > get request ( ) { return request ; }
public version range result add exception ( exception exception ) { if ( exception ! = null ) { if ( exception . be empty ( ) ) { exception = new array list < exception > ( ) ; } exception . add ( exception ) ; } return this ; }
public static < t > iterator < t > cycle ( t . . . element ) { return cycle ( list . new array list ( element ) ) ; }
public void set scope ( string scope ) { this . scope = scope ; }
public artifact get artifact ( ) { return artifact ; }
public collection < metadata > get metadata ( ) { return metadata ; }
public artifact get artifact ( ) { return artifact ; }
public string get artifact id ( ) { return this . artifact id ; } // -- string get artifact id ( )
public deploy request set metadata ( collection < metadata > metadata ) { if ( metadata == null ) { this . metadata = collection . empty list ( ) ; } else { this . metadata = metadata ; } return this ; }
public artifact get artifact ( ) { return artifact ; }
public remote repository get repository ( ) { return repository ; }
public request < ? > get request ( ) { return request ; }
public void set file ( file file ) { this . file = file ; }
public authentication builder add custom ( authentication authentication ) { if ( authentication ! = null ) { authentication . add ( authentication ) ; } return this ; }
public string get url ( ) { return this . url ; } // -- string get url ( )
public policy get policy ( ) { return policy ; }
public list < remote repository > get repository ( ) { return repository ; }
public artifact result set repository ( artifact repository repository ) { this . repository = repository ; return this ; }
public void set dependency ( java . util . list < dependency > dependency ) { this . dependency = dependency ; } // -- void set dependency ( java . util . list )
public artifact descriptor result set dependency ( list < dependency > dependency ) { if ( dependency == null ) { this . dependency = collection . empty list ( ) ; } else { this . dependency = dependency ; } return this ; }
public list < remote repository > get repository ( ) { return repository ; }
public artifact descriptor result set repository ( artifact repository repository ) { this . repository = repository ; return this ; }
public int root ( ) { return root ; }
public metadata request set delete local copy if miss ( boolean delete local copy if miss ) { this . delete local copy if miss = delete local copy if miss ; return this ; }
public boolean be delete local copy if miss ( ) { return delete local copy if miss ; }
public collection < metadata > get metadata ( ) { return metadata ; }
public list < exception > get exception ( ) { return exception ; }
public artifact get artifact ( ) { return artifact ; }
public object get result ( ) { return result ; }
public remote repository get repository ( ) { return repository ; }
public void resume ( ) { delegate . resume ( ) ; }
public string get version ( ) { return version ; }
public list < exception > get exception ( ) { return exception ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public static byte [ ] encode data with length ( final base64 u r l data ) { byte [ ] bytes = data ! = null ? data . decode ( ) : null ; return encode data with length ( byte ) ; }
public void set session ( session session ) { this . session = session ; }
public void set filter ( tree filter filter ) { this . filter = filter ; }
public artifact get artifact ( ) { return artifact ; }
public authentication builder add custom ( authentication authentication ) { if ( authentication ! = null ) { authentication . add ( authentication ) ; } return this ; }
public void set authentication ( authentication authentication ) { _authentication = authentication ; }
public void set proxy ( web proxy proxy ) { this . proxy = proxy ; }
public activation o s get os ( ) { return this . o ; } // -- activation o s get os ( )
public string get name ( ) { return this . name ; } // -- string get name ( )
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public string get password ( ) { return password ; }
public string get private key password ( ) { return this . private key password ; }
public void set mode ( string mode ) { this . mode = mode ; }
public string get local repository ( ) { return this . local repository ; } // -- string get local repository ( )
public argument create argument ( boolean insert at start ) { argument argument = new argument ( ) ; if ( insert at start ) { argument . insert element at ( argument , 0 ) ; } else { argument . add element ( argument ) ; } return argument ; }
public commandline java . sys property get sys property ( ) { return get command line ( ) . get system property ( ) ; }
public int run ( string [ ] args ) throw exception { int exit code = 0 ; try { exit code = init ( args ) ; if ( exit code ! = 0 ) { return exit code ; } if ( command . validate ( ) ) { command . execute ( ) ; } else { exit code = 1 ; } } catch ( exception e ) { e . print stack trace ( err ) ; return 1 ; } return exit code ; }
public int get count ( ) { return message . size ( ) ; }
public int write ( writer writer , result set r ) throw s q l exception { this . output = writer ; return write result set ( r ) ; }
public int get numerator ( ) { return numerator ; }
public boolean be empty ( ) { return name . be empty ( ) ; }
public void set float value ( float float value ) { this . float value = float value ; }
public ct type reference < double > double type ( ) { return double . clone ( ) ; }
public void set dir ( file directory ) { this . directory = directory ; }
public dependency resolver get resolver ( ) { return resolver ; }
public static json value parse ( reader reader ) throw i o exception { if ( reader == null ) { throw new null pointer exception ( `` reader be null `` ) ; } default handler handler = new default handler ( ) ; new json parser ( handler ) . parse ( reader ) ; return handler . get value ( ) ; }
public static json value parse ( string string ) { if ( string == null ) { throw new null pointer exception ( `` string be null `` ) ; } default handler handler = new default handler ( ) ; new json parser ( handler ) . parse ( string ) ; return handler . get value ( ) ; }
public void set ( boolean value ) { this . value = value ; }
public boolean be empty ( ) { return name . be empty ( ) ; }
public location get location ( ) { return this . location ; }
public t [ ] get value ( t [ ] array ) { t v = get value ( ) ; if ( v == null ) { if ( array . length ! = 0 ) { array [ 0 ] = null ; } return array ; } if ( array . length == 0 ) { array = array . copy of ( array , 1 ) ; } array [ 0 ] = v ; if ( array . length ! = 1 ) { array [ 1 ] = null ; } return array ; }
public boolean be empty ( ) { return value . be empty ( ) ; }
public long a long ( ) { throw new illegal argument exception ( `` not a number `` ) ; }
public static string pretty print ( pretty printable tree ) { string builder sb = new string builder ( ) ; pretty print ( tree . get node ( ) , sb , `` `` , true , true ) ; return sb . to string ( ) ; }
public static double geq ( double value ) { report matcher ( new great or equal ( value ) ) ; return 0 ; }
public float float value ( ) { return value ; }
public static short any short ( ) { report matcher ( new instance of ( short . class , `` < any short > `` ) ) ; return 0 ; }
public static boolean eq ( boolean value ) { return report matcher ( new equal ( value ) ) . return false ( ) ; }
public static int or ( int first , int second ) { last control . report or ( 2 ) ; return first ; }
static public void assert equal ( float expect , float actual , float delta ) { assert equal ( null , expect , actual , delta ) ; }
public void visit code ( ) { if ( mv ! = null ) { mv . visit code ( ) ; } }
public void set bean ( object new bean ) { bean = new bean ; reinitialise ( ) ; }
public json generator get generator ( ) { return null ; }
public final method info method ( ) { return method ; }
public object get mock server result ( ) { return this . mock server result ; }
public static < t > t mock ( class < t > class to mock ) { return mock ( class to mock , with setting ( ) . default answer ( returns_defaults ) ) ; }
public static verification mode at most once ( ) { return verification mode factory . at most once ( ) ; }
public static void validate mockito usage ( ) { mockito_core . validate mockito usage ( ) ; }
public object get result ( ) { return result ; }
public static < a > answer < void > answer void ( void answer1 < a > answer ) { return to answer ( answer ) ; }
public static < t > t be a ( class < t > clazz ) { report matcher ( new instance of ( clazz ) ) ; return null ; }
public static < t > t mock ( class < t > class to mock ) { return mock ( class to mock , with setting ( ) . default answer ( returns_defaults ) ) ; }
public static class get wrapper type ( class primitive type ) { if ( primitive type . be primitive ( ) ) { return primitives_to_wrappers . get ( primitive type ) ; } return primitive type ; }
public static set any set ( ) { return report matcher ( any . any ) . return set ( ) ; }
public static string any string ( ) { return report matcher ( any . any ) . return string ( ) ; }
public static string any string ( ) { return report matcher ( any . any ) . return string ( ) ; }
public static boolean eq ( boolean value ) { report matcher ( new equal ( value ) ) ; return false ; }
public string get suffix ( ) { return suffix ; }
public static verification mode only ( ) { return verification mode factory . only ( ) ; }
public static power mockito stubber do answer ( answer < ? > answer ) { return powermockito_core . do answer ( answer ) ; }
public class < t > get type ( ) { return type ; }
public static string any string ( ) { return report matcher ( any . any ) . return string ( ) ; }
public static short to short ( object value ) throw conversion exception { number n = to number ( value , short . class ) ; if ( n instanceof short ) { return ( short ) n ; } else { return new short ( n . short value ( ) ) ; } }
public static long long that ( matcher < long > matcher ) { report matcher ( matcher ) ; return 0 ; }
public static < t > element matcher . junction < t > not ( element matcher < ? super t > matcher ) { return new negate matcher < t > ( matcher ) ; }
public static < t > t arg that ( matcher < t > matcher ) { report matcher ( matcher ) ; return ( t ) default value ( generic type of matcher ( matcher . get class ( ) ) ) ; }
public static long long that ( matcher < long > matcher ) { report matcher ( matcher ) ; return 0 ; }
public axis engine get engine ( ) { return ( engine ) ; }
public logger get logger ( ) { return logger ; }
public runner safe runner for class ( class < ? > test class ) { try { return runner for class ( test class ) ; } catch ( throwable e ) { return new error reporting runner ( test class , e ) ; } }
public static < a > answer < void > answer void ( void answer1 < a > answer ) { return to answer ( answer ) ; }
public void clear ( ) { clear ( size ) ; }
public boolean be synthetic ( ) { return synthetic ; }
public collector result get collector ( ) { return collector . get collector tree ( ) ; }
public static verification mode only ( ) { return verification mode factory . only ( ) ; }
public static void validate mockito usage ( ) { mockito_core . validate mockito usage ( ) ; }
public request < ? > get request ( ) { return request ; }
public http request [ ] retrieve record request ( http request http request ) { string record request = retrieve record request ( http request , format . json ) ; if ( string utils . be not empty ( recorded request ) & & ! record request . equal ( `` [ ] `` ) ) { return http request serializer . deserialize array ( record request ) ; } else { return new http request [ 0 ] ; } }
public http method get method ( ) { return this . method ; }
public void set body ( expression body ) { super . set body ( body ) ; use = body ; }
public http response with cooky ( cookie . . . cooky ) { this . cooky . with entry ( cooky ) ; return this ; }
public void clear cooky ( ) { cooky parse = true ; cooky convert = true ; cooky = null ; }
public static builder new builder ( ) { return new builder ( ) ; }
public static builder new builder ( ) { return new builder ( ) ; }
public byte [ ] buffer ( ) { return this . buffer ; }
public t get ( ) { return t ; }
public void set r ( string value ) { this . r = value ; }
public static < t > consumer < t > consumer ( unchecked consumer < t > consumer ) { return consumer . to consumer ( ) ; }
public static < t > unchecked consumer < t > unchecked ( consumer < t > consumer ) { return unchecked consumer . from ( consumer ) ; }
protect void on visit lookup switch insn ( label default target , int [ ] key , label [ ] label ) { super . visit lookup switch insn ( default target , key , label ) ; }
public annotation visitor visit type annotation ( final int type ref , final type path type path , final string descriptor , final boolean visible ) { if ( delegate ! = null ) { return delegate . visit type annotation ( type ref , type path , descriptor , visible ) ; } return null ; }
public void set sort ( string value ) { this . sort = value ; }
public static object eval ( string expression , map < string , object > var ) { cache map variable resolver factory factory = new cache map variable resolver factory ( var ) ; try { return new m v e l interpret runtime ( expression , null , factory ) . parse ( ) ; } finally { factory . externalize ( ) ; } }
public static object execute expression ( final object compile expression , final object ctx , final map var ) { cache map variable resolver factory factory = var ! = null ? new cache map variable resolver factory ( var ) : null ; try { return ( ( executable statement ) compile expression ) . get value ( ctx , factory ) ; } finally { if ( factory ! = null ) factory . externalize ( ) ; } }
public eval factory eval ( ) { if ( eval == null ) { eval = new eval factory ( this ) ; } return eval ; }
public static object eval ( string expression , map < string , object > var ) { cache map variable resolver factory factory = new cache map variable resolver factory ( var ) ; try { return new m v e l interpret runtime ( expression , null , factory ) . parse ( ) ; } finally { factory . externalize ( ) ; } }
public void set thread two phase commit ( boolean thread two phase commit ) { this . thread two phase commit = thread two phase commit ; }
public byte [ ] get byte ( ) { int size = 0 ; for ( int i = 0 ; i < classic list . size ( ) ; i++ ) { size += classic list . get ( i ) . length ; } byte [ ] ret = new byte [ size ] ; int temp size = 0 ; for ( int i = 0 ; i < classic list . size ( ) ; i++ ) { system . arraycopy ( classic list . get ( i ) , 0 , ret , temp size , classic list . get ( i ) . length ) ; temp size += classic list . get ( i ) . length ; } return ret ; }
public void start ( ) throw i o exception { lock . lock ( ) ; try { if ( process ! = null ) { return ; } process = new command line ( this . executable , args . to array ( new string [ ] { } ) ) ; process . set environment variable ( environment ) ; process . copy output to ( system . err ) ; process . execute async ( ) ; wait until available ( ) ; } finally { lock . unlock ( ) ; } }
public void detail ( boolean detail ) { this . detailed = detail ; }
public void set recovery i d ( long recovery id ) { if ( recovery id > this . recovery id ) { this . recovery id = recovery id ; } else { throw new illegal argument exception ( `` the new rcovery id : `` + recovery id + `` must be great than the current one : `` + this . recovery id ) ; } }
public long start recovery ( index shard index shard , discovery node source node , peer recovery target service . recovery listener listener , time value activity timeout ) { recovery target recovery target = new recovery target ( index shard , source node , listener ) ; start recovery internal ( recovery target , activity timeout ) ; return recovery target . recovery id ( ) ; }
public void set module ( final list < module > module ) { this . module = module ; }
public store get store ( ) { return store ; }
public void register bean ( class < ? > bean class ) { do register bean ( bean class , null , null , null , null ) ; }
public @ not null thread get thread ( ) { return thread ; }
public float get request per second ( ) { return request per second ; }
public void set commit name ( string [ ] commit name ) { this . commit name = commit name ; }
public boolean be complete ( ) { return complete ; }
public boolean be xa assume recovery complete ( ) { return xa assume recovery complete ; }
public list < string > get xa resource map class name ( ) { synchronize ( this ) { return new array list < string > ( xa resource map class name ) ; } }
public list < string > get xa recovery node ( ) { return new array list < string > ( xa recovery node ) ; }
public void set transaction synchronization registry name ( string transaction synchronization registry name ) { this . transaction synchronization registry name = transaction synchronization registry name ; }
public void set xa resource orphan filter class name ( list < string > xa resource orphan filter class name ) { synchronize ( this ) { if ( xa resource orphan filter class name == null ) { this . xa resource orphan filter = new array list < x a resource orphan filter > ( ) ; this . xa resource orphan filter class name = new array list < string > ( ) ; } else if ( ! xa resource orphan filter class name . equal ( this . xa resource orphan filter class name ) ) { this . xa resource orphan filter = null ; this . xa resource orphan filter class name = new array list < string > ( xa resource orphan filter class name ) ; } } }
public void set commit name ( string [ ] commit name ) { this . commit name = commit name ; }
public void set transaction manager ( final transaction manager transaction manager ) { this . transaction manager = transaction manager ; }
public static logger get logger ( class < ? > clazz ) { return get logger ( clazz . get name ( ) ) ; }
public void set connection ( string connection ) { this . connection = connection ; } // -- void set connection ( string )
public void set session ( session session ) { this . session = session ; }
public int get connect timeout ( ) { return connect timeout ; }
public static input source to input source ( source s ) { return to input source ( s , null ) ; }
public static void write double l e ( double d , byte [ ] arr , int offset ) { write long l e ( double . double to raw long bit ( d ) , arr , offset ) ; }
public synchronize void reset ( ) { check stream ( ) ; end ( stream ) ; stream = init ( conserve memory ? 1 : 0 ) ; finish = false ; compress direct buf off = compress direct buf len = 0 ; uncompressed direct buf . limit ( direct buffer size ) ; uncompressed direct buf . position ( direct buffer size ) ; user buf off = user buf len = 0 ; }
public final byte [ ] buffer ( ) { return buf ; }
public static long read global checkpoint ( final path location , final string expect translog u u i d ) throw i o exception { final checkpoint checkpoint = read checkpoint ( location , expect translog u u i d ) ; return checkpoint . global checkpoint ; }
public state get state ( ) { return state . get ( ) . get state ( ) ; }
public void replace string value ( char sequence string value ) { comment = string value . to string ( ) ; }
public uri get uri ( ) { return this . uri ; }
protect charset get charset ( @ nullable medium type content type ) { if ( content type ! = null & & content type . get charset ( ) ! = null ) { return content type . get charset ( ) ; } else { return standard charsets . utf_8 ; } }
public void remove http data from clean ( interface http data data ) { check destroy ( ) ; factory . remove http data from clean ( request , data ) ; }
public list < interface http data > get body http data ( ) { check destroy ( ) ; if ( ! be last chunk ) { throw new not enough data decoder exception ( ) ; } return body list http data ; }
protect charset get charset ( @ nullable medium type content type ) { if ( content type ! = null & & content type . get charset ( ) ! = null ) { return content type . get charset ( ) ; } else { return standard charsets . utf_8 ; } }
public static cod input stream new instance ( final byte [ ] buf ) { return new instance ( buf , 0 , buf . length ) ; }
public string get uri ( ) { return uri ; }
protect b max reserve stream ( int max reserve stream ) { enforce constraint ( `` server `` , `` connection `` , connection ) ; enforce constraint ( `` server `` , `` codec `` , decoder ) ; enforce constraint ( `` server `` , `` codec `` , encoder ) ; this . max reserve stream = check positive or zero ( max reserve stream , `` max reserve stream `` ) ; return self ( ) ; }
protect int max reserve stream ( ) { return max reserve streams ! = null ? max reserve stream : default_max_reserved_streams ; }
public long capacity ( ) { return capacity . get ( ) ; }
protect http2 frame logger frame logger ( ) { return frame logger ; }
public string get table ( ) { return table ; }
public void add header ( header header ) { header . add ( header ) ; }
public void add ( hpack header field header ) { int header size = header . size ( ) ; if ( header size > capacity ) { clear ( ) ; return ; } while ( capacity - size < header size ) { remove ( ) ; } hpack header field [ head++ ] = header ; size += header . size ( ) ; if ( head == hpack header field . length ) { head = 0 ; } }
public string get encode ( ) { return encode ; }
public string get code ( ) { return this . code ; }
public string value ( ) { return value ; }
public synchronize void set flag ( flags flag , boolean set ) throw message exception { if ( set ) flag . add ( flag ) ; else flag . remove ( flag ) ; }
public void set in stream ( in stream stream ) { this . stream = stream ; }
public @ nullable response < ? > response ( ) { return response ; }
public int [ ] get value ( ) { int [ ] result = new int [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get value ( i ) ; } return result ; }
public string get prefix ( ) { return prefix ; }
public principal get principal ( ) { return this . principal ; }
static public void assert equal ( string message , object expect , object actual ) { if ( expect == null & & actual == null ) return ; if ( expect ! = null & & expect . equal ( actual ) ) return ; if ( expect instanceof string & & actual instanceof string ) throw new comparison failure ( message , ( string ) expect , ( string ) actual ) ; else fail not equal ( message , expect , actual ) ; }
public dynamic type . builder < ? > rebase ( package a package , class file locator class file locator ) { return rebase ( new package description . for loaded package ( a package ) , class file locator ) ; }
public void set component type ( q name component type ) { this . component type = component type ; }
public resource get archive ( ) { return be reference ( ) ? ( ( archive resource ) get check ref ( ) ) . get archive ( ) : archive ; }
public input stream get input stream ( ) { return input stream ; }
public static i o file filter not file filter ( final i o file filter filter ) { return filter . negate ( ) ; }
public static < t extend real field element < t > > field vector3 d < t > apply inverse to ( final rotation r , final field vector3 d < t > u ) { final t x = u . get x ( ) ; final t y = u . get y ( ) ; final t z = u . get z ( ) ; final t s = x . multiply ( r . get q1 ( ) ) . add ( y . multiply ( r . get q2 ( ) ) ) . add ( z . multiply ( r . get q3 ( ) ) ) ; final double m0 = -r . get q0 ( ) ; return new field vector3 d < t > ( x . multiply ( m0 ) . subtract ( z . multiply ( r . get q2 ( ) ) . subtract ( y . multiply ( r . get q3 ( ) ) ) ) . multiply ( m0 ) . add ( s . multiply ( r . get q1 ( ) ) ) . multiply ( 2 ) . subtract ( x ) , y . multiply ( m0 ) . subtract ( x . multiply ( r . get q3 ( ) ) . subtract ( z . multiply ( r . get q1 ( ) ) ) ) . multiply ( m0 ) . add ( s . multiply ( r . get q2 ( ) ) ) . multiply ( 2 ) . subtract ( y ) , z . multiply ( m0 ) . subtract ( y . multiply ( r . get q1 ( ) ) . subtract ( x . multiply ( r . get q2 ( ) ) ) ) . multiply ( m0 ) . add ( s . multiply ( r . get q3 ( ) ) ) . multiply ( 2 ) . subtract ( z ) ) ; }
public field vector3 d < t > apply inverse to ( final field vector3 d < t > u ) { final t x = u . get x ( ) ; final t y = u . get y ( ) ; final t z = u . get z ( ) ; final t s = q1 . multiply ( x ) . add ( q2 . multiply ( y ) ) . add ( q3 . multiply ( z ) ) ; final t m0 = q0 . negate ( ) ; return new field vector3 d < t > ( m0 . multiply ( x . multiply ( m0 ) . subtract ( q2 . multiply ( z ) . subtract ( q3 . multiply ( y ) ) ) ) . add ( s . multiply ( q1 ) ) . multiply ( 2 ) . subtract ( x ) , m0 . multiply ( y . multiply ( m0 ) . subtract ( q3 . multiply ( x ) . subtract ( q1 . multiply ( z ) ) ) ) . add ( s . multiply ( q2 ) ) . multiply ( 2 ) . subtract ( y ) , m0 . multiply ( z . multiply ( m0 ) . subtract ( q1 . multiply ( y ) . subtract ( q2 . multiply ( x ) ) ) ) . add ( s . multiply ( q3 ) ) . multiply ( 2 ) . subtract ( z ) ) ; }
public t get ( ) { return t ; }
public int update ( long p1 , long p2 ) throw data access exception { return update ( new object [ ] { p1 , p2 } ) ; }
public string get protocol ( ) { return protocol ; }
public boolean try read element from xml ( ews service xml reader reader ) throw exception { if ( reader . get local name ( ) . equal ignore case ( xml element name . mailbox ) ) { this . load from xml ( reader , reader . get local name ( ) ) ; return true ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . response type ) ) { this . response type = reader . read element value ( meet response type . class ) ; return true ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . last response time ) ) { this . last response time = reader . read element value a date time ( ) ; return true ; } else { return super . try read element from xml ( reader ) ; } }
public boolean try read element from xml ( ews service xml reader reader ) throw exception { if ( reader . get local name ( ) . equal ignore case ( xml element name . mailbox ) ) { this . load from xml ( reader , reader . get local name ( ) ) ; return true ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . response type ) ) { this . response type = reader . read element value ( meet response type . class ) ; return true ; } else if ( reader . get local name ( ) . equal ignore case ( xml element name . last response time ) ) { this . last response time = reader . read element value a date time ( ) ; return true ; } else { return super . try read element from xml ( reader ) ; } }
protect static protocol connection load from xml ( ews xml reader reader ) throw exception { protocol connection connection = new protocol connection ( ) ; do { reader . read ( ) ; if ( reader . get node type ( ) . get node type ( ) == xml node type . start_element ) { if ( reader . get local name ( ) . equal ( xml element name . encryption method ) ) { connection . set encryption method ( reader . read element value ( string . class ) ) ; } else if ( reader . get local name ( ) . equal ( xml element name . hostname ) ) { connection . set hostname ( reader . read element value ( string . class ) ) ; } else if ( reader . get local name ( ) . equal ( xml element name . port ) ) { connection . set port ( reader . read element value ( int . class ) ) ; } } } while ( ! reader . be end element ( xml namespace . autodiscover , xml element name . protocol connection ) ) ; return connection ; }
public rule operation error collection get error ( ) { return this . error ; }
public void set folder id ( string folder id ) { this . folder id = folder id ; }
protect t end internal execute ( i async result async result ) throw exception { http web request response = ( http web request ) async result . get ( ) ; return this . read response ( response ) ; }
public date get meeting time ( ) { return meeting time ; }
public void delete ( delete mode delete mode , send cancellation mode send cancellation mode ) throw exception { this . internal delete ( delete mode , send cancellation mode , null ) ; }
public object writer with view ( class < ? > view ) { return _new ( this , _config . with view ( view ) ) ; }
public void set destination folder id ( folder id destination folder id ) { this . destination folder id = destination folder id ; }
public void set send invitation or cancellation mode ( send invitation or cancellation mode value ) { this . send invitation or cancellation mode = value ; }
public void set mode ( string mode ) { this . mode = mode ; }
public occurrence info collection get modify occurrence ( ) throw service local exception { return get property bag ( ) . get object from property definition ( appointment schema . modified occurrence ) ; }
public item id get item id ( ) { return this . item id ; }
public void clear notification event ( ) { on notification event . clear ( ) ; }
protect void validate update delegate ( ) throw service validation exception { for ( delegate folder permission delegate folder permission : this . delegate folder permission . value ( ) ) { if ( delegate folder permission . get permission level ( ) == delegate folder permission level . custom & & ! delegate folder permission . be exist permission level custom ) { throw new service validation exception ( `` this operation ca n't be perform because one or more folder `` + `` permission level be set to custom . `` ) ; } } }
protect service object type get service object type ( ) { return service object type . item ; }
protect void internal add or replace ( t entry entry ) { t entry old entry ; if ( this . entry . contains key ( entry . get key ( ) ) ) { old entry = this . entry . get ( entry . get key ( ) ) ; old entry . remove change event ( this ) ; entry . add on change event ( this ) ; if ( ! this . added entry . contains ( entry . get key ( ) ) ) { if ( ! this . modified entry . contains ( entry . get key ( ) ) ) { this . modified entry . add ( entry . get key ( ) ) ; } } this . change ( ) ; } else { this . internal add ( entry ) ; } }
public void set value ( string value ) { assert not null ( value ) ; this . value = value ; }
protect node get parameter ( ) { return xml node ; }
public void set session ( session session ) { this . session = session ; }
public select set lock mode ( lock mode lock mode ) { lock option . set lock mode ( lock mode ) ; return this ; }
public method parameter get method parameter ( ) { return this . parameter ; }
public access get access ( ) { return this . access ; }
public object id generator < ? > object id generator instance ( mapper config < ? > config , annotate annotate , class < ? > impl class ) { return null ; }
public value instantiator value instantiator instance ( mapper config < ? > config , annotate annotate , class < ? > resolver class ) { return null ; }
public static annotation [ ] get filtering annotation ( final annotation [ ] annotation ) { if ( annotation == null || annotation . length == 0 ) { return filter helper . empty_annotations ; } final list < annotation > filtering annotation = new array list < > ( annotation . length ) ; for ( final annotation annotation : annotation ) { final class < ? extend annotation > annotation type = annotation . annotation type ( ) ; for ( final annotation meta annotation : annotation type . get declared annotation ( ) ) { if ( meta annotation instanceof entity filter ) { filter annotation . add ( annotation ) ; } } } return filter annotation . to array ( new annotation [ filter annotation . size ( ) ] ) ; }
public deserialization config get deserialization config ( ) { return _deserialization config ; }
public bean description get bean description ( class < ? > clazz ) { if ( ! class to bean description . contains key ( clazz ) ) { bean description bean description = get bean description factory ( ) . create ( clazz ) ; class to bean description . put ( clazz , bean description ) ; } return class to bean description . get ( clazz ) ; }
public json deserializer < t > unwrapping deserializer ( name transformer unwrapper ) { return this ; }
public json token a token ( ) { return json token . value_number_int ; }
public int get upper bound byte ( ) { return this . upper bound byte ; }
public type get return type ( ) { return internal get return type ( ) ; }
public void set class pool ( class pool loader ) { class pool = loader ; }
public final void set transaction synchronization ( int transaction synchronization ) { this . transaction synchronization = transaction synchronization ; }
public u r i builder with scheme ( string scheme ) { return new u r i builder ( optional . of nullable ( scheme ) , scheme specific part , host , port , path , fragment , parameter , be path absolute , end with slash ) ; }
public string get ref ( ) { return ref ; }
public void set object checker ( object checker impl ) { object checker = impl ; }
public void set manager ( string manager ) { this . manager = manager ; }
public string get configuration ( ) { return this . configuration ; } // -- string get configuration ( )
public boolean evaluate ( long t1 , long t2 ) { return evaluate ( t1 , t2 , file_utils . get file timestamp granularity ( ) ) ; }
public http header get header ( ) { return this . header ; }
public logger get logger ( ) { return logger ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public final void add first ( byte buf buf , channel promise promise ) { add first ( buf , to channel future listener ( promise ) ) ; }
public boolean be trace enable ( ) { return ( get logger ( ) . be loggable ( level . fine ) ) ; }
final public static string basic array format ( final string message pattern , final object [ ] arg array ) { format tuple ft = array format ( message pattern , arg array , null ) ; return ft . get message ( ) ; }
public void error ( string msg , throwable t ) { logger . log ( fqcn , level . error , msg , t ) ; }
public void debug ( string msg ) { logger . log ( fqcn , level . debug , msg , null ) ; }
public void set level ( int level ) { this . level = level ; }
public level get level ( ) { return level ; }
public string get protocol ( ) { return protocol ; }
protect void configure ssl ( ssl context factory . server factory , ssl ssl , ssl store provider ssl store provider ) { factory . set protocol ( ssl . get protocol ( ) ) ; configure ssl client auth ( factory , ssl ) ; configure ssl password ( factory , ssl ) ; factory . set cert alias ( ssl . get key alias ( ) ) ; if ( ! object utils . be empty ( ssl . get cipher ( ) ) ) { factory . set include cipher suite ( ssl . get cipher ( ) ) ; factory . set exclude cipher suite ( ) ; } if ( ssl . get enabled protocol ( ) ! = null ) { factory . set include protocol ( ssl . get enabled protocol ( ) ) ; } if ( ssl store provider ! = null ) { try { factory . set key store ( ssl store provider . get key store ( ) ) ; factory . set trust store ( ssl store provider . get trust store ( ) ) ; } catch ( exception ex ) { throw new illegal state exception ( `` unable to set ssl store `` , ex ) ; } } else { configure ssl key store ( factory , ssl ) ; configure ssl trust store ( factory , ssl ) ; } }
public long ticket key fail ( ) { lock reader lock = context . ctx lock . read lock ( ) ; reader lock . lock ( ) ; try { return s s l context . session ticket key fail ( context . ctx ) ; } finally { reader lock . unlock ( ) ; } }
public long accept renegotiate ( ) { lock reader lock = context . ctx lock . read lock ( ) ; reader lock . lock ( ) ; try { return s s l context . session accept renegotiate ( context . ctx ) ; } finally { reader lock . unlock ( ) ; } }
public list < certificate > peer certificate ( ) { return peer certificate ; }
public long get size max ( ) { return size max ; }
public cherry pick command set progress monitor ( progress monitor monitor ) { if ( monitor == null ) { monitor = null progress monitor . instance ; } this . monitor = monitor ; return this ; }
public int get connect timeout ( ) { return connect timeout ; }
public file get file ( ) { return file ; }
public static boolean min length ( string value , int min ) { return ( value . length ( ) > = min ) ; }
public void add all ( promise . . . promise ) { add all ( ( future [ ] ) promise ) ; }
public byte [ ] get byte ( ) { return byte ; }
public string id ( ) { return id ; }
public static short lookup index by name ( string name ) { function metadata fd = get instance ( ) . get function by name internal ( name ) ; if ( fd == null ) { return -1 ; } return ( short ) fd . get index ( ) ; }
public void set count ( int count ) { this . count = count ; }
public algorithm get algorithm ( ) { return algorithm ; }
public byte [ ] encode ( final byte buffer array ) { return encode hex string ( array ) . get byte ( this . get charset ( ) ) ; }
public authentication builder add custom ( authentication authentication ) { if ( authentication ! = null ) { authentication . add ( authentication ) ; } return this ; }
static public byte [ ] encode ( byte [ ] binary data ) { if ( binary data == null ) return null ; int length data = binary data . length ; int length encode = length data * 2 ; byte [ ] encode data = new byte [ length encode ] ; for ( int i = 0 ; i < length data ; i++ ) { encode data [ i * 2 ] = look up hex alphabet [ ( binary data [ i ] > > 4 ) & 0xf ] ; encode data [ i * 2+1 ] = look up hex alphabet [ binary data [ i ] & 0xf ] ; } return encoded data ; }
public static boolean iterator concat ( final boolean iterator a [ ] ) { return concat ( a , 0 , a . length ) ; }
public boolean equal ( final object o ) { if ( this == o ) return true ; if ( value == null ) return false ; if ( ! ( o instanceof secret ) ) return false ; secret other secret = ( secret ) o ; return equal s h a256 base ( other secret ) ; }
protect void verify iteration count ( ) throw illegal argument exception { if ( ( minimal iteration count < = 0 ) || ( maximal iteration count < = minimal iteration count ) ) { throw math runtime exception . create illegal argument exception ( `` invalid iteration limit : min= { 0 } , max= { 1 } `` , minimal iteration count , maximal iteration count ) ; } }
public string get provider ( ) { return provider ; }
public string get u r l ( ) { return service . get u r l ( ) ; }
public string key ( ) { return key ; }
public string key ( ) { return key ; }
protect byte [ ] generate key ( string pas phrase ) { byte encode byte array [ ] = character encode string ( pass phrase ) ; byte pad byte array [ ] = pad string ( encoded byte array ) ; byte [ ] secret key = fan fold ( pad byte array ) ; secret key = set parity ( secret key ) ; secret key = get strong key ( secret key ) ; secret key = calculate checksum ( pad byte array , secret key ) ; secret key = set parity ( secret key ) ; secret key = get strong key ( secret key ) ; return secret key ; }
public byte [ ] get signature ( ) { return signature ; }
public string get expect ( ) { return f expect ; }
public static set < string > get registered parameter name ( ) { return registered_parameter_names ; }
public j s o n object to j s o n object ( ) { return to j s o n object ( true ) ; }
public set < j w s algorithm > get j w s algorithm ( ) { return jws algs ; }
public output < long > decode value ( ) { return decode value ; }
public static object add array ( object list , object [ ] array ) { for ( int i = 0 ; array ! = null & & i < array . length ; i++ ) { list = lazy list . add ( list , array [ i ] ) ; } return list ; }
public void set endpoint address ( @ nullable string endpoint address ) { this . endpoint address = endpoint address ; }
public void set endpoint address ( @ nullable string endpoint address ) { this . endpoint address = endpoint address ; }
public void set endpoint address ( @ nullable string endpoint address ) { this . endpoint address = endpoint address ; }
public response mode get response mode ( ) { return rm ; }
public set < j w s algorithm > get j w s algorithm ( ) { return jws algs ; }
protect void set base u r i ( parse u r i base u r i ) { this . base u r i = base u r i ; }
public void set t l s client certificate bound access token ( final boolean tl client cert bound token ) { tls client certificate bound access token = tls client cert bound tokens ; }
public long get incremental size ( ) { return incremental size ; }
public date time to date time i s o ( ) { return new date time ( get millis ( ) , i s o chronology . get instance ( get zone ( ) ) ) ; }
public set < j w s algorithm > get j w s algorithm ( ) { return jws algs ; }
protect final list < d c subject > parse subject ( final list < element > e list ) { final list < d c subject > subject = new array list < d c subject > ( ) ; for ( final element e subject : e list ) { final element description = e subject . get child ( `` description `` , get r d f namespace ( ) ) ; if ( description ! = null ) { final string taxonomy = get taxonomy ( description ) ; final list < element > value = description . get child ( `` value `` , get r d f namespace ( ) ) ; for ( final element value : value ) { final d c subject subject = new d c subject impl ( ) ; subject . set taxonomy uri ( taxonomy ) ; subject . set value ( value . get text ( ) ) ; subject . add ( subject ) ; } } else { final d c subject subject = new d c subject impl ( ) ; subject . set value ( e subject . get text ( ) ) ; subject . add ( subject ) ; } } return subject ; }
public static final rev filter before ( date t ) { return before ( t . get time ( ) ) ; }
public void set external delegation token secret manager ( abstract delegation token secret manager secret manager ) { this . secret manager . stop thread ( ) ; this . secret manager = secret manager ; manage secret manager = false ; }
public string get client x509 certificate root d n ( ) { return client x509 certificate root d n ; }
public audience get audience ( ) { return audience ; }
public u r i builder add parameter ( iterable < query param > new params ) { if ( ! new params . iterator ( ) . have next ( ) ) { return this ; } query params update = this . parameter . add ( new params ) ; return with parameter ( update ) ; }
public uri get post logout redirection u r i ( ) { return post logout redirect u r i ; }
public jwt consumer builder set require jwt id ( ) { this . require jti = true ; return this ; }
public string get mode ( ) { return mode ; }
public void set number of success ( int success ) { set number of success internal ( success ) ; }
public authorization success response to success response ( ) { return ( authorization success response ) this ; }
public static set < error object > get standard error ( ) { return standard_errors ; }
public string get auth type ( ) { return this . auth type ; }
public boolean add token ( token < ? extend token identifier > token ) { return ( token ! = null ) ? add token ( token . get service ( ) , token ) : false ; }
public void set render hint ( map hint ) { render hint = hint ; }
public list < resource model issue > get issue list ( ) { return issue list ; }
public void set scope ( final scope scope ) { this . scope = scope ; }
public void set scope ( string scope ) { this . scope = scope ; }
public void set request object j w e enc ( final encryption method request object j w e enc ) { this . request object j w e enc = request object j w e enc ; }
public encryption method get request object j w e enc ( ) { return request object j w e enc ; }
public void set software agent ( string software ) { x m l util . set string value ( parent , `` st evt : software agent `` , software ) ; }
public void set support t l s client certificate bound access token ( final boolean tl client cert bound token ) { tls client certificate bound access token = tls client cert bound tokens ; }
public list < string > get san list ( ) { return san list ; }
public string to j s o n string ( ) { return to j s o n string ( this , j s o n value . compression ) ; }
public @ nullable response < ? > response ( ) { return response ; }
public static set < error object > get standard error ( ) { return standard_errors ; }
public static status http status to grpc status ( int http status code ) { return http status to grpc code ( http status code ) . to status ( ) . with description ( `` http status code `` + http status code ) ; }
public client i d to client i d ( ) { return new client i d ( get value ( ) ) ; }
public request < ? > get request ( ) { return request ; }
public method get method ( ) { return this . method ; }
public final void set connect timeout millis ( long connect timeout millis ) { if ( connect timeout millis < = 0 ) { connect timeout millis = 0 ; } this . connect timeout millis = connect timeout millis ; }
public int get read timeout ( ) { return this . read timeout ; }
public x509 certificate get client x509 certificate ( ) { return certificate ; }
public request < ? > get request ( ) { return request ; }
public audience get audience ( ) { return audience ; }
public long long value ( ) { return value ; }
public void set request object j w s algs ( final list < j w s algorithm > request object j w s algs ) { this . request object j w s algs = request object j w s algs ; }
public boolean be custom ( string key ) { return ( get state ( key ) == state . custom ) ; }
public string uri ( ) { return uri ; }
public static boolean be asterisk form ( uri uri ) { return `` * `` . equal ( uri . get path ( ) ) & & uri . get scheme ( ) == null & & uri . get scheme specific part ( ) == null & & uri . get host ( ) == null & & uri . get authority ( ) == null & & uri . get query ( ) == null & & uri . get fragment ( ) == null ; }
public final void configure region ( region region ) { check mutability ( ) ; if ( region == null ) throw new illegal argument exception ( `` no region provide `` ) ; this . set region ( region . get region ( region ) ) ; }
public void set bundle country ( string bundle country ) { this . bundle country = bundle country ; }
public static boolean be valid name for component ( string component ) { if ( component . equal ( `` . `` ) || component . equal ( `` . . `` ) || component . index of ( `` : `` ) > = 0 || component . index of ( `` / `` ) > = 0 ) { return false ; } return ! be reserve path component ( component ) ; }
public void add user info claim ( final string claim name ) { add user info claim ( claim name , claim requirement . voluntary ) ; }
public string get policy name ( ) { return policy name ; }
public type get type ( ) { return type ; }
public void set q ( int q ) { get c o s object ( ) . set int ( c o s name . q , q ) ; }
public j s o n object to j s o n object ( ) { return to j s o n object ( true ) ; }
public j s o n object to j s o n object ( ) { return to j s o n object ( true ) ; }
public date time zone get time zone ( ) { return this . time zone ; }
public method get method ( ) { return method ; }
public static set < error object > get standard error ( ) { return standard_errors ; }
public void add user info claim ( final string claim name ) { add user info claim ( claim name , claim requirement . voluntary ) ; }
public j s o n object convert to j s o n object ( string json string ) { j s o n parser parser = new j s o n parser ( ) ; j s o n object json object = new j s o n object ( ) ; try { json object = ( j s o n object ) parser . parse ( json string ) ; } catch ( exception e ) { log . info ( e . get message ( ) , e ) ; } return json object ; }
public static fast date format get date time instance ( final int date style , final int time style , final time zone time zone ) { return get date time instance ( date style , time style , time zone , null ) ; }
public set < string > get verify i d token claim name ( final boolean with lang tag ) { return get claim name ( verify i d token claim , with lang tag ) ; }
public set < string > get i d token claim name ( final boolean with lang tag ) { return get claim name ( id token claim , with lang tag ) ; }
public o i d c claim request with user info claim request ( final claim set request user info ) { return new o i d c claim request ( get i d token claim request ( ) , user info , get i d token verify claim request ( ) , get user info verify claim request ( ) ) ; }
public set < string > get i d token claim name ( final boolean with lang tag ) { return get claim name ( id token claim , with lang tag ) ; }
public @ nullable response < ? > response ( ) { return response ; }
public audience get audience ( ) { return aud ; }
public void set anchor type ( anchor type anchor type ) { _escher client anchor . set flag ( anchor type . value ) ; }
public boolean require client i d ( ) { return require client i d ; }
public collection < metadata > get metadata ( ) { return metadata ; }
public constraint find constraint ( session session , string name ) { constraint constraint = constraint . get ( name ) ; if ( constraint == null ) { constraint = session . find local temp table constraint ( name ) ; } return constraint ; }
public string get namespace u r i ( ) { return name pool . get u r i from u r i code ( uri code ) ; }
public path get path ( ) { return path ; }
public string get entity ( ) { return entity ; }
public uri get redirection u r i ( ) { return redirect u r i ; }
public void add user info claim ( final string claim name ) { add user info claim ( claim name , claim requirement . voluntary ) ; }
public o i d c claim request with user info claim request ( final claim set request user info ) { return new o i d c claim request ( get i d token claim request ( ) , user info , get i d token verify claim request ( ) , get user info verify claim request ( ) ) ; }
public acr get subject a c r ( ) { return subject a c r ; }
public j w e algorithm get user info j w e alg ( ) { return user info j w e alg ; }
public final web application context get web application context ( ) { return this . web application context ; }
public static set < string > get registered parameter name ( ) { return registered_parameter_names ; }
public void set user info j w e alg ( final j w e algorithm user info j w e alg ) { this . user info j w e alg = user info j w e alg ; }
public j w e algorithm get user info j w e alg ( ) { return user info j w e alg ; }
public uri get post logout redirection u r i ( ) { return post logout redirect u r i ; }
public void set session ( session session ) { this . session = session ; }
public static data output stream new data output stream ( file file ) throw i o exception { return new data output stream ( new file output stream ( file ) ) ; }
public final boolean equal ( final set < ? > o ) { return o == this || o . contain all ( this ) & & contain all ( o ) ; }
public int get execute count ( ) { return execute count ; }
public int connection count ( ) { return delegate . connection count ( ) ; }
public file certificate ( ) { return certificate ; }
public list < certificate > peer certificate ( ) { return peer certificate ; }
public int [ ] get value ( ) { int [ ] result = new int [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get value ( i ) ; } return result ; }
@ override public void flush ( ) throw i o exception { delegate . flush ( ) ; }
public void send connection preface ( ) throw i o exception { frame writer . connection preface ( ) ; frame writer . setting ( ok http setting ) ; int window size = ok http setting . get initial window size ( setting . default_initial_window_size ) ; if ( window size ! = setting . default_initial_window_size ) { frame writer . window update ( 0 , window size - setting . default_initial_window_size ) ; } }
public string source ( ) { return source ; }
public source get source ( ) { return source ; }
public long round trip time ( ) throw interrupted exception { latch . await ( ) ; return receive - sent ; }
public boolean have next ( ) { return have next inet socket address ( ) || have next proxy ( ) || have next postpone ( ) ; }
public string get type ( ) { return type ; }
public void set charset ( charset charset ) { assert . not null ( charset , `` charset must not be null `` ) ; this . charset = charset ; }
public string get value ( ) { return value ; }
public void set http only ( boolean http only ) { this . http only = http only ; }
public long size ( ) { return size ; }
public void send connection preface ( ) throw i o exception { frame writer . connection preface ( ) ; frame writer . setting ( ok http setting ) ; int window size = ok http setting . get initial window size ( setting . default_initial_window_size ) ; if ( window size ! = setting . default_initial_window_size ) { frame writer . window update ( 0 , window size - setting . default_initial_window_size ) ; } }
public long round trip time ( ) throw interrupted exception { latch . await ( ) ; return receive - sent ; }
public boolean have next ( ) { return have next inet socket address ( ) || have next proxy ( ) || have next postpone ( ) ; }
public void set in stream ( in stream stream ) { this . stream = stream ; }
public static cache control empty ( ) { return new cache control ( ) ; }
public call get call ( ) { return call ; }
public void response body end ( call call , long byte count ) { }
public void request body end ( call call , long byte count ) { }
public void on failure ( web socket web socket , throwable t , @ nullable response response ) { }
public void on closing ( web socket web socket , int code , string reason ) { }
public synchronize int get http connection count ( ) { return connection . size ( ) - get multiplexed connection count ( ) ; }
public final void cancel ( ) { super . cancel ( ) ; }
public int get read timeout millis ( ) { return read timeout millis ; }
public string get charset ( ) { return charset ; }
public long get size ( ) { return size ; }
public static hash function hmac md5 ( byte [ ] key ) { return hmac md5 ( new secret key spec ( check not null ( key ) , `` hmac m d5 `` ) ) ; }
public byte [ ] hmac ( final byte [ ] value to digest ) { return mac . do final ( value to digest ) ; }
public string get type ( ) { return type ; }
public void set interval ( long interval ) { this . interval = interval ; }
public void set max age in second ( long max age in second ) { assert . be true ( max age in second > 0 , ( ) - > `` max age in second must be non-negative . get `` + max age in second ) ; this . max age in second = max age in second ; update hpkp header value ( ) ; }
public static string replace ( string value , string key , string replace value ) { if ( value == null || key == null || replace value == null ) { return value ; } int po = value . index of ( key ) ; if ( pos < 0 ) { return value ; } int length = value . length ( ) ; int start = po ; int end = po + key . length ( ) ; if ( length == key . length ( ) ) { value = replace value ; } else if ( end == length ) { value = value . substring ( 0 , start ) + replace value ; } else { value = value . substring ( 0 , start ) + replace value + replace ( value . substring ( end ) , key , replace value ) ; } return value ; }
public @ nullable response < ? > response ( ) { return response ; }
public dependency resolver get resolver ( ) { return resolver ; }
public redirect config max redirects ( int value ) { return new redirect config ( follow redirects , allow circular redirects , reject relative redirect , value , true ) ; }
public void set type ( int type ) { this . type = type ; }
public string key ( ) { return key ; }
public parameter list get parameter ( ) { return _parameters ; }
public void set require parameter name ( string require parameter name ) { this . require parameter name = require parameter name ; }
public void set type uri ( string type uri ) { _type uri = type uri ; }
public alias add to alias object extension ( final abstract object alias object extension ) { this . get alias object extension ( ) . add ( alias object extension ) ; return this ; }
public io . vertx . axle . core . http . cookie set max age ( long max age ) { delegate . set max age ( max age ) ; return this ; }
public date get timestamp ( ) { return timestamp ; }
public string uri ( ) { return uri ; }
public parameter list get parameter ( ) { return _parameters ; }
public void level ( level level ) { this . level = object . require non null ( level , `` level must not be null `` ) ; }
public element attr ( string attribute key , string attribute value ) { for ( element element : this ) { element . attr ( attribute key , attribute value ) ; } return this ; }
public void set rp ( int rp ) { this . rp = rp ; }
public void set timeout ( time value timeout ) { this . timeout = timeout ; }
public list < j a x b element < representation type > > get representation or fault ( ) { if ( representation or fault == null ) { representation or fault = new array list < j a x b element < representation type > > ( ) ; } return this . representation or fault ; }
public boolean be true ( ) { return value == true ; }
protect string list get category ( ) { return this . category ; }
public boolean be handle ( ) { return true ; }
public string [ ] get command ( ) { return command ; }
public void set parameter id ( int id ) { parameter id = id ; }
public command get command ( final string command id ) { check id ( command id ) ; command command = ( command ) handle object by id . get ( command id ) ; if ( command == null ) { command = new command ( command id ) ; command . should fire event = should command fire event ; handle object by id . put ( command id , command ) ; command . add command listener ( this ) ; if ( execution listener ! = null ) { command . add execution listener ( execution listener ) ; } } return command ; }
public throwable init cause ( throwable cause ) { this . cause = cause ; return this ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public void define ( final string name , final string description , final category category ) { define ( name , description , category , null ) ; }
public void set label ( name label ) { this . label = label ; if ( label ! = null ) label . set parent ( this ) ; }
public boolean match ( i undo context context ) { return context == this ; }
public list < operation > static operation ( ) { return static operation ; }
public void set context ( string context ) { if ( context . start with ( `` / `` ) ) { this . context = context ; } else { this . context = `` / `` + context ; } }
public void add match ( i undo context context ) { child . add ( context ) ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public final string id ( ) { return id ; }
public static int compare to ( character leave , number right ) { return compare to ( integer . value of ( leave ) , right ) ; }
public static boolean be valid compress buffer ( byte [ ] input , int offset , int length ) throw i o exception { if ( input == null ) throw new null pointer exception ( `` input be null `` ) ; return impl . be valid compress buffer ( input , offset , length ) ; }
public int hash code ( ) { return to string ( ) . hash code ( ) ; }
public string get expression ( ) { return expression ; }
public string get expression ( ) { return expression ; }
public void set variable ( variable declaration variable ) { assert not null ( variable ) ; this . variable = variable ; variable . set parent ( this ) ; }
public void set content type ( string content type ) { assert . not null ( content type , `` 'content type ' must not be null `` ) ; this . content type = content type ; }
public model add to model simple extension ( final object model simple extension ) { this . get model simple extension ( ) . add ( model simple extension ) ; return this ; }
public location get location ( ) { return this . location ; }
public file store get file store ( ) { return file store ; }
public void set ( boolean value ) { this . value = value ; }
public void set name ( string name ) { this . name = name ; }
protect void grow ( ) { object [ ] expand = new object [ element . length + grow_size ] ; system . arraycopy ( element , 0 , expand , 0 , element . length ) ; element = expand ; }
public void add change listener ( final property change listener listener ) { change support . add property change listener ( listener ) ; }
public void set system ( string system ) { this . system = system ; } // -- void set system ( string )
public void cancel ( iterable < s s table reader > cancel ) { for ( s s table reader cancel : cancel ) cancel ( cancel ) ; }
public boolean be lock ( ) { return owner ! = null ; }
public node get parent ( ) { return parent ; }
public final void configure region ( region region ) { check mutability ( ) ; if ( region == null ) throw new illegal argument exception ( `` no region provide `` ) ; this . set region ( region . get region ( region ) ) ; }
public node get parent ( ) { return parent ; }
public string get unique id ( ) { return unique id ; }
protect resource get resource by path ( string path ) { if ( path ! = null & & path . start with ( `` / `` ) ) { path = path . substring ( 1 ) ; } return new file system resource ( path ) ; }
public string get namespace u r i ( ) { return name pool . get u r i from u r i code ( uri code ) ; }
public static final source of ( file file ) { return new source ( null , null , null , null , null , null , null , file ) ; }
public cherry pick command set progress monitor ( progress monitor monitor ) { if ( monitor == null ) { monitor = null progress monitor . instance ; } this . monitor = monitor ; return this ; }
public void clear ( ) { target . clear ( ) ; }
public location get location ( ) { return this . location ; }
protect void grow ( ) { object [ ] expand = new object [ element . length + grow_size ] ; system . arraycopy ( element , 0 , expand , 0 , element . length ) ; element = expand ; }
public static marker get marker ( final string name , final marker parent ) { return get marker ( name ) . add parent ( parent ) ; }
public string type ( ) { return type ; }
public static < t > t arg that ( matcher < t > matcher ) { report matcher ( matcher ) ; return ( t ) default value ( generic type of matcher ( matcher . get class ( ) ) ) ; }
public string get id ( ) { return id ; }
public boolean be set ( int mask ) { return ( attribute & mask ) ! = 0 ; }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public byte [ ] get ( ) { return info ; }
protect void initialize ( data tree node root node ) { / * create the implicit root node * / initialize ( new delta data tree ( new data tree node ( null , null , new abstract data tree node [ ] { root node } ) ) ) ; }
public int num data node ( ) { return num data node ( root node ) ; }
public void set project ( final string project ) { super . set project ( project ) ; }
public model map get default model ( ) { return this . default model ; }
public f status get status ( ) throw i o exception { return get status ( null ) ; }
public i progress monitor get wrap progress monitor ( ) { return progress monitor ; }
public void set read only ( boolean read only ) { set ( efs . attribute_read_only , read only ) ; }
public void set ( int mask ) { flags |= mask ; }
public boolean be read only ( ) { return ( attribute & efs . attribute_read_only ) ! = 0 ; }
public void remove variable ( string name ) { if ( null == variable ) { return ; } variable . remove ( name ) ; }
public void add change listener ( final property change listener listener ) { change support . add property change listener ( listener ) ; }
public string get default string ( string name ) { return get default preference ( ) . get ( name , string_default_default ) ; }
public double value ( ) { return value ; }
protect float get number ( string name , float default value ) { return this . get c o s object ( ) . get float ( name , default value ) ; }
public string get default string ( string name ) { return get default preference ( ) . get ( name , string_default_default ) ; }
public int get default int ( string name ) { return get default preference ( ) . get int ( name , int_default_default ) ; }
public string get default string value ( ) { return default string value ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public stats response stats ( stats request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , enrich request converter : : stats , option , stats response : : from x content , collection . empty set ( ) ) ; }
public log event to serializable ( final log event event ) { return event ; }
public void run ( ) { this . delegate . run ( ) ; }
public static bundle [ ] get host ( bundle bundle ) { return internal platform . get default ( ) . get host ( bundle ) ; }
public final i log get log ( ) { return internal platform . get default ( ) . get log ( get bundle ( ) ) ; }
public final o get o s ( ) { return o ; }
public static application type get default ( ) { return web ; }
public static bundle [ ] get host ( bundle bundle ) { return internal platform . get default ( ) . get host ( bundle ) ; }
public bundle get bundle ( ) { return bundle ; }
public static i log get log ( bundle bundle ) { return internal platform . get default ( ) . get log ( bundle ) ; }
public input stream get input stream ( ) throw i o exception { return url . open stream ( ) ; }
public string get configuration ( ) { return this . configuration ; } // -- string get configuration ( )
public final class get element type ( ) { return this . element type ; }
public void set manager ( string manager ) { this . manager = manager ; }
public void set manager ( string manager ) { this . manager = manager ; }
protect i workspace root get workspace root ( ) { return resource plugin . get workspace ( ) . get root ( ) ; }
protect void fire event ( debug event event ) { debug plugin . get default ( ) . fire debug event set ( new debug event [ ] { event } ) ; }
public byte get flag ( ) { return flag ; }
public change get change ( ) { return f change ; }
public static big integer to big integer ( number self ) { if ( self instanceof big integer ) { return ( big integer ) self ; } else if ( self instanceof big decimal ) { return ( ( big decimal ) self ) . to big integer ( ) ; } else if ( self instanceof double ) { return new big decimal ( ( double ) self ) . to big integer ( ) ; } else if ( self instanceof float ) { return new big decimal ( ( float ) self ) . to big integer ( ) ; } else { return new big integer ( long . to string ( self . long value ( ) ) ) ; } }
public configuration get configuration ( ) { return config ; }
public container get container ( ) { return container ; }
public file get file ( ) { return file ; }
public string get attribute value ( string attr ) { return get parameter value ( attr ) ; }
public static object build ( list < object > key element ) { if ( key element == null || key element . be empty ( ) ) { throw new illegal argument exception ( `` at least one key element be require to build a cache key `` ) ; } else if ( key element . size ( ) == 1 ) { if ( key element . get ( 0 ) == null ) { throw new null pointer exception ( null_keys_not_supported_msg ) ; } return key element . get ( 0 ) ; } else { return new composite cache key ( key element ) ; } }
public boolean be whitespace visible ( ) { return whitespace visible ; }
public json structure get root structure ( ) { return root ; }
public void set file ( file file ) { this . file = file ; }
protect void set attribute ( final string attribute name , final int value ) throw core exception { i workspace workspace= resource plugin . get workspace ( ) ; i workspace runnable runnable= monitor - > ensure marker ( ) . set attribute ( attribute name , value ) ; workspace . run ( runnable , get marker rule ( ) , i workspace . avoid_update , null ) ; }
public void fire suspend event ( int detail ) { fire event ( new debug event ( this , debug event . suspend , detail ) ) ; }
public void add log listener ( i log listener listener ) { synchronize ( log listener ) { log listener . add ( listener ) ; } }
public path get path ( ) { return path ; }
public cherry pick command set progress monitor ( progress monitor monitor ) { if ( monitor == null ) { monitor = null progress monitor . instance ; } this . monitor = monitor ; return this ; }
public string get path ( ) { return path ; }
public static url create u r l ( string path ) throw malformed u r l exception { return new url ( generate u r l ( path ) ) ; }
public static string extract file extension ( string path ) { int end = path . index of ( ' ? ' ) ; int fragment index = path . index of ( ' # ' ) ; if ( fragment index ! = -1 & & ( end == -1 || fragment index < end ) ) { end = fragment index ; } if ( end == -1 ) { end = path . length ( ) ; } int begin = path . last index of ( '/ ' , end ) + 1 ; int param index = path . index of ( ' ; ' , begin ) ; end = ( param index ! = -1 & & param index < end ? param index : end ) ; int ext index = path . last index of ( ' . ' , end ) ; if ( ext index ! = -1 & & ext index > begin ) { return path . substring ( ext index + 1 , end ) ; } return null ; }
public deployment option set instance ( int instance ) { this . instance = instance ; return this ; }
public string get name ( ) { return name ; }
public static string get thread id ( ) { return get thread id ( thread . current thread ( ) ) ; }
public string get value ( ) { return value ; }
public string get value ( ) { return value ; }
public string id ( ) { return id ; }
public static extension registry new instance ( ) { return new extension registry ( ) ; }
public void set lazy ( final boolean lazy ) { this . lazy = lazy ; }
public boolean be pattern ( ) { return pattern name ! = null ; }
public static char [ ] to primitive ( final character [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_char_array ; } final char [ ] result = new char [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . char value ( ) ; } return result ; }
public object get ( int key ) { entry tab [ ] = table ; int hash = key ; int index = ( hash & 0x7 f f f f f f f ) % tab . length ; for ( entry e = tab [ index ] ; e ! = null ; e = e . next ) { if ( e . hash == hash ) { return e . value ; } } return null ; }
public static char [ ] to primitive ( final character [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_char_array ; } final char [ ] result = new char [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . char value ( ) ; } return result ; }
public work copy owner get work copy owner ( ) { return null ; }
public list < i o exception > get problem ( ) { return problem ; }
public list body declaration ( ) { return this . body declaration ; }
public static marker get marker ( final string name , final marker parent ) { return get marker ( name ) . add parent ( parent ) ; }
public string get descriptor ( ) { return descriptor ; }
public list body declaration ( ) { return this . body declaration ; }
public void set operator ( postfix expression . operator operator ) { if ( operator == null ) { throw new illegal argument exception ( ) ; } pre value change ( operator_property ) ; this . operator = operator ; post value change ( operator_property ) ; }
public static < e > e max ( final e o1 , final e o2 , comparator < e > comparator ) { if ( comparator == null ) { comparator = natural_comparator ; } final int c = comparator . compare ( o1 , o2 ) ; return c > 0 ? o1 : o2 ; }
public int [ ] get value ( ) { int [ ] result = new int [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get value ( i ) ; } return result ; }
public i compilation unit get work copy ( ) { return this . work copy ; }
public void set expression ( expression expression ) { a s t node old child = this . optional expression ; pre replace child ( old child , expression , expression_property ) ; this . optional expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public class < e > get element type ( ) { return element type ; }
public void set type ( type type ) { if ( type == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . type ; pre replace child ( old child , type , type_property ) ; this . type = type ; post replace child ( old child , type , type_property ) ; }
public boolean have comment ( ) { return comment ! = null ; }
public list < i o exception > get problem ( ) { return problem ; }
public collection < statement > get statement ( ) { return statement ; }
public static annotation [ ] get filtering annotation ( final annotation [ ] annotation ) { if ( annotation == null || annotation . length == 0 ) { return filter helper . empty_annotations ; } final list < annotation > filtering annotation = new array list < > ( annotation . length ) ; for ( final annotation annotation : annotation ) { final class < ? extend annotation > annotation type = annotation . annotation type ( ) ; for ( final annotation meta annotation : annotation type . get declared annotation ( ) ) { if ( meta annotation instanceof entity filter ) { filter annotation . add ( annotation ) ; } } } return filter annotation . to array ( new annotation [ filter annotation . size ( ) ] ) ; }
public void set declaration ( body declaration declaration ) { f declaration= declaration ; }
public final i bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve reference ( this ) ; }
public string get expression ( ) { return expression ; }
public pattern get pattern ( ) { return pattern ; }
public http request with body ( string body ) { this . body = new string body ( body ) ; return this ; }
public boolean have result ( ) { return have result ; }
public final i type bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve type ( this ) ; }
public receiver get underlying receiver ( ) { return next receiver ; }
public final type return type ( ) { return method internal . return type ( ) ; }
public void set type ( type type ) { unsupported in2 ( ) ; if ( type == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . type ; pre replace child ( old child , type , type_property ) ; this . type = type ; post replace child ( old child , type , type_property ) ; }
public void set expression ( expression expression ) { support only in12 ( ) ; a s t node old child = this . optional expression ; pre replace child ( old child , expression , expression_property ) ; this . optional expression = expression ; post replace child ( old child , expression , expression_property ) ; }
public static boolean be public ( int flag ) { return ( flags & acc public ) ! = 0 ; }
public boolean be private ( ) { return this . modifier keyword == modifier keyword . private_keyword ; }
public boolean be final ( ) { return this . modifier keyword == modifier keyword . final_keyword ; }
public boolean be shutdown ( ) { return ! be open . get ( ) ; }
public string get name ( ) { return ( this . name ) ; }
public int get range ( ) { return i range ; }
public assignment . operator get operator ( ) { return this . assignment operator ; }
public node get node ( ) { return node ; }
public void set type ( type type ) { if ( type == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . type ; pre replace child ( old child , type , type_property ) ; this . type = type ; post replace child ( old child , type , type_property ) ; }
public set < annotation > get qualifier ( ) { return collection . unmodifiable set ( qualifier ) ; }
public final void set rule ( int rule ) { this . rule = rule ; }
public boolean be fragment ( ) { return fragment ; }
public final i bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve reference ( this ) ; }
public boolean be interface ( ) { return ! be array ( ) & & this . component class . be interface ( ) ; }
public void set superclass ( name superclass name ) { internal set superclass ( superclass name ) ; }
public type get superclass type ( ) { unsupported in2 ( ) ; return this . optional superclass type ; }
public declaration get declaration by id ( string id ) { declaration decl = declaration by id . get ( id ) ; if ( ( decl == null ) & & ( parent ! = null ) ) { decl = parent . get declaration by id ( id ) ; } return decl ; }
public void set type ( type type ) { if ( type == null ) { throw new illegal argument exception ( ) ; } a s t node old child = this . type ; pre replace child ( old child , type , type_property ) ; this . type = type ; post replace child ( old child , type , type_property ) ; }
public void set argument ( object [ ] argument ) { this . argument = argument ; }
public void set property name ( string property name ) { this . property name = property name ; }
public list fragment ( ) { return this . fragment ; }
public static boolean be public ( int flag ) { return ( flags & acc public ) ! = 0 ; }
public static boolean be public ( int flag ) { return ( flags & public ) ! = 0 ; }
public static boolean be public ( int flag ) { return ( flags & acc public ) ! = 0 ; }
public static boolean be annotation ( int flag ) { return ( flags & acc annotation ) ! = 0 ; }
public int get option ( ) { return option ; }
public static level value of ( final string name ) { object . require non null ( name , `` no level name give . `` ) ; final string level name = to upper case ( name ) ; final level level = level . get ( level name ) ; if ( level ! = null ) { return level ; } throw new illegal argument exception ( `` unknown level constant [ `` + level name + `` ] . `` ) ; }
public boolean be synthetic ( ) { return this . synthetic ; }
public void remove ( int index ) { entry . remove ( index ) ; }
public static boolean be camel case pattern ( string pattern ) { return search pattern . validate match rule ( pattern , search pattern . r_camelcase_match ) == search pattern . r_camelcase_match ; }
public rule get rule ( ) { return this . rule ; }
public input stream get input stream ( ) throw i o exception { return new reader input stream ( reader ) ; }
public void set package ( string pkg ) { this . option . default package = pkg ; }
public string get code ( ) { return this . code ; }
public final int type ( ) { return type ! = 0 ? type : resolve type ( ) ; }
public line string get line ( ) { return line ; }
public list < i o exception > get problem ( ) { return problem ; }
public void set index ( int index ) { this . index = index ; }
public list < format error > get error ( ) { return error ; }
public int get number of syntax error ( ) { return state . syntax error ; }
public tag tag ( ) { return tag ; }
public string get original u r l ( ) { return original u r l ; }
public boolean be raw ( ) { if ( this . type parameter . length == 0 ) { return true ; } for ( int i = 0 , n = this . type parameter . length ; i < n ; i++ ) { if ( ! this . type parameter [ i ] . equal ( wildcard type parameter . unknown ) ) { return false ; } } return true ; }
public final boolean be abstract ( ) { return modifier . be abstract ( get modifier ( ) ) ; }
public boolean be default method ( ) { return ( this . modifier & extra compiler modifier . acc default method ) ! = 0 ; }
public final boolean be default abstract ( ) { return ( this . modifier & extra compiler modifier . acc default abstract ) ! = 0 ; }
public static string c ( string p ) { return p . replace ( '/ ' , ' . ' ) ; }
public string get message ( ) { return message ; }
public void set build ( build build ) { this . build = build ; } // -- void set build ( build )
public static i java search scope create reference scope ( i java element [ ] java element ) { set < i java project > projects= new hash set < > ( ) ; for ( i java element java element : java element ) { project . add ( java element . get java project ( ) ) ; } i java project [ ] prj= project . to array ( new i java project [ project . size ( ) ] ) ; return search engine . create java search scope ( prj , true ) ; }
public string get event ( ) { return event ; }
public final i resource delta get delta ( i project project ) { return super . get delta ( project ) ; }
public void to external ( coordinate internal , coordinate external ) { external . x = internal . x ; external . y = internal . y ; }
public boolean be call on null input ( ) { return call on null input ; }
public void start ( ) throw exception { start ( false ) ; }
public int compare ( object old info , object new info ) { if ( old info == null & & new info == null ) return 0 ; if ( old info == null || new info == null ) return 1 ; return test equality ( old info , new info ) ? 0 : 1 ; }
public static i classpath container get classpath container ( i path container path , i java project project ) throw java model exception { java model manager manager = java model manager . get java model manager ( ) ; i classpath container container = manager . get classpath container ( container path , project ) ; if ( container == java model manager . container_initialization_in_progress ) { return manager . get previous session container ( container path , project ) ; } return container ; }
public void set request body type ( body type request body type ) { this . throw if readonly ( ) ; this . request body type = request body type ; }
public void set type ( string type ) { f type= type ; }
public void set body ( expression body ) { super . set body ( body ) ; use = body ; }
public int get position ( ) { return this . position ; }
public int get modifier ( ) { return modifier . public ; }
public string get path ( ) { return this . path ; }
public final void set type ( string type ) { action . set name ( c o s name . type , type ) ; }
public output < string > handle ( ) { return handle ; }
public class info list get class implement ( final string interface name ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } if ( ! scan spec . enable class info ) { throw new illegal argument exception ( `` please call class graph # enable class info ( ) before # scan ( ) `` ) ; } final class info class info = class name to class info . get ( interface name ) ; return class info == null ? class info list . empty_list : class info . get class implement ( ) ; }
public boolean contains integer ( number value ) { if ( value == null ) { return false ; } return contains integer ( value . int value ( ) ) ; }
public float float value ( ) { return value ; }
public long long value ( ) { return value ; }
public type signature get type descriptor ( ) { return type descriptor ; }
public k next key ( final object key ) { final link entry < k , v > entry = get entry ( key ) ; return entry == null || entry . after == header ? null : entry . after . get key ( ) ; }
public string get import simple name ( ) { if ( be import on demand ) { return null ; } string import name = get import name ( ) ; return import name . substring ( import name . last index of ( ' . ' ) + 1 ) ; }
protect void set type name ( char [ ] type name ) { this . type name = type name ; }
public meta method get setter ( ) { return setter ; }
public output < string > handle ( ) { return handle ; }
public void set description ( string description ) { this . description = description ; }
public void set project ( project project ) { this . project = project ; }
public static color get default selection color ( ) { return default_selection_color ; }
public void set replace ( string replace ) { this . replace = project . to boolean ( replace ) ; }
public sqm expression < ? > get right hand operand ( ) { return rh operand ; }
protect ct member . cache have member cache ( ) { if ( member cache ! = null ) return member cache . get ( ) ; return null ; }
public void set label ( string label ) { this . label = label ; }
public string get indent ( ) { return indent ; }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public void set expand entity ( final boolean expand ) { this . expand = expand ; engine = null ; }
public class < e > get element type ( ) { return element type ; }
public string get import simple name ( ) { if ( be import on demand ) { return null ; } string import name = get import name ( ) ; return import name . substring ( import name . last index of ( ' . ' ) + 1 ) ; }
public boolean get omit encode ( ) { return omit encode ; }
public string get name ( ) { return f method . get name ( ) ; }
protect boolean match interface ( string interface name ) { return null ; }
public string get new node name ( ) { return new node name ; }
public type get type ( ) { return type ; }
public object get local context ( ) { return local context ; }
public list body declaration ( ) { return this . body declaration ; }
public static string get local name ( element element ) { string name = element . get tag name ( ) ; if ( name . index of ( ' : ' ) > 0 ) { name = name . substring ( name . index of ( ' : ' ) +1 ) ; } return name ; }
public tag tag ( ) { return tag ; }
public i java model status verify ( ) { i java element parent element = get parent element ( ) ; if ( parent element == null ) { return new java model status ( i java model status constant . no_elements_to_process ) ; } string package name = this . pkg name == null ? null : util . concat with ( this . pkg name , ' . ' ) ; i java project project = parent element . get java project ( ) ; if ( this . pkg name == null || ( this . pkg name . length > 0 & & java convention . validate package name ( package name , project . get option ( java core . compiler_source , true ) , project . get option ( java core . compiler_compliance , true ) ) . get severity ( ) == i status . error ) ) { return new java model status ( i java model status constant . invalid_name , package name ) ; } i java element root = get parent element ( ) ; if ( root . be read only ( ) ) { return new java model status ( i java model status constant . read_only , root ) ; } i container parent folder = ( i container ) ( ( java element ) root ) . resource ( ) ; int i ; for ( i = 0 ; i < this . pkg name . length ; i++ ) { i resource sub folder = parent folder . find member ( this . pkg name [ i ] ) ; if ( sub folder ! = null ) { if ( sub folder . get type ( ) ! = i resource . folder ) { return new java model status ( i java model status constant . name_collision , message . bind ( message . status_name collision , sub folder . get full path ( ) . to string ( ) ) ) ; } parent folder = ( i container ) sub folder ; } } return java model status . verified_ok ; }
public void set recovery path ( path recovery path ) { this . recovery path = recovery path ; }
public final i type bind resolve binding ( ) { return this . ast . get binding resolver ( ) . resolve type ( this ) ; }
public string get target name ( ) { return f target name ; }
public string get name ( ) { return target . get name ( ) ; }
public string get target name ( ) { return f target name ; }
public meta method get setter ( ) { return setter ; }
public environment get environment ( ) { return this . environment ; }
public final int get node kind ( ) { return type . attribute ; }
public type get generic type ( ) { return generic type ; }
public string get tag ( ) { return element name ; }
public void set resource ( resource resource ) { this . resource = resource ; }
public text edit perform ( ) { text edit result= do copy ( f edit ) ; if ( result ! = null ) { for ( text edit edit : f copy . key set ( ) ) { edit . post process copy ( this ) ; } } return result ; }
public boolean be manage ( ) { return manage type . contains ( type ) ; }
protect void set name source start ( int start ) { this . name start= start ; }
public static method [ ] get all method ( class < ? > clazz ) { if ( clazz == null ) { throw new illegal argument exception ( `` you must specify a class in order to get the method . `` ) ; } set < method > method = new link hash set < method > ( ) ; class < ? > this type = clazz ; while ( this type ! = null ) { final class < ? > type = this type ; final method [ ] declare method = access controller . do privilege ( new privilege action < method [ ] > ( ) { public method [ ] run ( ) { return type . get declare method ( ) ; } } ) ; for ( method method : declare method ) { method . set accessible ( true ) ; method . add ( method ) ; } collection . add all ( method , type . get method ( ) ) ; this type = this type . get superclass ( ) ; } return method . to array ( new method [ method . size ( ) ] ) ; }
public void set resource ( resource resource ) { this . resource = resource ; }
public static i search pattern create search pattern ( string string pattern , int search for , int limit to , boolean be case sensitive ) { int match mode = string pattern . index of ( ' * ' ) ! = -1 || string pattern . index of ( ' ? ' ) ! = -1 ? search pattern . r_pattern_match : search pattern . r_exact_match ; int match rule = be case sensitive ? match mode | search pattern . r_case_sensitive : match mode ; return new search pattern adapter ( search pattern . create pattern ( string pattern , search for , limit to , match rule ) ) ; }
public list < warn message > get warning ( ) { return warning ; }
public list < i o exception > get problem ( ) { return problem ; }
public int get position ( ) { return position ; }
public string get error message ( ) { return error message ; }
public analyzer get analyzer ( ) { return analyzer ; }
public static boolean be transmittable ( int status code ) { return ( status code == normal ) || ( status code == shutdown ) || ( status code == protocol ) || ( status code == bad_data ) || ( status code == bad_payload ) || ( status code == policy_violation ) || ( status code == message_too_large ) || ( status code == required_extension ) || ( status code == server_error ) || ( status code == service_restart ) || ( status code == try_again_later ) || ( status code == invalid_upstream_response ) ; }
public file get dir ( ) { return this . dir ; }
public file get file ( ) { return file ; }
public static string get filename extension ( @ nullable string path ) { if ( path == null ) { return null ; } int ext index = path . last index of ( extension_separator ) ; if ( ext index == -1 ) { return null ; } int folder index = path . last index of ( folder_separator ) ; if ( folder index > ext index ) { return null ; } return path . substring ( ext index + 1 ) ; }
public byte [ ] process class ( string name , byte [ ] classbytes , classpath entry classpath entry , bundle entry entry , classpath manager manager ) { return null ; }
protect final void add function library ( function library library ) { function library library list = executable . get function library ( ) ; if ( library list instanceof function library list ) { ( ( function library list ) library list ) . add function library ( library ) ; } else { throw new illegal state exception ( `` register function library can not be extend `` ) ; } }
public static set < url > parse class path ( ) { return parse class path ( system . get property ( `` java . class . path `` ) ) ; }
public void set preview feature ( final boolean preview feature ) { this . preview feature = preview feature ; }
public change get change ( ) { return f change ; }
public void add all ( change [ ] change ) { for ( change change : change ) { add ( change ) ; } }
public change get undo change ( ) { return f undo ; }
public pattern processor get pattern processor ( ) { return pattern processor ; }
public boolean get rename ( ) { return m rename ; }
public set < string > get change ( ) { return change ; }
public final void set rule ( int rule ) { this . rule = rule ; }
public change get undo until exception ( ) { return f undo until exception ; }
public void set history ( boolean value ) { this . history = value ; }
public list < condition > get condition ( ) { return condition ; }
public path get path ( ) { return path ; }
public final void configure region ( region region ) { check mutability ( ) ; if ( region == null ) throw new illegal argument exception ( `` no region provide `` ) ; this . set region ( region . get region ( region ) ) ; }
public void add group ( string group ) { if ( be wild card a c l value ( group ) ) { throw new illegal argument exception ( `` group `` + group + `` can not be add `` ) ; } if ( ! be all allow ( ) ) { list < string > group list = new link list < string > ( ) ; group list . add ( group ) ; group map . cache group add ( group list ) ; group . add ( group ) ; } }
public string get text ( ) { return f text ; }
public string get text ( ) { return f text ; }
public string get refactoring id ( final refactoring contribution contribution ) { assert . be not null ( contribution ) ; populate cache ( ) ; return f id cache . get ( contribution ) ; }
public static refactoring contribution manager get instance ( ) { if ( f instance == null ) f instance= new refactoring contribution manager ( ) ; return f instance ; }
public static string get matching character ( final string character , final string input , final int maximum length ) { final string builder sb = new string builder ( input . length ( ) ) ; for ( int i = 0 ; i < input . length ( ) ; i++ ) { final char c = input . char at ( i ) ; if ( character . index of ( c ) ! = -1 ) { if ( sb . length ( ) < maximum length ) { sb . append ( c ) ; } else { break ; } } } return sb . to string ( ) ; }
public cherry pick command set progress monitor ( progress monitor monitor ) { if ( monitor == null ) { monitor = null progress monitor . instance ; } this . monitor = monitor ; return this ; }
public time stamp get transmit time stamp ( ) { return get timestamp ( transmit_timestamp_index ) ; }
public static refactoring contribution manager get instance ( ) { if ( f instance == null ) f instance= new refactoring contribution manager ( ) ; return f instance ; }
public list < string > get delete ( ) { return delete ; }
public void set update reference ( boolean update reference ) { f update references= update reference ; }
public void set update reference ( boolean update reference ) { f update references= update reference ; }
public void trigger action ( ) { trigger action ( time ) ; }
public get request refresh ( boolean refresh ) { this . refresh = refresh ; return this ; }
public string get revision ( ) { return revision ; }
public void set type ( int type ) { this . type = type ; }
public iterable < desire capability > get desire capability ( ) { lock . read lock ( ) . lock ( ) ; try { return new session request . stream ( ) . map ( req - > new desire capability ( req . get request ( ) . get desired capability ( ) ) ) . collect ( collector . to list ( ) ) ; } finally { lock . read lock ( ) . unlock ( ) ; } }
public boolean be dangle symbolic link ( string name ) throw i o exception { return be dangle symbolic link ( new file ( name ) ) ; }
public default boolean be empty ( ) { return key ( ) . size ( ) == 0 ; }
public set < k > key set ( ) { if ( key set == null ) { key set = new key set < > ( this ) ; } return key set ; }
public void remove all ( ) { local . clear ( ) ; }
public void close ( ) throw i o exception { input . close ( ) ; }
public static boolean be public ( int flag ) { return ( flags & public ) ! = 0 ; }
public version result get result ( ) { return result ; }
public v put ( k key , v value ) { return put ( key , value , false ) ; }
public void set action ( string action ) { this . action = action ; }
public string get property ( ) { return property ; }
public void set long value ( long long value ) { this . long value = long value ; }
public boolean match ( service reference < ? > reference ) { return matches0 ( ( reference ! = null ) ? service reference map . a map ( reference ) : collection . empty map ( ) ) ; }
protect void handle i o exception ( final i o exception e ) throw i o exception { throw e ; }
public namespace get namespace ( ) { return namespace ; }
public static throwable get cause ( throwable throwable ) { return get cause ( throwable , cause_method_names ) ; }
public string get method name ( ) { return method name ; }
public bundle get bundle ( ) { return bundle ; }
public bundle get bundle ( ) { return bundle ; }
public set < string > get reference string ( ) { return reference string ; }
default public i runtime classpath entry [ ] resolve runtime classpath entry ( i runtime classpath entry entry , i java project project , boolean exclude test code ) throw core exception { return resolve runtime classpath entry ( entry , project ) ; }
public resource name iterator find resource name ( string resource name ) { return find resource class ( resource name ) ; }
public void set user ( string user ) { super . set internal user ( user ) ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public boolean contains ( object value ) { return contain value ( value ) ; }
public policy get policy ( ) { return policy ; }
public string get host ( ) { return host ; }
public char sequence get leave ( ) { return leave ; }
public static throwable get cause ( throwable throwable ) { return get cause ( throwable , cause_method_names ) ; }
public string get name ( ) { return name ; }
public string get location ( ) { return location ; }
public boolean be manage ( ) { return f be manage ; }
public string get value ( ) { return value ; }
public string put attribute ( string key , string value ) { if ( attribute == null ) { attribute = new hash map < string , string > ( ) ; } return attribute . put ( key , value ) ; }
public static bundle [ ] get host ( bundle bundle ) { return internal platform . get default ( ) . get host ( bundle ) ; }
public list < resource > get resource ( ) { return resource ; }
public static void identity to string ( string buffer buffer , object object ) { if ( object == null ) { throw new null pointer exception ( `` can not get the to string of a null identity `` ) ; } buffer . append ( object . get class ( ) . get name ( ) ) . append ( ' @ ' ) . append ( integer . to hex string ( system . identity hash code ( object ) ) ) ; }
public void set ( int value ) { this . value = value ; }
public static < t > t be a ( class < t > clazz ) { report matcher ( new instance of ( clazz ) ) ; return null ; }
public void add document listener ( document listener listener ) { this . document listener . put ( listener , listener ) ; }
public static boolean have manager ( i document [ ] document ) { for ( i document document : document ) { if ( have manager ( document ) ) return true ; } return false ; }
public int get position ( ) { return position ; }
public final int end offset ( ) { return end offset ; }
public document get document ( ) { return doc ; }
public int get offset ( ) { return this . offset ; }
public boolean be fragment ( ) { return fragment ; }
public final void configure region ( region region ) { check mutability ( ) ; if ( region == null ) throw new illegal argument exception ( `` no region provide `` ) ; this . set region ( region . get region ( region ) ) ; }
public string get event ( ) { return event ; }
public void set type ( int type ) { this . type = type ; }
public void mark ( int mark limit ) { }
public void cleanup ( ) { }
public static annotation [ ] get filtering annotation ( final annotation [ ] annotation ) { if ( annotation == null || annotation . length == 0 ) { return filter helper . empty_annotations ; } final list < annotation > filtering annotation = new array list < > ( annotation . length ) ; for ( final annotation annotation : annotation ) { final class < ? extend annotation > annotation type = annotation . annotation type ( ) ; for ( final annotation meta annotation : annotation type . get declared annotation ( ) ) { if ( meta annotation instanceof entity filter ) { filter annotation . add ( annotation ) ; } } } return filter annotation . to array ( new annotation [ filter annotation . size ( ) ] ) ; }
public boolean be empty ( ) { return name . be empty ( ) ; }
public int get offset ( ) { return offset ; }
public string get context id ( ) { return this . context id ; }
public pattern get pattern ( ) { return pattern ; }
public dependency resolver get resolver ( ) { return resolver ; }
public string get value ( ) { return value ; }
public void set value ( final @ nullable string value ) { this . value = value ; }
public void set value ( string value ) { assert not null ( value ) ; this . value = value ; }
protect boolean have already an unambiguous to string of ( object obj ) { for ( int i = 0 ; i < type_with_unambiguous_representation . length ; i++ ) { if ( type_with_unambiguous_representation [ i ] . be instance ( obj ) ) return true ; } return false ; }
public str builder replace all ( char search , char replace ) { if ( search ! = replace ) { for ( int i = 0 ; i < size ; i++ ) { if ( buffer [ i ] == search ) { buffer [ i ] = replace ; } } } return this ; }
public void set modifier ( int modifier ) { this . modifier = modifier ; }
public string get text ( ) { return f text ; }
public string get text ( ) { return f text ; }
public node get parent ( ) { return parent ; }
public void add child ( unknown element child ) { if ( child == null ) { child = new array list ( ) ; } child . add ( child ) ; }
public boolean visit ( copy source edit edit ) { return visit node ( edit ) ; }
public string get description ( ) { return description ; }
public text edit perform ( ) { text edit result= do copy ( f edit ) ; if ( result ! = null ) { for ( text edit edit : f copy . key set ( ) ) { edit . post process copy ( this ) ; } } return result ; }
public final string get template ( ) { return template ; }
public final string get template ( ) { return template ; }
public string get match format name ( ) { return have match ( ) ? get match ( ) . get format name ( ) : null ; }
public string get u r l ( ) { return service . get u r l ( ) ; }
public url get url ( ) { return url ; }
public void set image ( final image image ) { this . image = image ; }
public final void set matrix ( matrix matrix ) { c o s array matrix array = null ; if ( matrix ! = null ) { matrix array = matrix . to c o s array ( ) ; } dictionary . set item ( c o s name . matrix , matrix array ) ; }
public int size ( ) { return size ; }
public static list transpose ( list list ) { list result = new array list ( ) ; if ( list . be empty ( ) ) return result ; int min size = integer . max_value ; for ( object list like : list ) { list list = ( list ) default type transformation . cast to type ( list like , list . class ) ; if ( list . size ( ) < min size ) min size = list . size ( ) ; } if ( min size == 0 ) return result ; for ( int i = 0 ; i < min size ; i++ ) { result . add ( new array list ( ) ) ; } for ( object list like : list ) { list list = ( list ) default type transformation . cast to type ( list like , list . class ) ; for ( int i = 0 ; i < min size ; i++ ) { list result list = ( list ) result . get ( i ) ; result list . add ( list . get ( i ) ) ; } } return result ; }
public void clear ( ) { clear ( size ) ; }
public float get float ( string key , float default value ) { return get float ( c o s name . get p d f name ( key ) , default value ) ; }
public boolean get boolean ( string key , boolean default value ) { return get boolean ( c o s name . get p d f name ( key ) , default value ) ; }
public boolean get boolean ( c o s name key , boolean default value ) { return get boolean ( key , null , default value ) ; }
public boolean get boolean ( string key , boolean default value ) { return get boolean ( c o s name . get p d f name ( key ) , default value ) ; }
public p d stream get font file3 ( ) { p d stream retval = null ; c o s base obj = dic . get dictionary object ( c o s name . font_file3 ) ; if ( obj instanceof c o s stream ) { retval = new p d stream ( ( c o s stream ) obj ) ; } return retval ; }
public void set float ( string key , float value ) { set float ( c o s name . get p d f name ( key ) , value ) ; }
public set < c o s name > key set ( ) { return item . key set ( ) ; }
public c o s base get item ( c o s name key ) { return item . get ( key ) ; }
public c o s base get item ( c o s name key ) { return item . get ( key ) ; }
protect void internal add or replace ( t entry entry ) { t entry old entry ; if ( this . entry . contains key ( entry . get key ( ) ) ) { old entry = this . entry . get ( entry . get key ( ) ) ; old entry . remove change event ( this ) ; entry . add on change event ( this ) ; if ( ! this . added entry . contains ( entry . get key ( ) ) ) { if ( ! this . modified entry . contains ( entry . get key ( ) ) ) { this . modified entry . add ( entry . get key ( ) ) ; } } this . change ( ) ; } else { this . internal add ( entry ) ; } }
public version version ( ) { return version ; }
protect void set decrypt metadata ( boolean decrypt metadata ) { this . decrypt metadata = decrypt metadata ; }
public static void write swap short ( final output stream output , final short value ) throw i o exception { output . write ( ( byte ) ( ( value > > 0 ) & 0xff ) ) ; output . write ( ( byte ) ( ( value > > 8 ) & 0xff ) ) ; }
public final void set object ( c o s base object ) throw i o exception { base object = object ; }
public c o s base get object ( ) { return base object ; }
public static generation type from xml ( string name ) { return generation type . value of ( name ) ; }
protect byte array output stream create temporary output stream ( ) { return new byte array output stream ( output_byte_array_initial_size ) ; }
public byte [ ] to byte array ( ) throw i o exception { byte array output stream output = new byte array output stream ( ) ; input stream be = null ; try { be = create input stream ( ) ; i o utils . copy ( be , output ) ; } finally { if ( be ! = null ) { be . close ( ) ; } } return output . to byte array ( ) ; }
public string get char set ( ) { return this . char set ; }
public int get line ( ) { return line ; }
public void set bound box ( bound box b box ) { bound box = b box ; }
public string get file name ( ) { return file name ; }
public void set last page overlay file ( string last page overlay file ) { last page overlay filename = last page overlay file ; }
public string get default overlay file ( ) { return default overlay filename ; }
public void set header ( string header ) { this . header = header ; }
public static c o s writer x ref entry get null entry ( ) { return nullentry ; }
protected list < c o s writer x ref entry > get x ref entry ( ) { return x ref entry ; }
public string get filename ( ) { return filename ; }
public date get creation time ( ) { return new date ( ctime ) ; }
public static boolean be final ( int mod ) { return ( mod & final ) ! = 0 ; }
public static checksum checksum ( file file , checksum checksum ) throw i o exception { if ( file . be directory ( ) ) { throw new illegal argument exception ( `` checksum ca n't be compute on directory `` ) ; } input stream in = null ; try { in = new check input stream ( new file input stream ( file ) , checksum ) ; i o utils . copy ( in , new null output stream ( ) ) ; } finally { i o utils . close quietly ( in ) ; } return checksum ; }
public void set name ( string name ) { this . name = name ; }
public void add name ( string name ) { this . instruction . add ( name ) ; }
public void add boolean ( boolean value ) { this . instruction . add ( value ) ; }
public str tokenizer a tokenizer ( ) { return new str builder tokenizer ( ) ; }
public static < e > navigable set < e > synchronize navigable set ( navigable set < e > navigable set ) { return synchronize . navigable set ( navigable set ) ; }
public static kryo pool with byte array output stream ( int pool size , final kryo instantiator ki ) { return new kryo pool ( pool size ) { protect ser de state new instance ( ) { return new ser de state ( ki . new kryo ( ) , new input ( ) , new output ( new byte array output stream ( ) ) ) { / * * we have to take extra care of the byte array output stream * / @ override public void clear ( ) { super . clear ( ) ; byte array output stream byte stream = ( byte array output stream ) output . get output stream ( ) ; byte stream . reset ( ) ; } @ override public byte [ ] output to byte ( ) { output . flush ( ) ; byte array output stream byte stream = ( byte array output stream ) output . get output stream ( ) ; return byte stream . to byte array ( ) ; } @ override public void write output to ( output stream os ) throw i o exception { output . flush ( ) ; byte array output stream byte stream = ( byte array output stream ) output . get output stream ( ) ; byte stream . write to ( o ) ; } } ; } } ; }
public void set in stream ( in stream stream ) { this . stream = stream ; }
public list annotation ( ) { return this . annotation ; }
public c o s base get k ( ) { return this . get c o s object ( ) . get dictionary object ( c o s name . k ) ; }
public string get name ( ) { return ref . get string ( c o s name . name ) ; }
public p d form x object get alternate icon ( ) { c o s base i = this . get c o s object ( ) . get dictionary object ( c o s name . ix ) ; if ( i instanceof c o s stream ) { return new p d form x object ( ( c o s stream ) i ) ; } return null ; }
public j tree get tree ( ) { return f tree ; }
public void set name ( string name ) { dictionary . set string ( c o s name . name , name ) ; }
public double get x ( ) { return x ; }
public string get scope ( ) { return this . scope ; }
public string get text type ( ) { return f text type ; }
public vertical alignment get vertical ( ) { s t vertical alignment . enum align = cell alignement . get vertical ( ) ; if ( align == null ) align = s t vertical alignment . bottom ; return vertical alignment . value ( ) [ align . int value ( ) - 1 ] ; }
public integer get width ( ) { return width ; }
public void set state ( final object state ) { this . state = state ; }
public float get float ( string key , float default value ) { return get float ( c o s name . get p d f name ( key ) , default value ) ; }
public boolean can modify annotation ( ) { return be permission bit on ( modify_annotations_bit ) ; }
public boolean can modify ( ) { return be permission bit on ( modification_bit ) ; }
public boolean be form list ( ) { return form list ; }
public c o s name get crypt filter method ( ) { return ( c o s name ) crypt filter dictionary . get dictionary object ( c o s name . cfm ) ; }
public void set crypt filter method ( c o s name cfm ) { crypt filter dictionary . set item ( c o s name . cfm , cfm ) ; }
public void set content ( byte [ ] bytes ) { c o s string string = new c o s string ( byte ) ; string . set force hex form ( true ) ; dictionary . set item ( c o s name . content , string ) ; }
public void set permission ( path p , fs permission permission ) throw i o exception { }
public boolean remove recipient ( public key recipient recipient ) { return recipient . remove ( recipient ) ; }
public void add recipient ( public key recipient recipient ) { recipient . add ( recipient ) ; }
public x509 certificate get client x509 certificate ( ) { return certificate ; }
public boolean be decrypt ( ) { return be decrypt ; }
public static boolean be array ( object obj ) { return ( obj ! = null & & obj . get class ( ) . be array ( ) ) ; }
public static < e > list < e > a list ( iterable < e > i ) { if ( i instanceof collection ) { return new array list < e > ( ( collection < e > ) i ) ; } array list < e > a = new array list < e > ( ) ; for ( e e : i ) { a . add ( e ) ; } return a ; }
public void set password ( string password ) { this . password = password ; }
public void previous page ( ) { if ( ! be first page ( ) ) { this . page -- ; } }
public boolean be lock ( ) { return annot . get flag ( c o s name . f , flag_locked ) ; }
public void set rotate size ( final long rotate size ) { synchronize ( output lock ) { this . rotate size = rotate size ; } }
public boolean be no zoom ( ) { return annot . get flag ( c o s name . f , flag_no_zoom ) ; }
public c o s base get object ( ) { return base object ; }
public string get default style ( ) { return annot . get string ( c o s name . d ) ; }
public void set background ( color color ) { if ( color == null ) return ; _background = color ; }
public color get interior color ( ) { color retval = null ; c o s array array = ( c o s array ) annot . get dictionary object ( c o s name . ic ) ; if ( array ! = null ) { float [ ] rgb = array . to float array ( ) ; if ( rgb . length > = 3 ) { retval = new color ( rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; } } return retval ; }
public list < string > get filter ( ) { c o s base filter = parameter . get dictionary object ( c o s name . f , c o s name . filter ) ; if ( filter instanceof c o s name ) { c o s name name = ( c o s name ) filter ; return collection . singleton list ( name . get name ( ) ) ; } else if ( filter instanceof c o s array ) { return ( ( c o s array ) filter ) . to c o s name string list ( ) ; } return collection . empty list ( ) ; }
public string get default style ( ) { return annot . get string ( c o s name . d ) ; }
public string get default appearance ( ) { return annot . get string ( c o s name . da ) ; }
public color get interior color ( ) { color retval = null ; c o s array array = ( c o s array ) annot . get dictionary object ( c o s name . ic ) ; if ( array ! = null ) { float [ ] rgb = array . to float array ( ) ; if ( rgb . length > = 3 ) { retval = new color ( rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; } } return retval ; }
public void set version ( string version ) { catalog . set name ( c o s name . version , version ) ; }
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public p d file specification get file ( ) throw i o exception { return p d file specification . create f s ( get c o s object ( ) . get dictionary object ( `` fs `` ) ) ; }
public void save ( string file name ) throw i o exception { save ( new file ( file name ) ) ; }
public void close ( ) throw i o exception { input . close ( ) ; }
public list < string > get option display value ( ) { c o s base value = get c o s object ( ) . get dictionary object ( c o s name . opt ) ; return field utils . get pairable item ( value , 1 ) ; }
public integer get clear widget field flag ( ) { integer retval = null ; c o s number ff = ( c o s number ) field . get dictionary object ( c o s name . clr_f ) ; if ( ff ! = null ) { retval = ff . int value ( ) ; } return retval ; }
public void set field flag ( integer ff ) { c o s integer value = null ; if ( ff ! = null ) { value = c o s integer . get ( ff ) ; } field . set item ( c o s name . ff , value ) ; }
public option get option ( ) { return option ; }
public string get name ( ) { return name ; }
public option group get option group ( option opt ) { return ( option group ) option group . get ( opt . get opt ( ) ) ; }
public int get element name code ( ) { return element name code ; }
public c f f font get font ( ) { return cff font ; }
public void register true type font for closing ( true type font ttf ) { font to close . add ( ttf ) ; }
public integer get width ( ) { return width ; }
public float get max width ( ) { return dic . get float ( c o s name . max_width , 0 ) ; }
public float get width ( ) { return get c o s object ( ) . get float ( `` w `` , 1 ) ; }
public void register true type font for closing ( true type font ttf ) { font to close . add ( ttf ) ; }
public int get int ( string [ ] key list , int default value ) { int retval = default value ; c o s base obj = get dictionary object ( key list ) ; if ( obj instanceof c o s number ) { retval = ( ( c o s number ) obj ) . int value ( ) ; } return retval ; }
public matrix get initial matrix ( ) { return initial matrix ; }
public pattern get pattern ( ) { return pattern ; }
public color get interior color ( ) { color retval = null ; c o s array array = ( c o s array ) annot . get dictionary object ( c o s name . ic ) ; if ( array ! = null ) { float [ ] rgb = array . to float array ( ) ; if ( rgb . length > = 3 ) { retval = new color ( rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; } } return retval ; }
public matcher transform type get transform ( ) { return transform ; }
public static boolean be valid name for component ( string component ) { if ( component . equal ( `` . `` ) || component . equal ( `` . . `` ) || component . index of ( `` : `` ) > = 0 || component . index of ( `` / `` ) > = 0 ) { return false ; } return ! be reserve path component ( component ) ; }
public void set match range ( document range range ) { this . match range = range ; }
public void set image ( final image image ) { this . image = image ; }
public c o s base get k ( ) { return this . get c o s object ( ) . get dictionary object ( c o s name . k ) ; }
public list < string > get filter ( ) { c o s base filter = parameter . get dictionary object ( c o s name . f , c o s name . filter ) ; if ( filter instanceof c o s name ) { c o s name name = ( c o s name ) filter ; return collection . singleton list ( name . get name ( ) ) ; } else if ( filter instanceof c o s array ) { return ( ( c o s array ) filter ) . to c o s name string list ( ) ; } return collection . empty list ( ) ; }
public void set background ( color color ) { if ( color == null ) return ; _background = color ; }
public void set extend ( boolean extend ) { _extended = extend ; }
public string get table ( ) { return table ; }
public void set style ( style style ) { this . style = style ; }
public int get return op ( ) { return return op ; }
public void set digest method require ( boolean flag ) { get c o s object ( ) . set flag ( c o s name . ff , flag_digest_method , flag ) ; }
public final void set matrix ( matrix matrix ) { c o s array matrix array = null ; if ( matrix ! = null ) { matrix array = matrix . to c o s array ( ) ; } dictionary . set item ( c o s name . matrix , matrix array ) ; }
public void set miter limit ( float miter limit ) throw i o exception { if ( in text mode ) { throw new illegal state exception ( `` error : set miter limit be not allow within a text block . `` ) ; } if ( miter limit < = 0 . 0 ) { throw new illegal argument exception ( `` a miter limit < = 0 be invalid and will not render in acrobat reader `` ) ; } write operand ( miter limit ) ; write operator ( `` m `` ) ; }
public void set stroke ( boolean value ) { this . stroke = value ; }
public void set stroke ( boolean value ) { this . stroke = value ; }
public void set transfer ( c o s base transfer ) { this . transfer = transfer ; }
public c o s base get transfer ( ) { return transfer ; }
public void set word spacing ( float value ) { word space = value ; }
public float get word spacing ( ) { return word spacing ; }
public boolean be horizontal border ( ) { return horizontal border . be set ( field_1_options ) ; }
public set < type > get type ( ) { return type ; }
public p d file specification get file ( ) throw i o exception { return p d file specification . create f s ( fdf . get dictionary object ( c o s name . f ) ) ; }
public simple mix in resolver without local definition ( ) { return new simple mix in resolver ( _overrides , null ) ; }
public p d action get x ( ) { c o s dictionary x = ( c o s dictionary ) action . get dictionary object ( `` x `` ) ; p d action retval = null ; if ( x ! = null ) { retval = p d action factory . create action ( x ) ; } return retval ; }
public p d action get e ( ) { c o s dictionary e = ( c o s dictionary ) action . get dictionary object ( `` e `` ) ; p d action retval = null ; if ( e ! = null ) { retval = p d action factory . create action ( e ) ; } return retval ; }
public void set action ( string action ) { this . action = action ; }
public p d file specification get file ( ) throw i o exception { return p d file specification . create f s ( fdf . get dictionary object ( c o s name . f ) ) ; }
public p d action u r i get previous u r i ( ) { c o s base base = get c o s object ( ) . get dictionary object ( `` pa `` ) ; if ( base instanceof c o s dictionary ) { return new p d action u r i ( ( c o s dictionary ) base ) ; } return null ; }
public p d form x object get alternate icon ( ) { c o s base i = this . get c o s object ( ) . get dictionary object ( c o s name . ix ) ; if ( i instanceof c o s stream ) { return new p d form x object ( ( c o s stream ) i ) ; } return null ; }
public string get element identifier ( ) { return this . get c o s object ( ) . get string ( c o s name . id ) ; }
public p d border style dictionary get border style ( ) { c o s base b = get c o s object ( ) . get dictionary object ( c o s name . b ) ; if ( bs instanceof c o s dictionary ) { return new p d border style dictionary ( ( c o s dictionary ) b ) ; } return null ; }
public void set point only ( boolean point only ) { this . point only = point only ; }
public string get element identifier ( ) { return this . get c o s object ( ) . get string ( c o s name . id ) ; }
public c o s base get k ( ) { return this . get c o s object ( ) . get dictionary object ( c o s name . k ) ; }
public float get conversion factor ( ) { return this . get c o s object ( ) . get float ( `` c `` ) ; }
public void set filter ( tree filter filter ) { this . filter = filter ; }
public void set flag ( byte flag ) { this . flag = flag ; }
public jwt consumer builder set expect issuer ( string expect issuer ) { return set expect issuer ( true , expect issuer ) ; }
public synchronize url get u r l ( ) { if ( be reference ( ) ) { return ( ( u r l resource ) get check ref ( ) ) . get u r l ( ) ; } return url ; }
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public string get location ( ) { return location ; }
public void set user key ( byte [ ] u ) throw i o exception { dictionary . set item ( c o s name . u , new c o s string ( u ) ) ; }
public byte [ ] get ( ) { if ( be in memory ( ) ) { if ( cached content == null & & dfos ! = null ) { cache content = dfos . get data ( ) ; } return cached content ; } byte [ ] file data = new byte [ ( int ) get size ( ) ] ; input stream fis = null ; try { fis = new file input stream ( dfos . get file ( ) ) ; i o utils . read fully ( fis , file data ) ; } catch ( i o exception e ) { file data = null ; } finally { i o utils . close quietly ( fis ) ; } return file data ; }
public byte [ ] get signature ( ) { return signature ; }
public byte [ ] get signature ( ) { return signature ; }
public enclose expr set inner ( final expression inner ) { assert not null ( inner ) ; if ( inner == this . inner ) { return this ; } notify property change ( observable property . inner , this . inner , inner ) ; if ( this . inner ! = null ) this . inner . set parent node ( null ) ; this . inner = inner ; set a parent node of ( inner ) ; return this ; }
public void set image ( final image image ) { this . image = image ; }
public int read sign byte ( ) throw i o exception { int sign byte = read ( ) ; return sign byte < 127 ? sign byte : sign byte - 256 ; }
protect void set visible attribute ( set < string > visible attribute ) { if ( visible attribute ! = null ) { f visible attribute = new hash set < > ( visible attribute ) ; } }
public string get name ( ) { return ref . get string ( c o s name . name ) ; }
public void set bound box ( bound box b box ) { bound box = b box ; }
public void set top ( int y ) { array . grow to size ( 4 ) ; if ( y == -1 ) { array . set ( 3 , null ) ; } else { array . set int ( 3 , y ) ; } }
public void set top ( int y ) { array . grow to size ( 4 ) ; if ( y == -1 ) { array . set ( 3 , null ) ; } else { array . set int ( 3 , y ) ; } }
public void set bottom ( int y ) { array . grow to size ( 6 ) ; if ( y == -1 ) { array . set ( 3 , null ) ; } else { array . set int ( 3 , y ) ; } }
public void set digest method require ( boolean flag ) { get c o s object ( ) . set flag ( c o s name . ff , flag_digest_method , flag ) ; }
public void add child ( unknown element child ) { if ( child == null ) { child = new array list ( ) ; } child . add ( child ) ; }
protect void sort field ( list < field > field , list < string > names ) { for ( int i=0 ; i < name . size ( ) ; i++ ) { string name = name . get ( i ) ; for ( int f=0 ; f < field . size ( ) ; f++ ) { field field = field . get ( f ) ; if ( name . equal ( field . get name ( ) ) ) { collection . swap ( field , i , f ) ; break ; } } } }
public void set digest method require ( boolean flag ) { get c o s object ( ) . set flag ( c o s name . ff , flag_digest_method , flag ) ; }
public c o s base get c o s value ( ) throw i o exception { c o s base value = field . get dictionary object ( c o s name . v ) ; if ( value instanceof c o s name ) { return value ; } else if ( value instanceof c o s array ) { return value ; } else if ( value instanceof c o s string || value instanceof c o s stream ) { return value ; } else if ( value ! = null ) { throw new i o exception ( `` error : unknown type for field import `` + value ) ; } else { return null ; } }
public c o s base get c o s value ( ) throw i o exception { c o s base value = field . get dictionary object ( c o s name . v ) ; if ( value instanceof c o s name ) { return value ; } else if ( value instanceof c o s array ) { return value ; } else if ( value instanceof c o s string || value instanceof c o s stream ) { return value ; } else if ( value ! = null ) { throw new i o exception ( `` error : unknown type for field import `` + value ) ; } else { return null ; } }
public void set sort ( string value ) { this . sort = value ; }
public boolean be require ( ) { return require ; }
public static int [ ] new int array ( int len ) { if ( len == 0 ) { return empty_int_array ; } return new int [ len ] ; }
public float get width ( ) { return get c o s object ( ) . get float ( `` w `` , 1 ) ; }
public string get display name ( ) { return display name ; }
public int get denominator ( ) { return denominator ; }
public void set separator ( string separator ) { this . separator = separator ; }
public string get element identifier ( ) { return this . get c o s object ( ) . get string ( c o s name . id ) ; }
public p d form x object get alternate icon ( ) { c o s base i = this . get c o s object ( ) . get dictionary object ( c o s name . ix ) ; if ( i instanceof c o s stream ) { return new p d form x object ( ( c o s stream ) i ) ; } return null ; }
public p d border style dictionary get border style ( ) { c o s base b = get c o s object ( ) . get dictionary object ( c o s name . b ) ; if ( bs instanceof c o s dictionary ) { return new p d border style dictionary ( ( c o s dictionary ) b ) ; } return null ; }
public void set ( boolean value ) { this . value = value ; }
public string get name ( ) { return ref . get string ( c o s name . name ) ; }
public true type font get true type font ( ) { return ttf ; }
public void save ( file file name ) throw i o exception { save ( new file output stream ( file name ) ) ; }
public void set all security to be remove ( boolean remove all security ) { all security to be remove = remove all security ; }
public boolean be all security to be remove ( ) { return all security to be remove ; }
public p d action get e ( ) { c o s dictionary e = ( c o s dictionary ) action . get dictionary object ( `` e `` ) ; p d action retval = null ; if ( e ! = null ) { retval = p d action factory . create action ( e ) ; } return retval ; }
public void set action ( string action ) { this . action = action ; }
public string get s q l keywords ( ) { debug code call ( `` get s q l keywords `` ) ; return `` limit , minus , offset , rownum , sysdate , systime , systimestamp , today `` ; }
public instance creator get instance creator ( ) { return instance creator ; }
protect void write context line ( raw text text , int line ) throw i o exception { write line ( ' ' , text , line ) ; }
public void line to ( float x , float y ) throw i o exception { if ( in text mode ) { throw new illegal state exception ( `` error : line to be not allow within a text block . `` ) ; } write operand ( x ) ; write operand ( y ) ; write operator ( `` l `` ) ; }
public float get miter limit ( ) { return miter limit ; }
public string get name ( ) { return ref . get string ( c o s name . name ) ; }
public string get property ( string property name ) { object o = property . get ( property name ) ; return o instanceof string ? ( string ) o : null ; }
public void set annotation filter ( annotation filter annotation filter ) { this . annotation filter = annotation filter ; }
public annotation filter get annotation filter ( ) { return annotation filter ; }
public void add text ( string text ) { this . text = text ; }
public void previous page ( ) { if ( ! be first page ( ) ) { this . page -- ; } }
public void set separator ( string separator ) { this . separator = separator ; }
protect void set name source start ( int start ) { this . name start= start ; }
public void set sort by position ( boolean v ) { default config . set sort by position ( v ) ; }
public double get x ( ) { return x ; }
public void set default scale ( final int scale ) { this . m scale = scale ; }
public string get path translate ( ) { return this . _get http servlet request ( ) . get path translate ( ) ; }
public static < t > boolean list contains duplicate ( list < t > list ) { return list . size ( ) ! = new hash set < > ( list ) . size ( ) ; }
public vector get target ( ) { return target vector ; }
public string get doc ( ) { return doc ; }
public detail cookie matcher path ( matcher < ? super string > path matcher ) { return new detailed cookie matcher ( and ( matcher . have property ( `` path `` , path matcher ) ) ) ; }
public void destroy ( ) { unregister from m bean notification ( ) ; mbean server . destroy ( ) ; }
public static thread start ( thread thread , long timeout ) { thread monitor = null ; if ( timeout > 0 ) { thread monitor timout = new thread monitor ( thread , timeout ) ; monitor = new thread ( timout , thread monitor . class . get simple name ( ) ) ; monitor . set daemon ( true ) ; monitor . start ( ) ; } return monitor ; }
public int get threshold ( ) { return threshold ; }
public string name ( ) { return name ; }
public static list < method > get declare method include inherit ( class < ? > clazz ) { list < method > method = new array list < method > ( ) ; while ( clazz ! = null ) { for ( method method : clazz . get declare method ( ) ) { method . add ( method ) ; } clazz = clazz . get superclass ( ) ; } return method ; }
public void set master ( boolean master ) { m master = master ; }
public string [ ] get exclude mime type ( ) { set < string > exclude = _mime type . get excluded ( ) ; return exclude . to array ( new string [ exclude . size ( ) ] ) ; }
public static map synchronize map ( map map ) { return collection . synchronize map ( map ) ; }
public void set vertex ( float [ ] vertex ) { c o s array new vertex = new c o s array ( ) ; new vertex . set float array ( vertex ) ; annot . set item ( c o s name . vertex , new vertex ) ; }
public node get parent ( ) { return parent ; }
public int size ( ) { if ( root ! = null ) return root . size ( ) ; return 0 ; }
public string get file name ( ) { return file name ; }
public file get file ( ) { return file ; }
public static string get filter trace ( throwable t ) { string writer string writer= new string writer ( ) ; print writer writer= new print writer ( string writer ) ; t . print stack trace ( writer ) ; string buffer buffer= string writer . get buffer ( ) ; string trace= buffer . to string ( ) ; return base test runner . get filtered trace ( trace ) ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public string get family name ( ) { return family name ; }
public string get filename ( ) { return filename ; }
public void set src ( file src ) { set src resource ( new file resource ( src ) ) ; }
public void dispose ( ) { detach ( ) ; }
public arg create arg ( boolean insert at start ) { arg argument = new argument ( ) ; if ( insert at start ) { argument . add ( 0 , argument ) ; } else { argument . add ( argument ) ; } return argument ; }
public synchronize string [ ] get not include file ( ) { slow scan ( ) ; string [ ] file = new string [ file not include . size ( ) ] ; file not include . copy into ( file ) ; return file ; }
public int get value ( ) { return family ; }
public short get index ( ) { return ( short ) index ; }
public static cluster id converter new instance ( @ suppress warning ( `` unused `` ) final string [ ] option ) { return new cluster id converter ( ) ; }
public int length ( ) { return info . length + 6 ; }
public void fill ( int value ) { array . fill ( data , value ) ; }
public void add ( byte [ ] element , int start , int length ) { assert length > = 0 : `` length must be > = 0 `` ; ensure buffer space ( length ) ; system . arraycopy ( element , start , buffer , element count , length ) ; element count += length ; }
public static void set thread prefers event extractor ( boolean prefer event extractor ) { thread prefer event extractor . set ( prefer event extractor ) ; }
public static boolean get thread prefers event extractor ( ) { return thread prefer event extractor . get ( ) ; }
public static int index of ( byte byte [ ] , int start , int end , char s ) { int offset = start ; while ( offset < end ) { byte b = bytes [ offset ] ; if ( b == s ) { return offset ; } offset++ ; } return -1 ; }
public void set count ( int count ) { this . count = count ; }
public final byte [ ] get byte array ( ) { return this . byte array ; }
public void remove subject ( ) { remove1st property ( property i d map . pid_subject ) ; }
public void remove subject ( ) { remove1st property ( property i d map . pid_subject ) ; }
public string get status ( ) { return this . status ; } // -- string get status ( )
public file get file ( ) { return f file ; }
public final string get id ( ) { return id ; }
public void remove docparts ( ) { remove1st property ( property i d map . pid_docparts ) ; }
public string get last printed property string ( ) { return get date value ( last print ) ; }
public void remove subject ( ) { remove1st property ( property i d map . pid_subject ) ; }
public string get name ( ) { return name ; } // get name
public summary information get summary information ( ) { if ( ! initialize ) { read property ( ) ; } return s inf ; }
public string get comment ( ) { return comment ; }
public string get style sheet ( ) { return style sheet ; }
protect void possibly save ( ) { if ( auto save & & file name ! = null ) { try { save ( ) ; } catch ( configuration exception e ) { throw new configuration runtime exception ( `` fail to auto-save `` , e ) ; } } }
public static void set border left ( border style border , cell range address region , sheet sheet ) { int row start = region . get first row ( ) ; int row end = region . get last row ( ) ; int column = region . get first column ( ) ; cell property setter cps = new cell property setter ( cell util . border_left , border ) ; for ( int i = row start ; i < = row end ; i++ ) { cps . set property ( cell util . get row ( i , sheet ) , column ) ; } }
public static string get name ( int sid ) { return sid2str [ sid ] ; }
public void set header ( string header ) { this . header = header ; }
protect integer get basic row ( final int col ) { final int row = basic variable [ col ] ; return row == -1 ? null : row ; }
public static < t extend escher record > t get escher child ( escher container record owner , int record id ) { return owner . get child by id ( ( short ) record id ) ; }
public void row process ( string [ ] row , t context ) { row . add ( row ) ; }
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public void set brc top ( border code field_20_brc top ) { this . field_20_brc top = field_20_brc top ; }
public void set border color ( color color ) { ( ( gutter border ) get border ( ) ) . set color ( color ) ; repaint ( ) ; }
public ct type reference < short > short type ( ) { return short . clone ( ) ; }
public void set include sheet name ( boolean include sheet name ) { _include sheet name = include sheet name ; }
public void set background ( color color ) { if ( color == null ) return ; _background = color ; }
public void set flag ( byte flag ) { this . flag = flag ; }
public void set format flag ( short field_1_format flag ) { this . field_1_format flag = field_1_format flag ; }
public stack get stack ( ) { return stack ; }
protect void set internal date ( final string date ) { this . date = date ; }
public field vector3 d < t > get axis ( ) { return get axis ( rotation convention . vector_operator ) ; }
public int frequency ( int key ) { return frequency . frequency ( key ) ; }
public int frequency ( int key ) { return frequency . frequency ( key ) ; }
public void set height ( short height ) { field_4_height = height ; }
public option get option ( ) { return option ; }
public float get horizontal scaling ( ) { return horizontal scaling ; }
public void set index ( int index ) { this . index = index ; }
public void set auto update ( string auto update ) { this . auto update = auto update ; } // -- void set auto update ( string )
public short get y ( ) { return field_2_y ; }
public void set size ( long size ) { this . size = size ; }
public static u t f8 string blank string ( int length ) { byte [ ] space = new byte [ length ] ; array . fill ( space , ( byte ) ' ' ) ; return from byte ( space ) ; }
public i unknown get i unknown ( ) { return i unknown ; }
public boolean be custom ( string key ) { return ( get state ( key ) == state . custom ) ; }
public short get index ( ) { return ( short ) index ; }
public static short to short ( object value ) throw conversion exception { number n = to number ( value , short . class ) ; if ( n instanceof short ) { return ( short ) n ; } else { return new short ( n . short value ( ) ) ; } }
public void set default scale ( final int scale ) { this . m scale = scale ; }
public void set format flag ( short field_1_format flag ) { this . field_1_format flag = field_1_format flag ; }
public void set format flag ( short field_1_format flag ) { this . field_1_format flag = field_1_format flag ; }
public short value ( ) { return value ; }
public void set id ( string id ) { this . id = id ; }
public void add text ( string text ) { this . text = text ; }
public int get group index ( ) { return group idx ; }
public vertical alignment get vertical ( ) { s t vertical alignment . enum align = cell alignement . get vertical ( ) ; if ( align == null ) align = s t vertical alignment . bottom ; return vertical alignment . value ( ) [ align . int value ( ) - 1 ] ; }
public void set background ( color color ) { if ( color == null ) return ; _background = color ; }
public void set height ( short height ) { field_4_height = height ; }
public void set show label ( boolean value ) { field_1_format flag = show label . set short boolean ( field_1_format flag , value ) ; }
public void stop ( ) { if ( ! run ) throw new illegal state exception ( ) ; elapse = tick . tick ( ) - start ; run = false ; }
public time value get background persist interval ( ) { return background persist interval ; }
public void set text rotation ( long rotation ) { if ( rotation < 0 & & rotation > = -90 ) { rotation = 90 + ( ( -1 ) * rotation ) ; } cell alignement . set text rotation ( rotation ) ; }
public void increment ( ) { value++ ; }
public void set default scale ( final int scale ) { this . m scale = scale ; }
public void set ( boolean value ) { this . value = value ; }
public void set type ( int type ) { this . type = type ; }
public boolean be printable ( ) { return printable . be set ( field_3_option ) ; }
public void set printable ( boolean value ) { field_3_option = printable . set short boolean ( field_3_option , value ) ; }
public record [ ] get child record ( ) { return null ; }
public boolean be no prefix ( ) { return no prefix ; }
public static int next high power of two ( int v ) { v -- ; v |= v > > 1 ; v |= v > > 2 ; v |= v > > 4 ; v |= v > > 8 ; v |= v > > 16 ; v++ ; return v ; }
protect string builder append to ( string builder builder ) { return task id . append to ( builder ) . append ( separator ) . append ( id ) ; }
public void remove note ( string name ) { note . remove ( name ) ; }
public short get option flag ( ) { return field_1_option_flag ; }
public int get index ( ) { return index ; }
protect void update data ( ) { font family combo . set select item ( style constant . get font family ( current style ) ) ; font size combo . set select item ( new integer ( style constant . get font size ( current style ) ) . to string ( ) ) ; bold chk . set select ( style constant . be bold ( current style ) ) ; italic chk . set select ( style constant . be italic ( current style ) ) ; italic chk . set select ( style constant . be italic ( current style ) ) ; underline chk . set select ( style constant . be underline ( current style ) ) ; subscript chk . set select ( style constant . be subscript ( current style ) ) ; superscript chk . set select ( style constant . be superscript ( current style ) ) ; strikethrough chk . set select ( style constant . be strike through ( current style ) ) ; if ( current style . be define ( style constant . foreground ) ) { fg chooser . set color ( style constant . get foreground ( current style ) ) ; use foreground chk . set select ( true ) ; } else use foreground chk . set select ( false ) ; if ( current style . be define ( style constant . background ) ) { bg chooser . set color ( style constant . get background ( current style ) ) ; use background chk . set select ( true ) ; } else use background chk . set select ( false ) ; } // protect void update data ( )
public void row process ( string [ ] row , t context ) { row . add ( row ) ; }
public string get address ( ) { return this . address ; } // -- string get address ( )
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public void add text ( string text ) { this . text = text ; }
public static boolean have flag ( int option , int flag ) { return ( ( option & flag ) > 0 ) ; }
public boolean be function ( ) { return this . function ; }
public void set last column ( int col ) { set first column ( col ) ; }
public short get y maximum ( ) { return y max ; }
public synchronize void set flag ( flags flag , boolean set ) throw message exception { if ( set ) flag . add ( flag ) ; else flag . remove ( flag ) ; }
public record find first record by sid ( short sid ) { int ix = find first record loc by sid ( sid ) ; if ( ix < 0 ) { return null ; } return ( record ) _records . get ( ix ) ; }
public void set chart leave margin ( long margin ) { ct inline . set dist l ( margin ) ; }
public void set column ( int col ) { field_2_col = col ; }
public int get height ( ) { return field_4_height ; }
public static int get hi ( long encode ) { return ( int ) ( ( encode > > 32 ) & 0x f f f f_ f f f f l ) ; }
public boolean be boolean ( ) { return false ; }
public t get ( ) { return t ; }
public short get index ( ) { return ( short ) index ; }
public boolean be quote ( ) { return be quote ; }
public short get fit height ( ) { return print setup record . get fit height ( ) ; }
public void set style ( style style ) { this . style = style ; }
public entity i d get trust anchor ( ) { return anchor ; }
public static string get short name a property ( class < ? > clazz ) { string short name = get short name ( clazz ) ; int dot index = short name . last index of ( package_separator ) ; short name = ( dot index ! = -1 ? short name . substring ( dot index + 1 ) : short name ) ; return introspector . decapitalize ( short name ) ; }
public string get charset ( ) { return charset ; }
public int get char set ( ) { byte charset = font . get charset ( ) ; if ( charset > = 0 ) { return charset ; } else { return charset + 256 ; } }
public string get property ( string name ) { return prop . get property ( name ) ; }
public record [ ] get child record ( ) { return null ; }
public void set height ( short height ) { field_4_height = height ; }
public string get format ( ) { return format ; }
public static long encode ( int hi , int lo ) { long h = ( ( long ) hi ) & 0x f f f f_ f f f f l ; long l = ( ( long ) lo ) & 0x f f f f_ f f f f l ; return ( h < < 32 ) + l ; }
public void set margin bottom ( int margin bottom ) { set property value ( new escher simple property ( escher property . text__textbottom , margin bottom ) ) ; }
public int get margin bottom ( ) { escher simple property property = get opt record ( ) . lookup ( escher property . text__textbottom ) ; return property == null ? 0 : property . get property value ( ) ; }
public summary information get summary information ( ) { if ( ! initialize ) { read property ( ) ; } return s inf ; }
public document summary information get document summary information ( ) { if ( ! initialize ) { read property ( ) ; } return ds inf ; }
public void write ( file new file ) throw i o exception { try ( p o i f s file system fs = p o i f s file system . create ( new file ) ) { write ( f ) ; f . write filesystem ( ) ; } }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public void set file storage directory ( path file storage directory ) throw i o exception { assert . not null ( file storage directory , `` file storage directory must not be null `` ) ; this . file storage = file storage . from path ( file storage directory ) ; }
public void set root directory ( file root directory ) { this . root directory = root directory ; }
public static void main ( string args [ ] ) throw i o exception { if ( args . length < 1 ) { system . err . println ( `` useage : `` ) ; system . err . println ( `` \t power point extractor [ -notes ] < file > `` ) ; system . exit ( 1 ) ; } boolean note = false ; boolean comment = false ; boolean master = true ; string file ; if ( args . length > 1 ) { note = true ; file = args [ 1 ] ; if ( args . length > 2 ) { comment = true ; } } else { file = args [ 0 ] ; } power point extractor ppe = new power point extractor ( file ) ; system . out . println ( ppe . get text ( true , note , comment , master ) ) ; ppe . close ( ) ; }
public string get output dir ( ) { return output dir ; }
public synchronize void set child ( hash set < string > child ) { this . child = child ; }
public void set name ( string name ) { _name = name ; }
public boolean be free ( long po , int length ) { int start = get block ( po ) ; int block = get block count ( length ) ; for ( int i = start ; i < start + block ; i++ ) { if ( set . get ( i ) ) { return false ; } } return true ; }
public void set min x ( string value ) { this . min x = value ; }
public sys property get system property ( ) { return sys property ; }
public output < v > idx ( ) { return idx ; }
public void set embed id ( jaxb embed id value ) { this . embed id = value ; }
public void set value ( t t ) { this . value = t ; }
public void set ( int value ) { this . value = value ; }
public int read off size ( ) throw i o exception { int off size = read unsigned byte ( ) ; if ( off size < 1 || off size > 4 ) { throw new i o exception ( `` illegal ( < 1 or > 4 ) off size value `` + off size + `` in cff font at position `` + ( get position ( ) - 1 ) ) ; } return off size ; }
public void set ( int value ) { this . value = value ; }
public void set max history ( int max history ) { this . max history = max history ; }
public static string any string ( ) { return report matcher ( any . any ) . return string ( ) ; }
public void pop wrapper ( ) { if ( w stack . size ( ) > 0 ) { w stack . remove element at ( w stack . size ( ) - 1 ) ; } }
public void set stroke adjustment ( boolean value ) { stroke adjustment = value ; }
public void set scale option ( string option ) { fit . set name ( c o s name . sw , option ) ; }
public string get public i d ( ) { return public i d ; }
public boolean be g m t ( ) { return __is g m t ; }
public void set ( int value ) { this . value = value ; }
public static affine transformation create from control vector ( coordinate src0 , coordinate dest0 ) { double dx = dest0 . x - src0 . x ; double dy = dest0 . y - src0 . y ; return affine transformation . translation instance ( dx , dy ) ; }
public void set x ( string value ) { this . x = value ; }
public font box font get font box font ( ) { if ( cid font ! = null ) { return cid font ; } else { return t1 font ; } }
public double get shape ( ) { return shape ; }
public static point decode ( string geohash , spatial context ctx ) { rectangle rect = decode boundary ( geohash , ctx ) ; double latitude = ( rect . get min y ( ) + rect . get max y ( ) ) / 2d ; double longitude = ( rect . get min x ( ) + rect . get max x ( ) ) / 2d ; return ctx . make point ( longitude , latitude ) ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public static affine transformation rotation instance ( double theta , double x , double y ) { return rotation instance ( math . sin ( theta ) , math . co ( theta ) , x , y ) ; }
public matcher transform type get transform ( ) { return transform ; }
public color load color ( property skin property , string color property name ) { color color = null ; string color value = skin property . get property ( color property name , null ) ; log . debug ( `` load skin color with property ' `` + color property name + `` ' , value : `` + color value ) ; if ( color value ! = null ) { color = color . decode ( color value ) ; } else { log . warn ( `` color be not available for property ' `` + color property name + `` ' `` ) ; } return color ; }
public void set render hint ( map hint ) { render hint = hint ; }
public void remove note ( string name ) { note . remove ( name ) ; }
public string text ( ) { string builder sb = new string builder ( ) ; for ( element element : this ) { if ( sb . length ( ) ! = 0 ) sb . append ( `` `` ) ; sb . append ( element . text ( ) ) ; } return sb . to string ( ) ; }
public long get d ( ) { return d ; }
public final int int value ( ) { return fd ; }
public static double link ( double r ) { if ( r < 0 . 0 ) { double s = math . exp ( r ) ; return s / ( 1 . 0 + s ) ; } else { double s = math . exp ( -r ) ; return 1 . 0 / ( 1 . 0 + s ) ; } }
public void set first row ( int first row ) { _range . set first row ( first row ) ; }
public void row process ( string [ ] row , t context ) { row . add ( row ) ; }
public int to r g b ( ) throw i o exception { float [ ] float = color space . to r g b ( component ) ; int r = math . round ( floats [ 0 ] * 255 ) ; int g = math . round ( floats [ 1 ] * 255 ) ; int b = math . round ( floats [ 2 ] * 255 ) ; int rgb = r ; rgb = ( rgb < < 8 ) + g ; rgb = ( rgb < < 8 ) + b ; return rgb ; }
public string get family name ( ) { return family name ; }
public void row process ( string [ ] row , t context ) { row . add ( row ) ; }
public static void set border left ( border style border , cell range address region , sheet sheet ) { int row start = region . get first row ( ) ; int row end = region . get last row ( ) ; int column = region . get first column ( ) ; cell property setter cps = new cell property setter ( cell util . border_left , border ) ; for ( int i = row start ; i < = row end ; i++ ) { cps . set property ( cell util . get row ( i , sheet ) , column ) ; } }
public void row process ( string [ ] row , t context ) { row . add ( row ) ; }
public double get double l e ( int index ) { return double . long bit to double ( get long l e ( index ) ) ; }
public static row get row ( int row index , sheet sheet ) { row row = sheet . get row ( row index ) ; if ( row == null ) { row = sheet . create row ( row index ) ; } return row ; }
public void append ( char [ ] src array ) { final int length = src array . length ; ensure capacity ( length ) ; system . arraycopy ( src array , 0 , array , use , length ) ; use += length ; }
public void set total count ( int total count ) { this . total count = total count ; }
public void set float value ( float float value ) { this . float value = float value ; }
public int get int value ( ) { return 0 ; }
public static void put u int ( byte [ ] data , int offset , long value ) { int i = offset ; data [ i++ ] = ( byte ) ( ( value > > > 0 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 8 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 16 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 24 ) & 0x f f ) ; }
public void write u int ( long value ) { try { out . write ( ( byte ) ( ( value ) & 0x f f ) ) ; out . write ( ( byte ) ( ( value > > > 8 ) & 0x f f ) ) ; out . write ( ( byte ) ( ( value > > > 16 ) & 0x f f ) ) ; out . write ( ( byte ) ( ( value > > > 24 ) & 0x f f ) ) ; } catch ( i o exception e ) { throw new runtime exception ( e ) ; } }
public static void put u int ( byte [ ] data , int offset , long value ) { int i = offset ; data [ i++ ] = ( byte ) ( ( value > > > 0 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 8 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 16 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 24 ) & 0x f f ) ; }
public int read ( ) throw i o exception { throw new i o exception ( ) ; }
public byte read w p byte ( ) throw i o exception { return in . read byte ( ) ; }
public byte [ ] get byte ( ) { return byte ; }
public static numeric entity escaper between ( int codepoint low , int codepoint high ) { return new numeric entity escaper ( codepoint low , codepoint high , true ) ; }
public void import package ( string package name ) { import package . add ( package name ) ; }
public o p c package get package ( ) { return _document . get package ( ) ; }
public void set property ( string property ) { this . property = property ; }
public static void send part ( output stream out , final part [ ] part ) throw i o exception { send part ( out , part , default_boundary_bytes ) ; }
public string get file name ( ) { return file name ; }
public void set content type ( string content type ) { assert . not null ( content type , `` 'content type ' must not be null `` ) ; this . content type = content type ; }
protect string list get category ( ) { return this . category ; }
public void set last printed ( final date last print ) { get first section ( ) . set property ( property i d map . pid_lastprinted , variant . vt_filetime , last print ) ; }
public list < string > get modify file ( ) { return modify file ; }
public void set remove pack file ( final boolean remove pack file ) { this . remove pack file = remove pack file ; }
public void register part and content type ( package part part ) { add package part ( part ) ; this . content type manager . add content type ( part . get part name ( ) , part . get content type ( ) ) ; this . be dirty = true ; }
public void register part and content type ( package part part ) { add package part ( part ) ; this . content type manager . add content type ( part . get part name ( ) , part . get content type ( ) ) ; this . be dirty = true ; }
public package part create part ( package part name part name , string content type ) { return this . create part ( part name , content type , true ) ; }
public list fragment ( ) { return this . fragment ; }
public static uri get path ( uri uri ) { if ( uri ! = null ) { string path = uri . get path ( ) ; int num2 = path . length ( ) ; while ( -- num2 > = 0 ) { char ch1 = path . char at ( num2 ) ; if ( ch1 == packaging u r i helper . forward_slash_char ) { try { return new uri ( path . substring ( 0 , num2 ) ) ; } catch ( u r i syntax exception e ) { return null ; } } } } return null ; }
public static string get filename ( uri uri ) { if ( uri ! = null ) { string path = uri . get path ( ) ; int len = path . length ( ) ; int num2 = len ; while ( -- num2 > = 0 ) { char ch1 = path . char at ( num2 ) ; if ( ch1 == packaging u r i helper . forward_slash_char ) return path . substring ( num2 + 1 , len ) ; } } return `` `` ; }
public package part create part ( package part name part name , string content type ) { return this . create part ( part name , content type , true ) ; }
public void set in stream ( in stream stream ) { this . stream = stream ; }
public list < byte > get byte list ( string key ) { return get byte list ( key , new array list < byte > ( ) ) ; }
public string get name space uri ( ) { return this . name space uri ; }
public short get chart group index ( ) { return field_1_chart group index ; }
public void set author ( string author ) { _comment . set author id ( _comments . find author ( author ) ) ; }
public void write ( final kryo kryo , final output output , final t t ) { / * these adapter could be cache pretty efficiently in instance field if it be guarantee that this * class be never subject to concurrent use . that 's true of kryo instance , but it be not clear that * it be true of serializer instance . * / final shade kryo adapter shade kryo adapter = new shade kryo adapter ( kryo ) ; final shade output adapter shade output adapter = new shade output adapter ( output ) ; serializer . write ( shaded kryo adapter , shade output adapter , t ) ; }
public double get shape ( ) { return shape ; }
public int get next pic name number ( int format ) throw invalid format exception { int img = get all package picture ( ) . size ( ) + 1 ; string proposal = x w p f picture data . relation [ format ] . get file name ( img ) ; package part name create part name = packaging u r i helper . create part name ( proposal ) ; while ( this . get package ( ) . get part ( create part name ) ! = null ) { img++ ; proposal = x w p f picture data . relation [ format ] . get file name ( img ) ; create part name = packaging u r i helper . create part name ( proposal ) ; } return img ; }
public static void put u int ( byte [ ] data , int offset , long value ) { int i = offset ; data [ i++ ] = ( byte ) ( ( value > > > 0 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 8 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 16 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 24 ) & 0x f f ) ; }
public static boolean be valid ( string name ) { if ( name == null ) { throw new illegal argument exception ( `` name be miss `` ) ; } boolean slash = false ; for ( int i = 0 ; i < name . length ( ) ; i++ ) { char ch = name . char at ( i ) ; if ( ch < = ' ' || ch > = 127 || ch == ' ( ' || ch == ' ) ' || ch == ' < ' || ch == ' > ' || ch == ' @ ' || ch == ' , ' || ch == ' ; ' || ch == ' : ' || ch == '\\ ' || ch == ' `` ' || ch == ' [ ' || ch == ' ] ' || ch == ' ? ' || ch == '= ' ) { return false ; } else if ( ch == '/ ' ) { if ( slash || i == 0 || i + 1 == name . length ( ) ) { return false ; } slash = true ; } } return slash ; }
public string get comment ( ) { return comment ; }
public boolean be track revision ( ) { return setting . be track revision ( ) ; }
public void set select ( expression select , configuration config ) throw x path exception { this . select = select ; adopt child expression ( select ) ; }
public string get name ( ) { return name ; } // get name
public boolean force ( ) { return force ; }
public string get name ( ) { return name ; } // get name
public void set vertical alignment ( byte field_2_vertical alignment ) { this . field_2_vertical alignment = field_2_vertical alignment ; }
public short get rotation ( ) { return rotation . get short value ( field_10_options ) ; }
public void set background ( color color ) { if ( color == null ) return ; _background = color ; }
public void set strip space ( int strip action ) { option . set strip space ( strip action ) ; }
public string get author ( ) { return author ; }
public string get text ( ) { return f text ; }
public static double inv gamma1pm1 ( final double x ) { if ( x < -0 . 5 ) { throw new number be too small exception ( x , -0 . 5 , true ) ; } if ( x > 1 . 5 ) { throw new number be too large exception ( x , 1 . 5 , true ) ; } final double ret ; final double t = x < = 0 . 5 ? x : ( x - 0 . 5 ) - 0 . 5 ; if ( t < 0 . 0 ) { final double a = inv_gamma1p_m1_a0 + t * inv_gamma1p_m1_a1 ; double b = inv_gamma1p_m1_b8 ; b = inv_gamma1p_m1_b7 + t * b ; b = inv_gamma1p_m1_b6 + t * b ; b = inv_gamma1p_m1_b5 + t * b ; b = inv_gamma1p_m1_b4 + t * b ; b = inv_gamma1p_m1_b3 + t * b ; b = inv_gamma1p_m1_b2 + t * b ; b = inv_gamma1p_m1_b1 + t * b ; b = 1 . 0 + t * b ; double c = inv_gamma1p_m1_c13 + t * ( a / b ) ; c = inv_gamma1p_m1_c12 + t * c ; c = inv_gamma1p_m1_c11 + t * c ; c = inv_gamma1p_m1_c10 + t * c ; c = inv_gamma1p_m1_c9 + t * c ; c = inv_gamma1p_m1_c8 + t * c ; c = inv_gamma1p_m1_c7 + t * c ; c = inv_gamma1p_m1_c6 + t * c ; c = inv_gamma1p_m1_c5 + t * c ; c = inv_gamma1p_m1_c4 + t * c ; c = inv_gamma1p_m1_c3 + t * c ; c = inv_gamma1p_m1_c2 + t * c ; c = inv_gamma1p_m1_c1 + t * c ; c = inv_gamma1p_m1_c + t * c ; if ( x > 0 . 5 ) { ret = t * c / x ; } else { ret = x * ( ( c + 0 . 5 ) + 0 . 5 ) ; } } else { double p = inv_gamma1p_m1_p6 ; p = inv_gamma1p_m1_p5 + t * p ; p = inv_gamma1p_m1_p4 + t * p ; p = inv_gamma1p_m1_p3 + t * p ; p = inv_gamma1p_m1_p2 + t * p ; p = inv_gamma1p_m1_p1 + t * p ; p = inv_gamma1p_m1_p0 + t * p ; double q = inv_gamma1p_m1_q4 ; q = inv_gamma1p_m1_q3 + t * q ; q = inv_gamma1p_m1_q2 + t * q ; q = inv_gamma1p_m1_q1 + t * q ; q = 1 . 0 + t * q ; double c = inv_gamma1p_m1_c13 + ( p / q ) * t ; c = inv_gamma1p_m1_c12 + t * c ; c = inv_gamma1p_m1_c11 + t * c ; c = inv_gamma1p_m1_c10 + t * c ; c = inv_gamma1p_m1_c9 + t * c ; c = inv_gamma1p_m1_c8 + t * c ; c = inv_gamma1p_m1_c7 + t * c ; c = inv_gamma1p_m1_c6 + t * c ; c = inv_gamma1p_m1_c5 + t * c ; c = inv_gamma1p_m1_c4 + t * c ; c = inv_gamma1p_m1_c3 + t * c ; c = inv_gamma1p_m1_c2 + t * c ; c = inv_gamma1p_m1_c1 + t * c ; c = inv_gamma1p_m1_c0 + t * c ; if ( x > 0 . 5 ) { ret = ( t / x ) * ( ( c - 0 . 5 ) - 0 . 5 ) ; } else { ret = x * c ; } } return ret ; }
public ex hyperlink [ ] get ex hyperlink ( ) { array list < ex hyperlink > link = new array list < > ( ) ; for ( int i=0 ; i < _children . length ; i++ ) { if ( _children [ i ] instanceof ex hyperlink ) { link . add ( ( ex hyperlink ) _children [ i ] ) ; } } return link . to array ( new ex hyperlink [ link . size ( ) ] ) ; }
public void clear ( ) { list < x s l f shape > shape = new array list < > ( get shape ( ) ) ; for ( x s l f shape shape : shape ) { remove shape ( shape ) ; } }
public boolean get different odd even ( ) { return get header footer ( ) . be set different odd even ( ) ? get header footer ( ) . get different odd even ( ) : false ; }
public string get current macro name ( ) { if ( macro name stack . empty ( ) ) { return `` < undef > `` ; } else { return macro name stack . peek ( ) ; } }
public string get name ( ) { return property name ; }
public void set different odd even ( boolean flag ) { get header footer ( ) . set different odd even ( flag ) ; }
public boolean get different odd even ( ) { return get header footer ( ) . be set different odd even ( ) ? get header footer ( ) . get different odd even ( ) : false ; }
public void set chart leave margin ( long margin ) { ct inline . set dist l ( margin ) ; }
public void set column ( int col ) { field_2_col = col ; }
public void set st offset ( int st ) { this . st offset = st ; }
public string get display name ( ) { return display name ; }
public void set refid ( reference ref ) { this . ref = ref ; }
public string get id ( ) { return id ; }
public void set column name ( string column name ) { this . column name = column name ; }
public parser configuration set tab size ( int tab size ) { this . tab size = tab size ; return this ; }
public static < t > async data fetcher < t > async ( data fetcher < t > wrap data fetcher , executor executor ) { return new async data fetcher < > ( wrap data fetcher , executor ) ; }
public string get text type ( ) { return f text type ; }
public p o i x m l property get property ( ) { if ( property == null ) { try { property = new p o i x m l property ( pkg ) ; } catch ( exception e ) { throw new p o i x m l exception ( e ) ; } } return property ; }
public void set height ( short height ) { field_4_height = height ; }
public boolean get mirror margin ( ) { return setting . get mirror margin ( ) ; }
public void set text ( string text ) { if ( text == null ) { get header footer ( ) . unset even footer ( ) ; if ( ! get header footer ( ) . be set even header ( ) ) { get header footer ( ) . unset different odd even ( ) ; } } else { get header footer ( ) . set even footer ( text ) ; } }
public void add paragraph ( x w p f paragraph p ) { paragraph . add ( p ) ; }
public void set style ( style style ) { this . style = style ; }
public void insert table ( int po , x w p f table table ) { body element . add ( po , table ) ; int i = 0 ; for ( c t tbl tbl : ct document . get body ( ) . get tbl array ( ) ) { if ( tbl == table . get c t tbl ( ) ) { break ; } i++ ; } table . add ( i , table ) ; }
public boolean be form list ( ) { return form list ; }
public password new password ( string password ) { return new password ( password ) ; }
public string get revision ( ) { return revision ; }
public float get remain percent ( ) { return d f s util . get percent remain ( remain , capacity ) ; }
public void set different odd even ( boolean flag ) { get header footer ( ) . set different odd even ( flag ) ; }
public void set chart leave margin ( long margin ) { ct inline . set dist l ( margin ) ; }
public void set table ( int po , x w p f table table ) { table . set ( po , table ) ; ct document . get body ( ) . set tbl array ( po , table . get c t tbl ( ) ) ; }
public package part create part ( package part name part name , string content type ) { return this . create part ( part name , content type , true ) ; }
public iterator < string > get note name ( ) { return note . key set ( ) . iterator ( ) ; }
public string get ref ( ) { return ref ; }
public void add paragraph ( x w p f paragraph p ) { paragraph . add ( p ) ; }
public int get request num ( ) { return m request num ; }
public string get language ( ) { return language ; }
public void set spelling language ( string str spell language ) { c t language lang = get c t language ( ) ; lang . set val ( str spell language ) ; lang . set bidi ( str spell language ) ; }
public x w p f paragraph create paragraph ( ) { x w p f paragraph paragraph = new x w p f paragraph ( header footer . add new p ( ) , this ) ; paragraph . add ( paragraph ) ; body element . add ( paragraph ) ; return paragraph ; }
public integer get width ( ) { return width ; }
public void set header ( string header ) { this . header = header ; }
public static i o service get matching service ( string service name ) { c f mutable dictionary ref dict = io . i o service match ( service name ) ; if ( dict ! = null ) { return get matching service ( dict ) ; } return null ; }
public void set header ( string header ) { this . header = header ; }
public m a p i message get m a p i message ( ) { return ( m a p i message ) document ; }
public static < t extend escher record > t get escher child ( escher container record owner , int record id ) { return owner . get child by id ( ( short ) record id ) ; }
public void clear ( ) { mod count++ ; final hash entry < k , v > [ ] data = this . data ; for ( int i = data . length - 1 ; i > = 0 ; i -- ) { data [ i ] = null ; } size = 0 ; }
public static void main ( string args [ ] ) throw i o exception { if ( args . length == 0 ) { system . err . println ( `` use : `` ) ; system . err . println ( `` v b a macro extractor < office . doc > [ output ] `` ) ; system . err . println ( `` `` ) ; system . err . println ( `` if an output directory be give , macro be write there `` ) ; system . err . println ( `` otherwise they be output to the screen `` ) ; system . exit ( 1 ) ; } file input = new file ( args [ 0 ] ) ; file output = null ; if ( args . length > 1 ) { output = new file ( args [ 1 ] ) ; } v b a macro extractor extractor = new v b a macro extractor ( ) ; extractor . extract ( input , output ) ; }
public void set footer text ( string text ) { set footer visible ( true ) ; c string c = _container . get footer atom ( ) ; if ( cs == null ) { cs = _container . add footer atom ( ) ; } c . set text ( text ) ; }
public void set header text ( string text ) { set header visible ( true ) ; c string c = _container . get header atom ( ) ; if ( cs == null ) { cs = _container . add header atom ( ) ; } c . set text ( text ) ; }
public boolean be set ( int mask ) { return ( attribute & mask ) ! = 0 ; }
public void set idx ( long value ) { this . idx = value ; }
public boolean equal ( object other ) { return ( this == other || ( other instanceof bean component definition & & super . equal ( other ) ) ) ; }
public int get type ( ) { return little endian . get int ( _data , 4 ) ; }
public int get type ( ) { return little endian . get int ( _data , 4 ) ; }
public void set include slide master content ( boolean include slide master content ) { this . include slide master content = include slide master content ; }
public font box font get font box font ( ) { if ( cid font ! = null ) { return cid font ; } else { return t1 font ; } }
public long get record type ( ) { return _type ; }
public void try terminate and report ( ) { throwable ex = terminate ( ) ; if ( ex ! = null & & ex ! = exception helper . terminate ) { rx java plugins . on error ( ex ) ; } }
public x s s f hyperlink create hyperlink ( hyperlink type type ) { return new x s s f hyperlink ( type ) ; }
public string get cert nonce seed ( ) { return cert nonce seed ; }
public int get type ( ) { return little endian . get int ( _data , 4 ) ; }
public int get draw aspect ( ) { return little endian . get int ( _data , 0 ) ; }
public void write ( data output out ) throw i o exception { out . write ( code ) ; }
public string get indent ( ) { return indent ; }
public static < t extend escher record > t get escher child ( escher container record owner , int record id ) { return owner . get child by id ( ( short ) record id ) ; }
public int get option ( ) { return little endian . get short ( _header ) ; }
public record [ ] get record ( ) { return _records ; }
public static < r extend record > table < r > table ( r record ) { return table ( ( r [ ] ) new record [ ] { record } ) ; }
public string get name ( ) { return _name ; }
public int size ( ) { return size ; }
public long get record type ( ) { return _type ; }
public list < text prop collection > get character style ( ) { return char style ; }
public long get record type ( ) { return _type ; }
public long get record type ( ) { return _type ; }
public void set style ( style style ) { this . style = style ; }
public long get record type ( ) { return _type ; }
public void set idx ( long value ) { this . idx = value ; }
public x w p f paragraph create paragraph ( ) { x w p f paragraph paragraph = new x w p f paragraph ( header footer . add new p ( ) , this ) ; paragraph . add ( paragraph ) ; body element . add ( paragraph ) ; return paragraph ; }
public void set anchor type ( anchor type anchor type ) { _escher client anchor . set flag ( anchor type . value ) ; }
public escher record find first with id ( short id ) { return find first with id ( id , get escher record ( ) ) ; }
public record [ ] get child record ( ) { return null ; }
public void set background ( color color ) { if ( color == null ) return ; _background = color ; }
public record [ ] get child record ( ) { return null ; }
public synchronize void write ( int b ) { write ( new byte [ ] { ( byte ) b } , 0 , 1 ) ; }
public string to string ( ) { return to string ( `` `` ) ; }
public void extract message body ( output stream out ) throw i o exception { m a p i rtf attribute body = ( m a p i rtf attribute ) message . get message m a p i attribute ( m a p i property . rtf_compressed ) ; if ( body ! = null ) { out . write ( body . get data ( ) ) ; } }
public string get display to ( ) throw chunk not find exception { return get string from chunk ( main chunk . get display to chunk ( ) ) ; }
public string get html body ( ) throw chunk not find exception { if ( main chunk . get html body chunk binary ( ) ! = null ) { return main chunk . get html body chunk binary ( ) . get as7bit string ( ) ; } return get string from chunk ( main chunk . get html body chunk string ( ) ) ; }
public void set text ( string text ) { if ( text == null ) { get header footer ( ) . unset even footer ( ) ; if ( ! get header footer ( ) . be set even header ( ) ) { get header footer ( ) . unset different odd even ( ) ; } } else { get header footer ( ) . set even footer ( text ) ; } }
public void write ( file new file ) throw i o exception { try ( p o i f s file system fs = p o i f s file system . create ( new file ) ) { write ( f ) ; f . write filesystem ( ) ; } }
public list < e > a list ( ) { return unmodifiable list . unmodifiable list ( set order ) ; }
public void set style ( style style ) { this . style = style ; }
public void set first col ( int col ) { field_2_first_col = col ; }
public void set embed ( string value ) { this . embed = value ; }
public text edit perform ( ) { text edit result= do copy ( f edit ) ; if ( result ! = null ) { for ( text edit edit : f copy . key set ( ) ) { edit . post process copy ( this ) ; } } return result ; }
public byte [ ] get byte ( ) { return byte ; }
public int get border top ( ) { return bord top line style . get value ( field_13_border_styles1 ) ; }
public void set lnn min ( int field_34_lnn min ) { this . field_34_lnn min = field_34_lnn min ; }
public int get lnn min ( ) { return field_34_lnn min ; }
public static short to short ( object value ) throw conversion exception { number n = to number ( value , short . class ) ; if ( n instanceof short ) { return ( short ) n ; } else { return new short ( n . short value ( ) ) ; } }
public void previous page ( ) { if ( ! be first page ( ) ) { this . page -- ; } }
public void set dza gutter ( int field_47_dza gutter ) { this . field_47_dza gutter = field_47_dza gutter ; }
public int get dza gutter ( ) { return field_47_dza gutter ; }
public void set first row ( int first row ) { _range . set first row ( first row ) ; }
public color load color ( property skin property , string color property name ) { color color = null ; string color value = skin property . get property ( color property name , null ) ; log . debug ( `` load skin color with property ' `` + color property name + `` ' , value : `` + color value ) ; if ( color value ! = null ) { color = color . decode ( color value ) ; } else { log . warn ( `` color be not available for property ' `` + color property name + `` ' `` ) ; } return color ; }
public x w p f paragraph create paragraph ( ) { x w p f paragraph paragraph = new x w p f paragraph ( header footer . add new p ( ) , this ) ; paragraph . add ( paragraph ) ; body element . add ( paragraph ) ; return paragraph ; }
public void add user info claim ( final string claim name ) { add user info claim ( claim name , claim requirement . voluntary ) ; }
protect void check interval ( long start , long end ) { if ( end < start ) { throw new illegal argument exception ( `` the end instant must be great or equal to the start `` ) ; } }
public int get endnote number format ( ) { return _props . get nfc edn ref ( ) ; }
public short get endnote restart qualifier ( ) { return _props . get rnc edn ( ) ; }
public com . google . protobuf . byte string get data ( ) { return data_ ; }
protect offset source get offset source ( string field ) { if ( offset source == null ) { return super . get offset source ( field ) ; } return offset source ; }
public static cod input stream new instance ( byte buffer buf ) { return new instance ( buf , false / * buffer be immutable * / ) ; }
public static cod input stream new instance ( final byte [ ] buf ) { return new instance ( buf , 0 , buf . length ) ; }
public long get n ( ) { return n ; }
public void write optional byte reference ( @ nullable byte reference byte ) throw i o exception { if ( bytes == null ) { write v int ( 0 ) ; return ; } write v int ( byte . length ( ) + 1 ) ; byte . write to ( this ) ; }
public void set tag ( tag tag ) { this . tag = tag ; }
public void set registry ( registry registry ) { this . registry = registry ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public long get value ( ) { return value_ ; }
public int get value ( ) { return value_ ; }
public message lite set value ( message lite value ) { message lite original value = this . value ; this . delay bytes = null ; this . memoized byte = null ; this . value = value ; return original value ; }
public static lazy field lite from value ( message lite value ) { lazy field lite lf = new lazy field lite ( ) ; lf . set value ( value ) ; return lf ; }
public int get value ( ) { return value_ ; }
public int get count ( ) { return this . item . size ( ) ; }
public list < b type > get builder list ( ) { if ( external builder list == null ) { external builder list = new builder external list < m type , b type , i type > ( this ) ; } return external builder list ; }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public list < jaxb field result > get field result ( ) { if ( field result == null ) { field result = new array list < jaxb field result > ( ) ; } return this . field result ; }
public int get nanos ( ) { return nanos_ ; }
public scope get scope ( ) { return scope ; } // get scope
public setting get setting ( ) { return this . setting ; }
public void set build ( build build ) { this . build = build ; } // -- void set build ( build )
public item id get item id ( ) { return this . item id ; }
public string get location ( ) { return location ; }
public < t extend simple build item > t consume ( class < t > type ) { assert . check not null param ( `` type `` , type ) ; if ( ! run ) { throw message . msg . build step not run ( ) ; } final item id id = new item id ( type ) ; if ( id . be multi ( ) ) { throw message . msg . can not multi ( id ) ; } if ( ! step info . get consumes ( ) . contains ( id ) ) { throw message . msg . undeclared item ( id ) ; } return type . cast ( execution . get single ( ) . get ( id ) ) ; }
protect string get key attribute ( element element ) throw core exception { string key = element . get attribute ( key ) ; if ( key == null ) { throw get invalid format debug exception ( ) ; } return key ; }
public void set exit code ( int exit code ) { this . exit code = exit code ; }
public static < t > result matcher json path ( string expression , matcher < t > matcher ) { return new json path result matcher ( expression ) . value ( matcher ) ; }
public static void main ( string . . . args ) { new profiler ( ) . run ( args ) ; }
public static string last segment ( uri location ) { string path = location . get path ( ) ; if ( path == null ) return new path ( location . get scheme specific part ( ) ) . last segment ( ) ; return new path ( path ) . last segment ( ) ; }
public resource get archive ( ) { return be reference ( ) ? ( ( archive resource ) get check ref ( ) ) . get archive ( ) : archive ; }
public t get ( ) { return t ; }
public static boolean simple match ( string [ ] pattern , string str ) { if ( pattern ! = null ) { for ( string pattern : pattern ) { if ( simple match ( pattern , str ) ) { return true ; } } } return false ; }
public strategy get strategy ( ) { return strategy ; }
public void set id ( string id ) { this . id = id ; }
public boolean be persistent ( ) { return persistent ; }
public final void configure region ( region region ) { check mutability ( ) ; if ( region == null ) throw new illegal argument exception ( `` no region provide `` ) ; this . set region ( region . get region ( region ) ) ; }
public void set column name ( string column name ) { this . column name = column name ; }
public void set test resource ( java . util . list < resource > test resource ) { this . test resource = test resource ; } // -- void set test resource ( java . util . list )
public path get path ( ) { return path ; }
public void set stacktrace ( final @ nullable sentry stack trace stacktrace ) { this . stacktrace = stacktrace ; }
public iterator get property ( ) { return new mono iterator ( `` expression `` ) ; }
public final flux < t > repeat ( long num repeat , boolean supplier predicate ) { if ( num repeat < 0l ) { throw new illegal argument exception ( `` num repeat > = 0 require `` ) ; } if ( num repeat == 0 ) { return this . flux ( ) ; } return flux . defer ( ( ) - > repeat ( flux . count boolean supplier ( predicate , num repeat ) ) ) ; }
public final flux < t > repeat ( boolean supplier predicate ) { return flux . on assembly ( new mono repeat predicate < > ( this , predicate ) ) ; }
public t get value ( ) { return subscriber . get ( ) == terminate ? value : null ; }
public boolean be close on close ( ) { return close on close ; }
public tcp server no s s l ( ) { if ( configuration ( ) . be secure ( ) ) { tcp server dup = duplicate ( ) ; dup . configuration ( ) . ssl provider = null ; return dup ; } return this ; }
public tcp client no s s l ( ) { if ( configuration ( ) . be secure ( ) ) { tcp client dup = duplicate ( ) ; dup . configuration ( ) . ssl provider = null ; return dup ; } return this ; }
public synchronize inet socket address get address ( ) { return my address ; }
public string get remote i p address ( ) { return remote i p address ; }
protect int get max payload length ( ) { return this . max payload length ; }
public string get compiler ( ) { facade . set magic value ( get project ( ) . get property ( `` build . rmic `` ) ) ; return facade . get implementation ( ) ; }
public inet address get address ( ) { return address ; }
public static http2 frame codec builder for client ( ) { return new http2 frame codec builder ( false ) ; }
public http request decoder spec decoder ( ) { return decoder ; }
public argument accept option spec < string > with require arg ( ) { argument accept option spec < string > new spec = new require argument option spec < > ( option ( ) , description ( ) ) ; parser . recognize ( new spec ) ; return new spec ; }
public synchronize boolean be connect ( ) { return connect ; }
public int get max header size ( ) { return max header size ; }
public http response decoder spec decoder ( ) { return decoder ; }
public request spec builder add path param ( string parameter name , object parameter value ) { spec . path param ( parameter name , parameter value ) ; return this ; }
public request spec builder add param ( string parameter name , object . . . parameter value ) { spec . param ( parameter name , parameter value ) ; return this ; }
public request spec builder set trust store ( key store trust store ) { spec . trust store ( trust store ) ; return this ; }
public store get store ( ) { return store ; }
public cookie get ( string cookie name ) { assert parameter . not null ( cookie name , `` cookie name `` ) ; return cooky . get ( cookie name ) ; }
protect void append path ( string buffer path , string element ) { if ( string util . be blank ( element ) ) return ; if ( path . length ( ) > 0 ) path . append ( `` . `` ) ; path . append ( element ) ; }
public response spec builder append root path ( string path to append ) { spec . append root path ( path to append ) ; return this ; }
public long get connection max idle millis ( ) { return connection max idle millis ; }
protect charset get charset ( @ nullable medium type content type ) { if ( content type ! = null & & content type . get charset ( ) ! = null ) { return content type . get charset ( ) ; } else { return standard charsets . utf_8 ; } }
public static synchronize void set default ( default default ) { default = default ; }
public json path config number return type ( number return type number return type ) { return new json path config ( number return type , default parser type , gson object mapper factory , jackson1 object mapper factory , jackson2 object mapper factory , johnzon object mapper factory , jsonb object mapper factory , default deserializer , charset ) ; }
public strategy get strategy ( ) { return strategy ; }
public int get max redirects ( ) { return _max redirect ; }
public void init ( filter config config ) throw servlet exception { this . config = config ; this . init ( ) ; }
public synchronize boolean be s s l ( ) { return use s s l ; }
public string get property value ( string property name ) { return get property ( ) . get ( property name ) ; }
public void set validating ( boolean validating ) { this . validate = validating ; }
public static cookie get cookie ( http servlet request request , string name ) { assert . not null ( request , `` request must not be null `` ) ; cookie [ ] cooky = request . get cooky ( ) ; if ( cooky ! = null ) { for ( cookie cookie : cooky ) { if ( name . equal ( cookie . get name ( ) ) ) { return cookie ; } } } return null ; }
public string get header name ( ) { return this . header name ; }
public string get namespace u r i ( ) { return name pool . get u r i from u r i code ( uri code ) ; }
public status get status ( ) { return null ; }
public void set context ( object data ) { this . data = data ; }
public string to string ( ) { string builder sb = new string builder ( 256 ) ; sb . append ( `` ( `` ) ; sb . append ( get subject ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get predicate ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get object ( ) ) ; sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
protect void set base u r i ( parse u r i base u r i ) { this . base u r i = base u r i ; }
public detail cookie matcher path ( matcher < ? super string > path matcher ) { return new detailed cookie matcher ( and ( matcher . have property ( `` path `` , path matcher ) ) ) ; }
public path get path ( ) { return path ; }
public detail cookie matcher domain ( matcher < ? super string > domain matcher ) { return new detailed cookie matcher ( and ( matcher . have property ( `` domain `` , domain matcher ) ) ) ; }
public path get classpath ( ) { return classpath ; }
public uri get uri ( ) { return this . uri ; }
public url get url ( ) { return url ; }
protect boolean be valid scheme ( string scheme ) { if ( scheme == null ) { return false ; } if ( ! scheme_pattern . matcher ( scheme ) . match ( ) ) { return false ; } if ( be off ( allow_all_schemes ) ) { if ( ! this . allow scheme . contains ( scheme ) ) { return false ; } } return true ; }
public document parser ( parser parser ) { this . parser = parser ; return this ; }
public s s l context builder set trust manager factory algorithm ( final string trust manager factory algorithm ) { this . trust manager factory algorithm = trust manager factory algorithm ; return this ; }
public http client option set default port ( int default port ) { this . default port = default port ; return this ; }
public synchronize url get u r l ( ) { if ( be reference ( ) ) { return ( ( u r l resource ) get check ref ( ) ) . get u r l ( ) ; } return url ; }
public string get host ( ) { return host ; }
public string get provider ( ) { return provider ; }
public void set resource ( resource resource ) { this . resource = resource ; }
public void add per request resource ( class clazz ) { add resource factory ( new p o j o resource factory ( resource builder , clazz ) ) ; }
public static boolean be long literal ( string str ) { if ( str == null || str . be empty ( ) ) return false ; char [ ] char = str . to char array ( ) ; for ( int i = 0 ; i < char . length ; i++ ) { char c = char [ i ] ; if ( ( c < ' 0 ' & & ( i ! = 0 || c ! = '- ' ) ) || c > ' 9 ' ) return false ; } return true ; }
public credential get credential ( ) { return credential ; }
public final void set matrix ( matrix matrix ) { c o s array matrix array = null ; if ( matrix ! = null ) { matrix array = matrix . to c o s array ( ) ; } dictionary . set item ( c o s name . matrix , matrix array ) ; }
public void set low case term ( boolean low case term ) { this . low case term = low case term ; }
public static string capitalize ( string str ) { int str len ; if ( str == null || ( str len = str . length ( ) ) == 0 ) { return str ; } return new string buffer ( str len ) . append ( character . to title case ( str . char at ( 0 ) ) ) . append ( str . substring ( 1 ) ) . to string ( ) ; }
public completion stage < long > get ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __get ( handler ) ; } ) ; }
public static type [ ] get type argument ( final type type ) { if ( ! ( type instanceof parameterized type ) ) { return null ; } return ( ( parameterized type ) type ) . get actual type argument ( ) ; }
public static parameterized type find parameterized type ( class < ? > class to search , class < ? > parameterized interface ) { class current = class to search ; while ( current ! = object . class ) { for ( type current interface : current . get generic interface ( ) ) { if ( current interface instanceof parameterized type & & parameterized interface . be assignable from ( reflection utils . get raw type ( ( ( parameterized type ) current interface ) . get raw type ( ) ) ) ) { return ( parameterized type ) current interface ; } } current = current . get superclass ( ) ; } throw new jsonb exception ( message . get message ( message key . non_parametrized_type , parameterized interface ) ) ; }
public api response get response ( ) { return response ; }
public void add loop ( array comprehension loop acl ) { assert not null ( acl ) ; loop . add ( acl ) ; acl . set parent ( this ) ; }
public void set loop ( list < array comprehension loop > loop ) { assert not null ( loop ) ; this . loop . clear ( ) ; for ( array comprehension loop acl : loop ) { add loop ( acl ) ; } }
public ast node get body ( ) { return body ; }
public boolean be destructuring ( ) { return ! ( target instanceof name ) ; }
public list < condition > get condition ( ) { return condition ; }
public ast node get expression ( ) { return expression ; }
public void visit ( node visitor v ) { if ( v . visit ( this ) ) { target . visit ( v ) ; element . visit ( v ) ; } }
public void set label ( string label ) { this . label = label ; }
public void visit ( node visitor v ) { if ( v . visit ( this ) ) { test expression . visit ( v ) ; true expression . visit ( v ) ; false expression . visit ( v ) ; } }
public void set message ( string message ) { this . message = message ; }
public int get position ( ) { return this . position ; }
public void set rp ( int rp ) { this . rp = rp ; }
public void visit ( node visitor v ) { if ( v . visit ( this ) ) { target . visit ( v ) ; element . visit ( v ) ; } }
public list < condition > get condition ( ) { return condition ; }
public void remove variable ( string name ) { if ( null == variable ) { return ; } variable . remove ( name ) ; }
public void set body ( ast node body ) { throw new unsupported operation exception ( `` this node type have no body `` ) ; }
public boolean have identifier ( ) { return identifier ! =null ; }
public string get value ( ) { return value ; }
public void set token type ( string token type ) { this . token type = token type ; }
public void set expression ( ast node expression ) { assert not null ( expression ) ; this . expression = expression ; expression . set parent ( this ) ; }
public void set value ( object value ) { this . value = value ; }
public void visit ( node visitor v ) { if ( v . visit ( this ) ) { test expression . visit ( v ) ; true expression . visit ( v ) ; false expression . visit ( v ) ; } }
public expression get case order ( ) { return case order ; }
public void set type declaration ( type declaration decl ) { internal set type declaration ( decl ) ; }
public node get node ( ) { return node ; }
public void set index ( int index ) { this . index = index ; }
public void set be postfix ( boolean be postfix ) { this . be postfix = be postfix ; }
public boolean be postfix ( ) { return be postfix ; }
public void set be destructuring ( boolean destructuring ) { be destructuring = destructuring ; }
public void visit ( node visitor v ) { if ( v . visit ( this ) ) { target . visit ( v ) ; element . visit ( v ) ; } }
public ast node get expression ( ) { return expression ; }
public int get rp ( ) { return rp ; }
public ast node get expression ( ) { return expression ; }
public void set expression ( ast node expression ) { assert not null ( expression ) ; this . expression = expression ; expression . set parent ( this ) ; }
public char sequence get leave ( ) { return leave ; }
public void clear ( ) { synchronize ( cache ) { cache . clear ( ) ; } }
public static function get function ( string library name , string function name , int call flag ) { return native library . get instance ( library name ) . get function ( function name , call flag , null ) ; }
public boolean contains key ( final object key ) { check key ( key ) ; return lookup key ( key ) ! = null ; }
public static object a type ( object object , class type ) throw throwable { if ( object == null ) object = null object . get null object ( ) ; return invoke method n ( object . get class ( ) , object , `` a type `` , new object [ ] { type } ) ; }
synchronize public final slot register slot ( int slot idx , extend block id block id ) throw invalid request exception { if ( slot idx < 0 ) { throw new invalid request exception ( this + `` : invalid negative slot `` + `` index `` + slot idx ) ; } if ( slot idx > = slot . length ) { throw new invalid request exception ( this + `` : invalid slot `` + `` index `` + slot idx ) ; } if ( allocated slot . get ( slot idx ) ) { throw new invalid request exception ( this + `` : slot `` + slot idx + `` be already in use . `` ) ; } slot slot = new slot ( calculate slot address ( slot idx ) , block id ) ; if ( ! slot . be valid ( ) ) { throw new invalid request exception ( this + `` : slot `` + slot idx + `` be not mark a valid . `` ) ; } slot [ slot idx ] = slot ; allocate slot . set ( slot idx , true ) ; if ( log . be trace enable ( ) ) { log . trace ( this + `` : register slot `` + slot idx + `` : allocate slots= `` + allocated slot + string utils . get stack trace ( thread . current thread ( ) ) ) ; } return slot ; }
public void reinit ( token prototype ) { copy buffer ( prototype . buffer ( ) , 0 , prototype . length ( ) ) ; position increment = prototype . position increment ; flag = prototype . flag ; start offset = prototype . start offset ; end offset = prototype . end offset ; type = prototype . type ; payload = prototype . payload ; }
public scriptable get prototype ( ) { return prototype object ; }
public static boolean be array ( object obj ) { return ( obj ! = null & & obj . get class ( ) . be array ( ) ) ; }
public string get table name ( ) { return table name ; }
public void set flag ( byte flag ) { this . flag = flag ; }
public void detach ( ) { if ( listener ! = null ) { context factory . remove listener ( listener ) ; context factory = null ; listener = null ; } }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public void object dispose ( object obj ) { }
public void set context ( object data ) { this . data = data ; }
public void set global object id ( string value ) { this . global object id = value ; }
public string quit ( option opt ) throw exception { process opts ( opts ) ; return quit ( ) ; }
public synchronize void close ( ) throw i o exception { in . close ( ) ; }
public final string get template ( ) { return template ; }
public int y for line containing ( int offs ) throw bad location exception { rectangle r = model to view ( text area , offs ) ; return r ! =null ? r . y : -1 ; }
public collapse type collapse type ( ) { return collapse type . none ; }
public int get mark occurrence delay ( ) { return mark occurrence delay ; }
public boolean equal ( object obj ) { if ( obj instanceof event ) { return to string ( ) . equal ( obj . to string ( ) ) ; } else { return false ; } }
public int get line ( ) { return line ; }
public void set text area ( r text area text area ) { remove all tracking icon ( ) ; super . set text area ( text area ) ; }
public tag tag ( ) { return tag ; }
public void set background ( color color ) { if ( color == null ) return ; _background = color ; }
public x s s f hyperlink create hyperlink ( hyperlink type type ) { return new x s s f hyperlink ( type ) ; }
public void mark ( int mark limit ) { }
public void set background ( color color ) { if ( color == null ) return ; _background = color ; }
protect void set visible attribute ( set < string > visible attribute ) { if ( visible attribute ! = null ) { f visible attribute = new hash set < > ( visible attribute ) ; } }
public final string get template ( ) { return template ; }
public static timer task run after ( timer timer , int delay , final closure closure ) { timer task timer task = new timer task ( ) { public void run ( ) { closure . call ( ) ; } } ; timer . schedule ( timer task , delay ) ; return timer task ; }
public boolean get highlight current line ( ) { return highlight current line ; }
public static void close archive ( ) { synchronize ( fg zip file cache ) { for ( zip file file : fg zip file cache . value ( ) ) { synchronize ( file ) { try { file . close ( ) ; } catch ( i o exception e ) { debug plugin . log ( e ) ; } } } fg zip file cache . clear ( ) ; } }
public void set action ( string action ) { this . action = action ; }
public int y for line containing ( int offs ) throw bad location exception { rectangle r = model to view ( text area , offs ) ; return r ! =null ? r . y : -1 ; }
public static verification after delay after ( int millis ) { return new after ( millis , verification mode factory . time ( 1 ) ) ; }
public line string get line ( ) { return line ; }
public void set be dirty ( boolean value ) { this . be dirty = value ; }
public boolean add token ( token < ? extend token identifier > token ) { return ( token ! = null ) ? add token ( token . get service ( ) , token ) : false ; }
public boolean be exists ( ) { return be reference ( ) ? ( ( resource ) get check ref ( ) ) . be exists ( ) : get not null file ( ) . exists ( ) ; }
public int get max size ( ) { return this . max size ; }
public color get fold background ( ) { return fold indicator . get fold icon background ( ) ; }
public color get fold icon background ( ) { return fold icon background ; }
public int get line number ( ) { return get parent ( ) . get line number ( ) ; }
public color get fold background ( ) { return fold indicator . get fold icon background ( ) ; }
public void set background ( color color ) { if ( color == null ) return ; _background = color ; }
public synd image get icon ( ) { return icon ; }
public line string get line ( ) { return line ; }
protect r text area u i create r text area u i ( ) { return new r syntax text area u i ( this ) ; }
protect int validate range ( int start index , int end index ) { if ( start index < 0 ) { throw new string index out of bound exception ( start index ) ; } if ( end index > size ) { end index = size ; } if ( start index > end index ) { throw new string index out of bound exception ( `` end < start `` ) ; } return end index ; }
public int get position ( ) { return position ; }
public void set highlight secondary language ( boolean highlight ) { if ( this . highlight secondary language ! =highlight ) { highlight secondary language = highlight ; repaint ( ) ; fire property change ( highlight_secondary_languages_property , ! highlight , highlight ) ; } }
public boolean get highlight current line ( ) { return highlight current line ; }
public int y for line containing ( int offs ) throw bad location exception { rectangle alloc = get visible editor rect ( ) ; if ( alloc ! =null ) { r s t a view view = ( r s t a view ) get root view ( text area ) . get view ( 0 ) ; return view . y for line containing ( alloc , offs ) ; } return -1 ; }
public void add text ( string text ) { this . text = text ; }
public form login configurer < h > failure forward url ( string forward url ) { failure handler ( new forward authentication failure handler ( forward url ) ) ; return this ; }
public boolean equal ( object other ) { return ( this == other || ( other instanceof bean component definition & & super . equal ( other ) ) ) ; }
public void set b range ( p d range range ) { set component range array ( range , 2 ) ; }
public void clear ( ) { clear ( size ) ; }
protect int fill field ( byte [ ] data , escher record factory f ) { return fill field ( data , 0 , f ) ; }
public static object disposable ( disposable d ) { return new disposable notification ( d ) ; }
public subscription get ( ) { return state . current ( ) ; }
public void cancel ( iterable < s s table reader > cancel ) { for ( s s table reader cancel : cancel ) cancel ( cancel ) ; }
public static throwable get root cause ( throwable throwable ) { list list = get throwable list ( throwable ) ; return ( list . size ( ) < 2 ? null : ( throwable ) list . get ( list . size ( ) - 1 ) ) ; }
public boolean replace ( @ nullable disposable next ) { return disposable helper . replace ( resource , next ) ; }
public void basic qos ( int prefetch size , int prefetch count , boolean global , handler < async result < void > > result handler ) { delegate . basic qos ( prefetch size , prefetch count , global , result handler ) ; }
public boolean have value ( ) { object v = last value ; object o = state . get late ( ) ; return ! notification lite . be error ( o ) & & notification lite . be next ( v ) ; }
public void complete ( io . vertx . reactivex . ext . shell . cli . completion completion ) { delegate . complete ( completion . get delegate ( ) ) ; }
public final boolean await ( long time , time unit unit ) throw interrupted exception { boolean d = do . get count ( ) == 0 || ( do . await ( time , unit ) ) ; timeout = ! d ; return d ; }
public double get ( time unit unit ) { return get ( 0 , unit ) ; }
public collection < v > value ( ) { return this . map . value ( ) ; }
public void execute assert ( i assert < ? > assert command ) { assert command . do assert ( ) ; }
public static boolean be empty ( object [ ] array ) { return array == null || array . length == 0 ; }
public static cache control max age ( long max age , time unit unit ) { return max age ( duration . of second ( unit . to second ( max age ) ) ) ; }
public resolution report resolve ( collection < module > trigger , boolean trigger mandatory ) { return resolve ( trigger , trigger mandatory , false ) ; }
public void set subject ( string subject ) { this . subject = subject ; }
public list < observer > get observer ( ) { return observer ; }
public list < observer > get observer ( ) { return observer ; }
public final t get value ( ) { return value ; }
public static int next high power of two ( int v ) { v -- ; v |= v > > 1 ; v |= v > > 2 ; v |= v > > 4 ; v |= v > > 8 ; v |= v > > 16 ; v++ ; return v ; }
public final boolean be direct ( ) { return be direct ; }
public void terminate and drain ( throwable error ) { if ( ! terminate ) { exception = error ; terminate = true ; drain ( ) ; } }
public boolean be x h t m l ( ) { return do x h t m l ; }
public void remove element ( final int from , final int to ) { it . unimi . dsi . fastutil . array . ensure from to ( size , from , to ) ; system . arraycopy ( a , to , a , from , size - to ) ; size -= ( to - from ) ; }
public string get message ( ) { return message ; }
public void add ( json element element ) { if ( element == null ) { element = json null . instance ; } element . add ( element ) ; }
public static string get thread id ( ) { return get thread id ( thread . current thread ( ) ) ; }
public string get type ( ) { return type ; }
public final void set value ( string value ) { set value ( new string [ ] { value } ) ; }
public void set module ( final list < module > module ) { this . module = module ; }
public void set stacktrace ( boolean stacktrace ) { this . stacktrace = stacktrace ; }
public void set id ( final string id ) { this . id = id ; }
public void set name ( string name ) { this . name = name ; }
public void set transaction factory ( transaction factory transaction factory ) { this . transaction factory = transaction factory ; }
public boolean be attachment ( object value ) { return attachment utils . be attachment ( value ) ; }
public serializer < c > get serializer ( ) { return this . column serializer ; }
public send message result send message ( send message request request ) { request = before client execution ( request ) ; return execute send message ( request ) ; }
public int get cache dir size ( ) { return max cache item ; }
public void set cache size ( int cache size ) { this . cache size = cache size ; }
public void set proxy ( web proxy proxy ) { this . proxy = proxy ; }
public boolean be attach server name ( ) { return attach server name ; }
public boolean be attach thread ( ) { return attach thread ; }
public @ nullable boolean get enable uncaught exception handler ( ) { return enable uncaught exception handler ; }
public boolean be enable uncaught exception handler ( ) { return boolean . true . equal ( enable uncaught exception handler ) ; }
public int get max queue size ( ) { return max queue size ; }
public void to external ( coordinate internal , coordinate external ) { external . x = internal . x ; external . y = internal . y ; }
public void set tag ( tag tag ) { this . tag = tag ; }
public boolean remove shutdown hook ( runnable shutdown hook ) { if ( shutdown in progress . get ( ) ) { throw new illegal state exception ( `` shutdown in progress , can not remove a shutdown hook `` ) ; } return hook . remove ( new hook entry ( shutdown hook , 0 ) ) ; }
public void set session ( session session ) { this . session = session ; }
public int count ( ) { return count ; }
public void increment ( ) { value++ ; }
public static string capitalize ( string str ) { int str len ; if ( str == null || ( str len = str . length ( ) ) == 0 ) { return str ; } return new string buffer ( str len ) . append ( character . to title case ( str . char at ( 0 ) ) ) . append ( str . substring ( 1 ) ) . to string ( ) ; }
public void set name ( string name ) { this . name = name . to lower case ( locale . u ) ; }
public int get size ( ) { return size ; }
public boolean contains name ( final string name ) { for ( final t i : this ) { if ( i . get name ( ) . equal ( name ) ) { return true ; } } return false ; }
public void add other tesseract config ( string key , string value ) { if ( key == null ) { throw new illegal argument exception ( `` key must not be null `` ) ; } if ( value == null ) { throw new illegal argument exception ( `` value must not be null `` ) ; } matcher m = allowable_other_params_pattern . matcher ( key ) ; if ( ! m . find ( ) ) { throw new illegal argument exception ( `` key contain illegal character : `` +key ) ; } m . reset ( value ) ; if ( ! m . find ( ) ) { throw new illegal argument exception ( `` value contain illegal character : `` +value ) ; } other tesseract config . put ( key . trim ( ) , value . trim ( ) ) ; }
public void info ( string format , object arg a , object arg b ) { if ( logger . be loggable ( level . info ) ) { format tuple ft = message formatter . format ( format , arg a , arg b ) ; log ( self , level . info , ft . get message ( ) , ft . get throwable ( ) ) ; } }
public void reset ( ) { reset ( true , true ) ; }
public static log message format ( string format , object arg1 , object arg2 ) { return new format message2 ( format , arg1 , arg2 ) ; }
public io . vertx . reactivex . core . http . http client response body handler ( handler < io . vertx . reactivex . core . buffer . buffer > body handler ) { delegate . body handler ( new handler < io . vertx . core . buffer . buffer > ( ) { public void handle ( io . vertx . core . buffer . buffer event ) { body handler . handle ( io . vertx . reactivex . core . buffer . buffer . new instance ( ( io . vertx . core . buffer . buffer ) event ) ) ; } } ) ; return this ; }
public json object to json ( ) { json object json = super . to json ( ) ; http client option converter . to json ( this , json ) ; return json ; }
public json object to json object ( ) { json object ret = delegate . to json object ( ) ; return ret ; }
public static int parse unsigned short ( string lexical x s d unsigned short ) { if ( the converter == null ) init converter ( ) ; return the converter . parse unsigned short ( lexical x s d unsigned short ) ; }
public int po ( ) { return po ; }
public static io . vertx . axle . core . buffer . buffer buffer ( string string , string enc ) { io . vertx . axle . core . buffer . buffer ret = io . vertx . axle . core . buffer . buffer . new instance ( io . vertx . core . buffer . buffer . buffer ( string , enc ) ) ; return ret ; }
public byte [ ] get byte ( ) { return byte ; }
public output < string > summary ( ) { return summary ; }
public void remove ( int index ) { entry . remove ( index ) ; }
public t get ( ) { return t ; }
public string get public i d ( ) { return public i d ; }
public boolean to boolean ( ) { boolean ret = delegate . to boolean ( ) ; return ret ; }
public double get priority ( ) { return 0 . 5 ; }
public completion stage < long > get ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __get ( handler ) ; } ) ; }
public static io . vertx . axle . core . vertx vertx ( ) { io . vertx . axle . core . vertx ret = io . vertx . axle . core . vertx . new instance ( io . vertx . core . vertx . vertx ( ) ) ; return ret ; }
public void set creation date ( calendar creation ) { get c o s object ( ) . set embedded date ( `` params `` , `` creation date `` , creation ) ; }
public completion stage < long > get ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __get ( handler ) ; } ) ; }
public completion stage < long > get ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __get ( handler ) ; } ) ; }
public completion stage < long > get ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __get ( handler ) ; } ) ; }
public boolean be complete ( ) { return complete ; }
public integer get cookie max age ( ) { return this . cookie max age ; }
public void set http only ( boolean http only ) { this . http only = http only ; }
public void set site ( site site ) { this . site = site ; } // -- void set site ( site )
public io . vertx . axle . core . http . http client request delete ( string host , string request u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . delete ( host , request u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request option ( string request u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . option ( request u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request post ( string request u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . post ( request u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request delete ( string host , string request u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . delete ( host , request u r i ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request get ( string host , string request u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . get ( host , request u r i ) ) ; return ret ; }
public completion stage < void > write file ( string path , io . vertx . axle . core . buffer . buffer data ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __write file ( path , data , handler ) ; } ) ; }
public int get window size ( ) { return window size ; }
public json object to json ( ) { json object json = super . to json ( ) ; http client option converter . to json ( this , json ) ; return json ; }
public completion stage < long > get ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __get ( handler ) ; } ) ; }
public static io . vertx . axle . core . net . self sign certificate create ( string fqdn ) { io . vertx . axle . core . net . self sign certificate ret = io . vertx . axle . core . net . self sign certificate . new instance ( io . vertx . core . net . self sign certificate . create ( fqdn ) ) ; return ret ; }
public static io . vertx . axle . core . net . self sign certificate create ( ) { io . vertx . axle . core . net . self sign certificate ret = io . vertx . axle . core . net . self sign certificate . new instance ( io . vertx . core . net . self sign certificate . create ( ) ) ; return ret ; }
public instant get close instant ( ) { return close instant ; }
public static io . vertx . axle . core . vertx vertx ( ) { io . vertx . axle . core . vertx ret = io . vertx . axle . core . vertx . new instance ( io . vertx . core . vertx . vertx ( ) ) ; return ret ; }
public completion stage < void > close ( ) { return io . vertx . axle . async result completion stage . to completion stage ( handler - > { __close ( handler ) ; } ) ; }
public static io . vertx . axle . core . vertx vertx ( ) { io . vertx . axle . core . vertx ret = io . vertx . axle . core . vertx . new instance ( io . vertx . core . vertx . vertx ( ) ) ; return ret ; }
public io . vertx . axle . core . multi map header ( ) { io . vertx . axle . core . multi map ret = io . vertx . axle . core . multi map . new instance ( delegate . header ( ) ) ; return ret ; }
public static io . vertx . axle . core . net . self sign certificate create ( ) { io . vertx . axle . core . net . self sign certificate ret = io . vertx . axle . core . net . self sign certificate . new instance ( io . vertx . core . net . self sign certificate . create ( ) ) ; return ret ; }
public io . vertx . axle . core . http . http client request option ( string request u r i ) { io . vertx . axle . core . http . http client request ret = io . vertx . axle . core . http . http client request . new instance ( delegate . option ( request u r i ) ) ; return ret ; }
public datagram socket create datagram socket ( ) throw socket exception { return new datagram socket ( ) ; }
public void free reference ( pointer reference ) { remove ( reference ) ; }
public static < t > consumer < t > consumer ( unchecked consumer < t > consumer ) { return consumer . to consumer ( ) ; }
public list get stop class ( ) { return stop class ; }
public void stop ( promise < void > stop promise ) throw exception { uni < void > uni = async stop ( ) ; if ( uni ! = null ) { uni . subscribe ( ) . with ( x - > stop promise . complete ( ) , stop promise : : fail ) ; } else { super . stop ( stop promise ) ; } }
public void set definition ( string . . . definition ) { this . definition = definition ; }
public string get canonical service name ( ) { return dfs . get canonical service name ( ) ; }
public object [ ] get argument ( ) { return argument ; }
public boolean equal ( object obj ) { return super . equal ( obj ) ; }
public void add object ( rev object object ) throw incorrect object type exception { if ( ! exclude ( object ) ) add object ( object , 0 ) ; }
public string get event ( ) { return event ; }
public void set ( property property , int value ) { if ( property . get primary property ( ) . get property type ( ) ! = property . property type . simple ) { throw new property type exception ( property . property type . simple , property . get primary property ( ) . get property type ( ) ) ; } if ( property . get primary property ( ) . get value type ( ) ! = property . value type . integer ) { throw new property type exception ( property . value type . integer , property . get primary property ( ) . get value type ( ) ) ; } set ( property , integer . to string ( value ) ) ; }
public t load ( string yaml ) { return ( t ) loader . load ( new string reader ( yaml ) ) ; }
public node get node ( ) { return node ; }
public void set tag ( tag tag ) { this . tag = tag ; }
public string get indent ( ) { return indent ; }
public boolean be empty ( ) { return name . be empty ( ) ; }
public void clean up ( ) { }
public version get version ( ) { return version ; }
public void set project ( project project ) { this . project = project ; }
public request option add header ( string key , string value ) { check header ( ) ; object . require non null ( key , `` no null key accept `` ) ; object . require non null ( value , `` no null value accept `` ) ; header . add ( key , value ) ; return this ; }
protect void set check ( final boolean check ) { this . check = check ; }
public void set output directory ( string output directory ) { this . output directory = output directory ; } // -- void set output directory ( string )
public path get classpath ( ) { return classpath ; }
public void set container ( object container ) { this . container = container ; }
public annotation get annotation ( string type ) { annotation [ ] annotation = get annotation ( ) ; for ( int i = 0 ; i < annotation . length ; i++ ) { if ( annotation [ i ] . get type name ( ) . equal ( type ) ) return annotation [ i ] ; } return null ; }
public int get type ( ) { return block ; }
public void set variable ( variable declaration variable ) { assert not null ( variable ) ; this . variable = variable ; variable . set parent ( this ) ; }
public void set modifier ( int modifier ) { this . modifier = modifier ; }
public string get comment ( ) { return comment ; }
public source root add ( compilation unit compilation unit ) { assert not null ( compilation unit ) ; if ( compilation unit . get storage ( ) . be present ( ) ) { final path path = compilation unit . get storage ( ) . get ( ) . get path ( ) ; log . trace ( `` add new file % s `` , ( ) - > path ) ; final parse result < compilation unit > parse result = new parse result < > ( compilation unit , new array list < > ( ) , null ) ; cache . put ( path , parse result ) ; } else { throw new assertion error ( `` file add with this method should have their path set . `` ) ; } return this ; }
public void scan ct reference ( ct reference reference ) { }
public < t extend enum < t > > void set enum ( string name , t value ) { set ( name , value . to string ( ) ) ; }
public static boolean eval to boolean ( string expression , variable resolver factory var ) { return eval ( expression , var , boolean . class ) ; }
public void set double array ( int tag type , @ not null double [ ] double ) { set object array ( tag type , double ) ; }
public static short to short ( object value ) throw conversion exception { number n = to number ( value , short . class ) ; if ( n instanceof short ) { return ( short ) n ; } else { return new short ( n . short value ( ) ) ; } }
protect void set internal date ( final string date ) { this . date = date ; }
public type get type ( ) { return type ; }
public static char [ ] [ ] [ ] intern qualify name ( char [ ] [ ] [ ] qualify name ) { return intern qualify name ( qualified name , false ) ; }
public void scan ct reference ( ct reference reference ) { }
public static string repeat ( char ch , int count ) { string builder buffer = new string builder ( ) ; for ( int i = 0 ; i < count ; ++i ) buffer . append ( ch ) ; return buffer . to string ( ) ; }
public void set token stream ( token stream input ) { this . input = null ; reset ( ) ; this . input = input ; }
protect void enter ( ct element e ) { }
public void free reference ( pointer reference ) { remove ( reference ) ; }
public void scan ct name element ( ct name element e ) { }
public void set scan interval ( int scan interval ) { if ( be run ( ) ) throw new illegal state exception ( `` scanner start `` ) ; _scan interval = scan interval ; }
public void set st offset ( int st ) { this . st offset = st ; }
public void set separator ( string separator ) { this . separator = separator ; }
public static string get element content ( final element element ) throw exception { return get element content ( element , null ) ; }
public list get resource filter factory ( ) { return get filter list ( property_resource_filter_factories ) ; }
public string get compiler ( ) { string compiler impl = get compiler version ( ) ; if ( fork ) { if ( be jdk compiler ( compiler impl ) ) { compiler impl = `` ext javac `` ; } else { log ( `` since compiler setting be n't classic or modern , `` + `` ignoring fork setting . `` , project . msg_warn ) ; } } return compiler impl ; }
public access get access ( ) { return this . access ; }
public final t get value ( ) { return value ; }
public static string signature ( method method ) { return signature ( method . get name ( ) , method . get parameter type ( ) ) ; }
public static boolean be valid name for component ( string component ) { if ( component . equal ( `` . `` ) || component . equal ( `` . . `` ) || component . index of ( `` : `` ) > = 0 || component . index of ( `` / `` ) > = 0 ) { return false ; } return ! be reserve path component ( component ) ; }
public method parameter get method parameter ( ) { return this . parameter ; }
public field set set field ( field field ) { return set field ( new field description . for loaded field ( field ) ) ; }
public void scan ct reference ( ct reference reference ) { }
public static < t > t check not null ( t reference ) { if ( reference == null ) { throw new null pointer exception ( ) ; } return reference ; }
public static string class package a resource path ( class < ? > clazz ) { if ( clazz == null ) { return `` `` ; } string class name = clazz . get name ( ) ; int package end index = class name . last index of ( package_separator ) ; if ( package end index == -1 ) { return `` `` ; } string package name = class name . substring ( 0 , package end index ) ; return package name . replace ( package_separator , path_separator ) ; }
public boolean be pattern ( ) { return pattern name ! = null ; }
protect object get proxy ( aop proxy aop proxy ) { return aop proxy . get proxy ( this . proxy class loader ) ; }
protect int get order ( ) { return this . order ; }
public pattern get pattern ( ) { return pattern ; }
protected list < advisor > find candidate advisor ( ) { return this . advisor retrieval helper . find advisor bean ( ) ; }
public object get proxy ( ) { return proxy ; }
protected list < advisor > find candidate advisor ( ) { return this . advisor retrieval helper . find advisor bean ( ) ; }
public static boolean equal advisor ( advised support a , advised support b ) { return array . equal ( a . get advisor ( ) , b . get advisor ( ) ) ; }
public void set interceptor ( object [ ] interceptor ) { this . interceptor = interceptor ; }
public bean builder < t > bean class ( class < ? > bean class ) { this . bean class = bean class ; return this ; }
protect boolean be bean definition lazy init ( listable bean factory bean factory , string bean name ) { return ( bean factory instanceof configurable listable bean factory & & bean factory . contains bean definition ( bean name ) & & ( ( configurable listable bean factory ) bean factory ) . get bean definition ( bean name ) . be lazy init ( ) ) ; }
public string get prefix ( ) { return prefix ; }
public boolean have property override for ( string bean name ) { return this . bean name . contains ( bean name ) ; }
public void set default proxy target class ( boolean default proxy target class ) { this . default proxy target class = default proxy target class ; }
public boolean equal ( object other ) { return ( this == other || ( other instanceof bean component definition & & super . equal ( other ) ) ) ; }
public void add change listener ( final property change listener listener ) { change support . add property change listener ( listener ) ; }
public < t > t get proxy ( ) { return ( t ) create aop proxy ( ) . get proxy ( ) ; }
public string get target interface name ( ) { class < ? > ifc = this . rmi exporter . get service interface ( ) ; return ( ifc ! = null ? ifc . get name ( ) : null ) ; }
protected remote invocation create remote invocation ( method invocation method invocation ) { return get remote invocation factory ( ) . create remote invocation ( method invocation ) ; }
public pattern get pattern ( ) { return pattern ; }
public string get autowire candidate ( ) { return this . autowire candidate ; }
public method get method ( ) { return method ; }
public void set filter ( tree filter filter ) { this . filter = filter ; }
protect boolean [ ] implement interface ( i type bind member type , string [ ] interface name ) { boolean [ ] result= new boolean [ interface name . length ] ; for ( int i= 0 ; i < interface name . length ; i++ ) { if ( member type . get qualified name ( ) . equal ( interface names [ i ] ) ) result [ i ] = true ; } for ( i type bind intf : member type . get interface ( ) ) { boolean [ ] deeper= implement interface ( intf . get erasure ( ) , interface name ) ; for ( int j= 0 ; j < interface name . length ; j++ ) { result [ j ] = result [ j ] || deeper [ j ] ; } } return result ; }
public string get target name ( ) { return f target name ; }
public void set target list class ( class < ? extend list > target list class ) { if ( target list class == null ) { throw new illegal argument exception ( `` 'target list class ' must not be null `` ) ; } if ( ! list . class . be assignable from ( target list class ) ) { throw new illegal argument exception ( `` 'target list class ' must implement [ java . util . list ] `` ) ; } this . target list class = target list class ; }
public static bean factory get default bean factory ( ) { return default bean factory ; }
public void set lazy ( final boolean lazy ) { this . lazy = lazy ; }
public long get size max ( ) { return size max ; }
public int get min idle ( ) { final int max idle save = get max idle ( ) ; if ( this . min idle > max idle save ) { return max idle save ; } return min idle ; }
public date time with millis ( long new millis ) { return ( new millis == get millis ( ) ? this : new date time ( new millis , get chronology ( ) ) ) ; }
public void set action ( string action ) { this . action = action ; }
public get request refresh ( boolean refresh ) { this . refresh = refresh ; return this ; }
public scriptable get prototype ( ) { return prototype object ; }
public void set map handler ( set < ? > map handler ) { this . map handler = map handler ; }
public string get target bean name ( ) { return this . target bean name ; }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public static list < method > get declare method include inherit ( class < ? > clazz ) { list < method > method = new array list < method > ( ) ; while ( clazz ! = null ) { for ( method method : clazz . get declare method ( ) ) { method . add ( method ) ; } clazz = clazz . get superclass ( ) ; } return method ; }
public static class < ? extend annotation > find scope annotation ( errors error , annotation [ ] annotation ) { class < ? extend annotation > find = null ; for ( annotation annotation : annotation ) { class < ? extend annotation > annotation type = annotation . annotation type ( ) ; if ( be scope annotation ( annotation type ) ) { if ( found ! = null ) { error . duplicate scope annotation ( find , annotation type ) ; } else { find = annotation type ; } } } return find ; }
public void set factory ( string name ) { factory name = name ; }
public string get index name ( ) { return index name ; }
protect < t > t get bean ( string bean name , class < t > expect type ) { return bean factory annotation utils . qualified bean of type ( this . application context , expect type , bean name ) ; }
public value holder get generic argument value ( class < ? > require type , string require name , set < value holder > use value holder ) { for ( value holder value holder : this . generic argument value ) { if ( use value holder ! = null & & use value holder . contains ( value holder ) ) { continue ; } if ( value holder . get name ( ) ! = null & & ( require name == null || ! value holder . get name ( ) . equal ( require name ) ) ) { continue ; } if ( value holder . get type ( ) ! = null & & ( require type == null || ! class utils . match type name ( require type , value holder . get type ( ) ) ) ) { continue ; } if ( require type ! = null & & value holder . get type ( ) == null & & value holder . get name ( ) == null & & ! class utils . be assignable value ( require type , value holder . get value ( ) ) ) { continue ; } return value holder ; } return null ; }
public value holder get indexed argument value ( int index , class < ? > require type ) { return get indexed argument value ( index , require type , null ) ; }
public static class < ? > resolve return type argument ( method method , class < ? > generic ifc ) { assert . not null ( method , `` method must not be null `` ) ; resolvable type resolvable type = resolvable type . for method return type ( method ) . a ( generic ifc ) ; if ( ! resolvable type . have generic ( ) || resolvable type . get type ( ) instanceof wildcard type ) { return null ; } return get single generic ( resolvable type ) ; }
public void set target class ( class < ? > target class ) { this . target class = target class ; }
public static boolean should proxy target class ( configurable listable bean factory bean factory , string bean name ) { if ( bean name ! = null & & bean factory . contains bean definition ( bean name ) ) { bean definition bd = bean factory . get bean definition ( bean name ) ; return boolean . true . equal ( bd . get attribute ( preserve_target_class_attribute ) ) ; } return false ; }
public string get target bean name ( ) { return this . target bean name ; }
public string get name ( int value ) { return constant . get name ( value ) ; }
public type get target type ( ) { return this . target type ; }
public i content type matcher get matcher ( ) { return matcher ; }
public void set method ( string method ) { this . method = method ; }
public void set property ( string property ) { this . property = property ; }
public string get description ( ) { return ( description == null ) ? to string ( ) : description ; }
public final boolean content equal ( byte iterator other ) { assert . check not null param ( `` other `` , other ) ; for ( ; ; ) { if ( have next ( ) ) { if ( ! other . have next ( ) ) { return false ; } if ( next ( ) ! = other . next ( ) ) { return false ; } } else { return ! other . have next ( ) ; } } }
public object get bean ( ) { return bean ; }
public bean definition default get bean definition default ( ) { bean definition default bdd = new bean definition default ( ) ; bdd . set lazy init ( `` true `` . equal ignore case ( this . default . get lazy init ( ) ) ) ; bdd . set dependency check ( this . get dependency check ( default_value ) ) ; bdd . set autowire mode ( this . get autowire mode ( default_value ) ) ; bdd . set init method name ( this . default . get init method ( ) ) ; bdd . set destroy method name ( this . default . get destroy method ( ) ) ; return bdd ; }
public static class get class ( class loader class loader , string class name ) throw class not find exception { return get class ( class loader , class name , true ) ; }
public list < jaxb constructor result > get constructor result ( ) { if ( constructor result == null ) { constructor result = new array list < jaxb constructor result > ( ) ; } return this . constructor result ; }
public void set init method ( string init method ) { this . init method = init method ; }
public boolean be synthetic ( ) { return synthetic ; }
public list < resource > get resource ( ) { return resource ; }
public static boolean should proxy target class ( configurable listable bean factory bean factory , string bean name ) { if ( bean name ! = null & & bean factory . contains bean definition ( bean name ) ) { bean definition bd = bean factory . get bean definition ( bean name ) ; return boolean . true . equal ( bd . get attribute ( preserve_target_class_attribute ) ) ; } return false ; }
public boolean be return value require ( ) { return this . return value require ; }
public string generate bean name ( bean definition bean definition ) { return this . reader . get bean name generator ( ) . generate bean name ( bean definition , get registry ( ) ) ; }
public boolean get dependency check ( ) { return this . dependency check ; }
public string generate bean name ( bean definition bean definition ) { return this . reader . get bean name generator ( ) . generate bean name ( bean definition , get registry ( ) ) ; }
public int hash code ( ) { return to string ( ) . hash code ( ) ; }
protect bean factory locator get bean factory locator ( object target ) { return context singleton bean factory locator . get instance ( ) ; }
public final class get element type ( ) { return this . element type ; }
public boolean be enable ( ) { return this . enable ; }
public boolean equal ( object other ) { return ( this == other || ( other instanceof bean component definition & & super . equal ( other ) ) ) ; }
public int register bean definition ( resource bundle rb ) throw bean definition store exception { return register bean definition ( rb , null ) ; }
public int load bean definition ( resource resource , string prefix ) throw bean definition store exception { return load bean definition ( new encode resource ( resource ) , prefix ) ; }
public bean definition builder set dependency check ( int dependency check ) { bean definition . set dependency check ( dependency check ) ; return this ; }
public string generate bean name ( bean definition bean definition ) { return this . reader . get bean name generator ( ) . generate bean name ( bean definition , get registry ( ) ) ; }
public void apply default ( bean definition default default ) { set lazy init ( default . be lazy init ( ) ) ; set autowire mode ( default . get autowire mode ( ) ) ; set dependency check ( default . get dependency check ( ) ) ; set init method name ( default . get init method name ( ) ) ; set enforce init method ( false ) ; set destroy method name ( default . get destroy method name ( ) ) ; set enforce destroy method ( false ) ; }
public static class < ? > get target class ( object candidate ) { assert . not null ( candidate , `` candidate object must not be null `` ) ; class < ? > result = null ; if ( candidate instanceof target class aware ) { result = ( ( target class aware ) candidate ) . get target class ( ) ; } if ( result == null ) { result = ( be cglib proxy ( candidate ) ? candidate . get class ( ) . get superclass ( ) : candidate . get class ( ) ) ; } return result ; }
public void set enforce init method ( boolean enforce init method ) { this . enforce init method = enforce init method ; }
public void set property ( string property ) { this . property = property ; }
public string get property value ( string property name ) { return get property ( ) . get ( property name ) ; }
protect void add conversion ( conversion conversion , field map mapping ) { if ( conversion == null ) { return ; } if ( mapping . be map to index ( ) ) { this . convert index ( conversion ) . add ( map . get index ( ) ) ; } else { this . convert field ( conversion ) . add ( map . get field name ( ) ) ; } }
public property editor find editor ( string field , class < ? > value type ) { property editor registry editor registry = get property editor registry ( ) ; if ( editor registry ! = null ) { class < ? > value type to use = value type ; if ( value type to use == null ) { value type to use = get field type ( field ) ; } return editor registry . find custom editor ( value type to use , fix field ( field ) ) ; } else { return null ; } }
public void resize ( long new size ) { final int num page = num page ( new size ) ; if ( num page > page . length ) { page = array . copy of ( page , array util . oversize ( num page , ram usage estimator . num_bytes_object_ref ) ) ; } for ( int i = num page - 1 ; i > = 0 & & page [ i ] == null ; -- i ) { page [ i ] = new byte page ( i ) ; } for ( int i = num page ; i < page . length & & page [ i ] ! = null ; ++i ) { page [ i ] = null ; release page ( i ) ; } this . size = new size ; }
public void previous page ( ) { if ( ! be first page ( ) ) { this . page -- ; } }
public void set sort ( string value ) { this . sort = value ; }
public string [ ] get require ( ) { return require ; }
public < t extend annotation > t get parameter annotation ( class < t > annotation type ) { annotation [ ] anns = get parameter annotation ( ) ; for ( annotation ann : anns ) { if ( annotation type . be instance ( ann ) ) { return ( t ) ann ; } } return null ; }
public method parameter get method parameter ( ) { return this . parameter ; }
public tag command set annotate ( boolean annotate ) { this . annotate = annotate ; return this ; }
public void set validation mode ( int mode ) { validation = mode ; }
public static boolean should proxy target class ( configurable listable bean factory bean factory , string bean name ) { if ( bean name ! = null & & bean factory . contains bean definition ( bean name ) ) { bean definition bd = bean factory . get bean definition ( bean name ) ; return boolean . true . equal ( bd . get attribute ( preserve_target_class_attribute ) ) ; } return false ; }
protect object convert array ( object value ) { return value ; }
public set < injection point > get injection point ( ) throw configuration exception { return injection point . for instance method and field ( type ) ; }
public void set lazy ( final boolean lazy ) { this . lazy = lazy ; }
public void set merge enable ( boolean merge enable ) { this . merge enable = merge enable ; }
public string get name ( ) { return property name ; }
public list annotation ( ) { return this . annotation ; }
public period parse ( string value ) { return parse ( value , null ) ; }
public duration parse ( string value ) { return parse ( value , null ) ; }
public boolean force ( ) { return force ; }
public int get max two phase commit thread ( ) { return max two phase commit thread ; }
public type environment get environment ( ) { return f environment ; }
public integer get clean up cycle ( ) { return clean up cycle ; }
public string get location ( ) { return location ; }
public file get dir ( string sub dir ) { file dir = new file ( get dir ( ) , sub dir ) ; dir . mkdirs ( ) ; return dir ; }
public file get dir ( ) { return this . dir ; }
public string get ssl proxy ( ) { return ssl proxy ; }
public void set filter ( tree filter filter ) { this . filter = filter ; }
public list < string > get mime type ( ) { return mime type ; }
public static annotation retention of ( boolean enable ) { return enable ? enable : disable ; }
public void set key store ( key store configuration key store ) { if ( key store ! = null ) { this . key store = key store ; } }
public void set key store ( key store configuration key store ) { if ( key store ! = null ) { this . key store = key store ; } }
public string get path to servlet ( ) { string path = this . url path helper . get originate context path ( this . request ) ; if ( string utils . have text ( this . url path helper . get path within servlet mapping ( this . request ) ) ) { path += this . url path helper . get originate servlet path ( this . request ) ; } return path ; }
protect void set connection ( @ nullable connection connection ) { if ( this . current connection ! = null ) { if ( this . connection handle ! = null ) { this . connection handle . release connection ( this . current connection ) ; } this . current connection = null ; } if ( connection ! = null ) { this . connection handle = new simple connection handle ( connection ) ; } else { this . connection handle = null ; } }
public void set embed ( string value ) { this . embed = value ; }
public boolean get search forward ( ) { return forward ; }
public void set driver name ( string driver name ) { this . driver name = driver name ; }
public void set username ( string username ) { this . username = username ; }
public string get char set ( ) { return this . char set ; }
public class < ? > get value class ( ) { return object . class ; }
public list < condition > get condition ( ) { return condition ; }
public synchronize void set parent ( part parent ) { this . parent = parent ; }
public list < condition > get condition ( ) { return condition ; }
public string name ( ) { return this . name ; }
public string get password ( ) { return this . password ; } // -- string get password ( )
protect set < configurable application context > find application context ( ) { synchronize ( application context ) { return new link hash set < configurable application context > ( application context ) ; } }
protect int get order ( ) { return this . order ; }
public void trigger reload ( ) { synchronize ( this . monitor ) { synchronize ( this . connection ) { for ( connection connection : this . connection ) { try { connection . trigger reload ( ) ; } catch ( exception ex ) { logger . debug ( `` unable to send reload message `` , ex ) ; } } } } }
public void listen ( ) throw i o exception { listen ( thread . current thread ( ) ) ; }
public void set connection ( string connection ) { this . connection = connection ; } // -- void set connection ( string )
public deployment option set instance ( int instance ) { this . instance = instance ; return this ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public string get group id ( ) { return this . group id ; } // -- string get group id ( )
public void set unpack w a r ( boolean unpack w a r ) { this . unpack w a r = unpack w a r ; }
public string get value ( ) { return main value ; }
public boolean have property override for ( string bean name ) { return this . bean name . contains ( bean name ) ; }
public object parse ( byte [ ] in ) throw parse exception { return get p byte ( ) . parse ( in ) ; }
protect t read object ( input stream input stream , resolvable type type ) throw i o exception { buffered reader reader = new buffer reader ( new input stream reader ( input stream ) ) ; return read object ( reader , type ) ; }
public input stream get input stream ( ) throw i o exception { return new reader input stream ( reader ) ; }
public json content assert be not equal to json ( byte [ ] expect , j s o n compare mode compare mode ) { string expect json = this . loader . get json ( expect ) ; return assert not pass ( compare ( expect json , compare mode ) ) ; }
public json content assert be not equal to json ( file expect , j s o n compare mode compare mode ) { string expect json = this . loader . get json ( expect ) ; return assert not pass ( compare ( expect json , compare mode ) ) ; }
public json content assert be not equal to json ( byte [ ] expect , j s o n compare mode compare mode ) { string expect json = this . loader . get json ( expect ) ; return assert not pass ( compare ( expect json , compare mode ) ) ; }
public json value get value ( string path ) { return this . value . get ( this . path to property ( path ) ) ; }
public < t > response entity < t > exchange ( string url , http method method , http entity < ? > request entity , class < t > response type , object . . . url variable ) throw rest client exception { return this . rest template . exchange ( url , method , request entity , response type , url variable ) ; }
public < t > response entity < t > get for entity ( string url , class < t > response type , object . . . url variable ) throw rest client exception { return this . rest template . get for entity ( url , response type , url variable ) ; }
public < t > t post for object ( string url , object request , class < t > response type , object . . . url variable ) throw rest client exception { return this . rest template . post for object ( url , request , response type , url variable ) ; }
public < t > response entity < t > get for entity ( string url , class < t > response type , object . . . url variable ) throw rest client exception { return this . rest template . get for entity ( url , response type , url variable ) ; }
public void clear ( ) { clear ( size ) ; }
public void set target class ( class < ? > target class ) { this . target class = target class ; }
public static < t > t bean of type ( listable bean factory lbf , class < t > type ) throw bean exception { assert . not null ( lbf , `` listable bean factory must not be null `` ) ; map < string , t > bean of type = lbf . get bean of type ( type ) ; return unique bean ( type , bean of type ) ; }
public void add group ( string group ) { if ( be wild card a c l value ( group ) ) { throw new illegal argument exception ( `` group `` + group + `` can not be add `` ) ; } if ( ! be all allow ( ) ) { list < string > group list = new link list < string > ( ) ; group list . add ( group ) ; group map . cache group add ( group list ) ; group . add ( group ) ; } }
protect bean factory locator get bean factory locator ( object target ) { return context singleton bean factory locator . get instance ( ) ; }
public void set registry ( registry registry ) { this . registry = registry ; }
public environment get environment ( ) { return this . environment ; }
public scoped proxy mode get scoped proxy mode ( ) { return this . scoped proxy mode ; }
protect object get resource ( lookup element element , string request bean name ) throw bean exception { if ( string utils . have length ( element . map name ) ) { return this . jndi factory . get bean ( element . map name , element . lookup type ) ; } if ( this . always use jndi lookup ) { return this . jndi factory . get bean ( element . name , element . lookup type ) ; } if ( this . resource factory == null ) { throw new no such bean definition exception ( element . lookup type , `` no resource factory configure - specify the 'resource factory ' property `` ) ; } return autowire resource ( this . resource factory , element , request bean name ) ; }
protect object build lazy resource proxy ( final lookup element element , final string request bean name ) { target source t = new target source ( ) { @ override public class < ? > get target class ( ) { return element . lookup type ; } @ override public boolean be static ( ) { return false ; } @ override public object get target ( ) { return get resource ( element , request bean name ) ; } @ override public void release target ( object target ) { } } ; proxy factory pf = new proxy factory ( ) ; pf . set target source ( t ) ; if ( element . lookup type . be interface ( ) ) { pf . add interface ( element . lookup type ) ; } class loader class loader = ( this . bean factory instanceof configurable bean factory ? ( ( configurable bean factory ) this . bean factory ) . get bean class loader ( ) : null ) ; return pf . get proxy ( class loader ) ; }
public void set scoped proxy mode ( scoped proxy mode scoped proxy mode ) { this . scope metadata resolver = new annotation scope metadata resolver ( scoped proxy mode ) ; }
public long get timestamp ( ) { return timestamp ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public void set error handler ( error handler handler ) { }
public document parser ( parser parser ) { this . parser = parser ; return this ; }
public static void register web application scope ( configurable listable bean factory bean factory ) { register web application scope ( bean factory , null ) ; }
public string get display name ( ) { return display name ; }
public list < resource > get resource ( ) { return resource ; }
public void add attribute converter ( attribute converter attribute converter ) { add attribute converter ( attribute converter definition . from ( attribute converter ) ) ; }
public string get name ( ) { return to string ( ) ; }
public path get path ( ) { return path ; }
public template availability provider get provider ( string view , application context application context ) { assert . not null ( application context , `` application context must not be null `` ) ; return get provider ( view , application context . get environment ( ) , application context . get class loader ( ) , application context ) ; }
public static locale parse locale ( string locale string ) { locale locale = null ; if ( locale string == null ) { locale = locale . get default ( ) ; } else { try { string [ ] args = locale string . split ( `` _ `` ) ; if ( args . length == 1 ) { locale = new locale ( args [ 0 ] ) ; } else if ( args . length == 2 ) { locale = new locale ( args [ 0 ] , args [ 1 ] ) ; } else if ( args . length == 3 ) { locale = new locale ( args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; } } catch ( throwable t ) { locale = locale . get default ( ) ; } } return locale ; }
protect string render default message ( string default message , object [ ] args , locale locale ) { return format message ( default message , args , locale ) ; }
public string get escape name ( ) { char [ ] basename = get raw name ( ) ; return ( basename == null ) ? null : new string ( basename ) ; }
public string get encode ( ) { return this . encoding ; } // -- string get encoding ( )
protect message format create message format ( string msg , locale locale ) { return new message format ( ( msg ! = null ? msg : `` `` ) , locale ) ; }
public get request refresh ( boolean refresh ) { this . refresh = refresh ; return this ; }
public static bean factory locator get instance ( ) throw fatal bean exception { return context singleton bean factory locator . get instance ( ) ; }
public void set style ( style style ) { this . style = style ; }
public time zone get time zone ( ) { return printer . get time zone ( ) ; }
public date time field type get date time field type ( ) { return i date time field type ; }
public string get path ( ) { return this . path ; }
public void set target class ( class < ? > target class ) { this . target class = target class ; }
protected class < ? > get class for descriptor ( object manage bean ) { if ( aop utils . be jdk dynamic proxy ( manage bean ) ) { return aop proxy utils . proxied user interface ( manage bean ) [ 0 ] ; } return get class to expose ( manage bean ) ; }
protect model m bean notification info [ ] get notification info ( object manage bean , string bean key ) throw j m exception { return new model m bean notification info [ 0 ] ; }
protect model m bean constructor info [ ] get constructor info ( object manage bean , string bean key ) throw j m exception { return new model m bean constructor info [ 0 ] ; }
protect void check manage bean ( object manage bean ) throw illegal argument exception { if ( aop utils . be jdk dynamic proxy ( manage bean ) ) { throw new illegal argument exception ( `` metadata m bean info assembler do not support jdk dynamic proxy - `` + `` export the target bean directly or use cglib proxy instead `` ) ; } }
protected class < ? > get class for descriptor ( object manage bean ) { if ( aop utils . be jdk dynamic proxy ( manage bean ) ) { return aop proxy utils . proxied user interface ( manage bean ) [ 0 ] ; } return get class to expose ( manage bean ) ; }
public void set method ( string method ) { this . method = method ; }
public static boolean should proxy target class ( configurable listable bean factory bean factory , string bean name ) { if ( bean name ! = null & & bean factory . contains bean definition ( bean name ) ) { bean definition bd = bean factory . get bean definition ( bean name ) ; return boolean . true . equal ( bd . get attribute ( preserve_target_class_attribute ) ) ; } return false ; }
public void set description ( string description ) { this . description = description ; }
public void set limit ( long limit ) { this . limit = limit ; }
public void set index ( int index ) { this . index = index ; }
protect boolean match interface ( string interface name ) { return null ; }
public final string get template ( ) { return template ; }
public void set proxy ( web proxy proxy ) { this . proxy = proxy ; }
public void set name ( string name ) { if ( name == null ) throw new illegal argument exception ( ) ; this . name = name ; }
public void set resource ( resource resource ) { this . resource = resource ; }
public get request refresh ( boolean refresh ) { this . refresh = refresh ; return this ; }
protect void do write remote invocation ( remote invocation invocation , object output stream oos ) throw i o exception { oos . write object ( invocation ) ; }
public static void do with local method ( class < ? > clazz , method callback mc ) { method [ ] method = get declare method ( clazz ) ; for ( method method : method ) { try { mc . do with ( method ) ; } catch ( illegal access exception ex ) { throw new illegal state exception ( `` not allow to access method ' `` + method . get name ( ) + `` ' : `` + ex ) ; } } }
protect boolean be configuration callback interface ( class < ? > ifc ) { return ( initialize bean . class == ifc || disposable bean . class == ifc || object utils . contains element ( ifc . get interface ( ) , aware . class ) ) ; }
public final bean definition registry get registry ( ) { return this . registry ; }
public list < interceptor > get interceptor ( ) { return interceptor chain . get interceptor ( ) ; }
public void set proxy ( web proxy proxy ) { this . proxy = proxy ; }
public string get method name ( ) { return method name ; }
public static boolean check if parameter type be same ( boolean be var args , class < ? > [ ] expect parameter type , class < ? > [ ] actual parameter type ) { if ( expect parameter type == null || actual parameter type == null ) { throw new illegal argument exception ( `` parameter type can not be null `` ) ; } else if ( expect parameter type . length ! = actual parameter type . length ) { return false ; } else { for ( int i = 0 ; i < expect parameter type . length ; i++ ) { final class < ? > actual parameter type = get type ( actual parameter type [ i ] ) ; if ( be var args & & i == expect parameter type . length - 1 & & actual parameter type . get component type ( ) . be assignable from ( expect parameter type [ i ] ) ) { return true ; } else if ( ! actual parameter type . be assignable from ( expect parameter type [ i ] ) ) { return false ; } } } return true ; }
public void set argument ( object argument ) { this . argument = argument ; }
public throwable get exception ( ) { return exception ; }
public void set reconnection delay ( int delay ) { this . reconnection delay = delay ; }
public runnable get runnable ( ) { return this . runnable ; }
public boolean have task ( ) { return start time > 0 ; }
protect boolean keep result set ( ) { return false ; }
protect block queue < runnable > create queue ( int queue capacity ) { if ( queue capacity > 0 ) { return new link block queue < runnable > ( queue capacity ) ; } else { return new synchronous queue < runnable > ( ) ; } }
public void set queue capacity ( int queue capacity ) { this . queue capacity = queue capacity ; }
public static func0 < ? extends schedule executor service > get on generic schedule executor service ( ) { return on generic schedule executor service ; }
public void set proxy target class ( boolean proxy target class ) { this . proxy target class = proxy target class ; }
public string get script ( ) { return script ; }
public void override default editor ( class < ? > require type , property editor property editor ) { if ( this . overridden default editor == null ) { this . overridden default editor = new hash map < class < ? > , property editor > ( ) ; } this . overridden default editor . put ( require type , property editor ) ; }
public field set set field ( field field ) { return set field ( new field description . for loaded field ( field ) ) ; }
public string get path ( ) { return path ; }
public property editor find editor ( string field , class < ? > value type ) { property editor registry editor registry = get property editor registry ( ) ; if ( editor registry ! = null ) { class < ? > value type to use = value type ; if ( value type to use == null ) { value type to use = get field type ( field ) ; } return editor registry . find custom editor ( value type to use , fix field ( field ) ) ; } else { return null ; } }
public mapping get mapping ( ) { return mapping ; }
public b require ( property constraint < ? super t > constraint ) { validators . add ( constraint ) ; return ( b ) this ; }
public string get code ( ) { return this . code ; }
public bean builder < t > bean class ( class < ? > bean class ) { this . bean class = bean class ; return this ; }
public static class < ? > get target class ( object candidate ) { assert . not null ( candidate , `` candidate object must not be null `` ) ; class < ? > result = null ; if ( candidate instanceof target class aware ) { result = ( ( target class aware ) candidate ) . get target class ( ) ; } if ( result == null ) { result = ( be cglib proxy ( candidate ) ? candidate . get class ( ) . get superclass ( ) : candidate . get class ( ) ) ; } return result ; }
public void close ( ) { delegate . close ( ) ; }
public void set fallback ( parser fallback ) { this . fallback = fallback ; }
public void register bean ( class < ? > bean class ) { do register bean ( bean class , null , null , null , null ) ; }
public long get interval ( ) { return interval ; }
public runnable get runnable ( ) { return this . runnable ; }
public method get method ( ) { return method ; }
public string get method ( ) { return method ; }
public schedule executor service get schedule executor ( ) throw illegal state exception { assert . state ( this . schedule executor ! = null , `` thread pool task scheduler not initialize `` ) ; return this . schedule executor ; }
public boolean contains ( object value ) { return contain value ( value ) ; }
public static object get default value ( annotation annotation , string attribute name ) { if ( annotation == null ) { return null ; } return get default value ( annotation . annotation type ( ) , attribute name ) ; }
public annotation get annotation ( string type ) { annotation [ ] annotation = get annotation ( ) ; for ( int i = 0 ; i < annotation . length ; i++ ) { if ( annotation [ i ] . get type name ( ) . equal ( type ) ) return annotation [ i ] ; } return null ; }
public void set type ( class < ? > type ) { this . type = type ; }
public static type descriptor nest ( field field , int nest level ) { return nest ( new type descriptor ( field ) , nest level ) ; }
public static type descriptor nest ( method parameter method parameter , int nest level ) { if ( method parameter . get nesting level ( ) ! = 1 ) { throw new illegal argument exception ( `` method parameter nest level must be 1 : `` + `` use the nesting level parameter to specify the desired nesting level for nested type traversal `` ) ; } return nest ( new type descriptor ( method parameter ) , nest level ) ; }
public final string load profile name ( ) { final string profile env var override = get env profile name ( ) ; if ( ! string utils . be null or empty ( profile env var override ) ) { return profile env var override ; } else { final string profile sys prop override = get sys property profile name ( ) ; if ( ! string utils . be null or empty ( profile sys prop override ) ) { return profile sys prop override ; } else { return default_profile_name ; } } }
protect void print resolve exception ( @ nullable exception resolve exception ) throw exception { if ( resolve exception == null ) { this . printer . print value ( `` type `` , null ) ; } else { this . printer . print value ( `` type `` , resolve exception . get class ( ) . get name ( ) ) ; } }
public string get name ( ) { return ref . get string ( c o s name . name ) ; }
protect collection < field access > field of ( class < ? > c ) { collection < field access > field = field of a s t class . get ( c ) ; if ( field ! = null ) return field ; field = new array list < field access > ( ) ; get field ( c , field ) ; field of a s t class . put ( c , field ) ; return field ; }
public method parameter get method parameter ( ) { return this . parameter ; }
public static class < ? > resolve type argument ( class < ? > clazz , class < ? > generic ifc ) { resolvable type resolvable type = resolvable type . for class ( clazz ) . a ( generic ifc ) ; if ( ! resolvable type . have generic ( ) ) { return null ; } return get single generic ( resolvable type ) ; }
public static class < ? > resolve return type argument ( method method , class < ? > generic ifc ) { assert . not null ( method , `` method must not be null `` ) ; resolvable type resolvable type = resolvable type . for method return type ( method ) . a ( generic ifc ) ; if ( ! resolvable type . have generic ( ) || resolvable type . get type ( ) instanceof wildcard type ) { return null ; } return get single generic ( resolvable type ) ; }
public long last modified ( ) throw i o exception { if ( this . file ! = null ) { return super . last modified ( ) ; } else { try { return file . get last modified time ( this . file path ) . to millis ( ) ; } catch ( no such file exception ex ) { throw new file not find exception ( ex . get message ( ) ) ; } } }
public byte [ ] get byte ( ) { return byte ; }
public void set relative path ( string relative path ) { this . relative path = relative path ; } // -- void set relative path ( string )
public int hash code ( ) { return to string ( ) . hash code ( ) ; }
public void set location ( resource . . . location ) { this . location = location ; }
public void set location ( resource location ) { this . location = new resource [ ] { location } ; }
public resource name iterator find resource name ( string resource name ) { return find resource class ( resource name ) ; }
public void set encoding ( string encode encode ) { this . encode = encoding ; }
public property create property ( ) { final property prop = new property ( ) ; property list . add element ( prop ) ; return prop ; }
public class < ? > get declare class ( ) { return method . get declare class ( ) ; }
public static class < ? > get type argument ( type generic type ) { if ( ! ( generic type instanceof parameterized type ) ) return null ; parameterized type parameterized type = ( parameterized type ) generic type ; class < ? > type arg = ( class < ? > ) parameterized type . get actual type argument ( ) [ 0 ] ; return type arg ; }
public static annotation [ ] get filtering annotation ( final annotation [ ] annotation ) { if ( annotation == null || annotation . length == 0 ) { return filter helper . empty_annotations ; } final list < annotation > filtering annotation = new array list < > ( annotation . length ) ; for ( final annotation annotation : annotation ) { final class < ? extend annotation > annotation type = annotation . annotation type ( ) ; for ( final annotation meta annotation : annotation type . get declared annotation ( ) ) { if ( meta annotation instanceof entity filter ) { filter annotation . add ( annotation ) ; } } } return filter annotation . to array ( new annotation [ filter annotation . size ( ) ] ) ; }
public type get type ( ) { return type ; }
public string get alias ( ) { return alias ; }
public void set package ( string pkg ) { this . option . default package = pkg ; }
public to string builder append ( string field name , float value ) { style . append ( buffer , field name , value ) ; return this ; }
public @ not null thread get thread ( ) { return thread ; }
public int get concurrency ( ) { return concurrency ; }
public boolean be interface ( ) { return this . be interface ; }
public void set cache ( boolean cache ) { this . cache = cache ; }
public long get interval ( ) { return interval ; }
public long get interval ( ) { return this . interval ; }
public long get interval ( ) { return this . interval ; }
public void set class ( class clazz ) { this . clazz = clazz ; if ( clazz == null ) { return ; } this . class loader = ( class loader == null ) ? clazz . get class loader ( ) : class loader ; this . class name = ( class name == null ) ? clazz . get name ( ) : class name ; }
public static list < method > get declare method include inherit ( class < ? > clazz ) { list < method > method = new array list < method > ( ) ; while ( clazz ! = null ) { for ( method method : clazz . get declare method ( ) ) { method . add ( method ) ; } clazz = clazz . get superclass ( ) ; } return method ; }
public static class get wrapper type ( class primitive type ) { if ( primitive type . be primitive ( ) ) { return primitives_to_wrappers . get ( primitive type ) ; } return primitive type ; }
public static class get wrapper type ( class primitive type ) { if ( primitive type . be primitive ( ) ) { return primitives_to_wrappers . get ( primitive type ) ; } return primitive type ; }
public void import package ( string package name ) { import package . add ( package name ) ; }
public void set class name ( string class name ) { reader class name = class name ; }
public void set option comparator ( comparator comparator ) { if ( comparator == null ) { this . option comparator = new option comparator ( ) ; } else { this . option comparator = comparator ; } }
public static string hex encode ( byte [ ] bytes ) { string builder sb = new string builder ( ) ; for ( byte a byte : byte ) { string string = integer . to hex string ( a byte & 0xff ) ; if ( string . length ( ) == 1 ) { sb . append ( `` 0 `` ) ; } sb . append ( string . to upper case ( locale . u ) ) ; } return sb . to string ( ) ; }
public int byte size ( ) { return byte size ; }
public path resolve repo file ( string location ) { return path utils . get ( repo file , location ) ; }
public string [ ] get pattern ( ) { return pattern ; }
public static method get public method ( method method ) { class < ? > clazz = method . get declare class ( ) ; / * * short circuit for ( hopefully the majority of ) case where the declare * class be public . * / if ( ( clazz . get modifier ( ) & modifier . public ) ! = 0 ) { return method ; } return get public method ( clazz , method . get name ( ) , method . get parameter type ( ) ) ; }
public method get method ( ) { return method ; }
public void set location ( resource location ) { this . location = new resource [ ] { location } ; }
public string current task name ( ) { return this . current task name ; }
public task type get task type ( ) { return task id . get task type ( ) ; }
public int get task count ( ) { return this . task count ; }
public string get prefix ( ) { return prefix ; }
public object convert ( @ nullable object source , type descriptor target type ) { return convert ( source , type descriptor . for object ( source ) , target type ) ; }
public boolean can bypass convert ( @ nullable type descriptor source type , type descriptor target type ) { assert . not null ( target type , `` target type to convert to can not be null `` ) ; if ( source type == null ) { return true ; } generic converter converter = get converter ( source type , target type ) ; return ( converter == no_op_converter ) ; }
protect file get file for last modified check ( ) throw i o exception { return get file ( ) ; }
public int length ( ) { return path . size ( ) ; }
public reflect create ( ) throw reflect exception { return create ( new object [ 0 ] ) ; }
public final i log get log ( ) { return internal platform . get default ( ) . get log ( get bundle ( ) ) ; }
public void warn ( string format , object arg1 , object arg2 ) { format and log ( log_level_warn , format , arg1 , arg2 ) ; }
public boolean remove ( group member member ) { return this . internal remove ( member ) ; }
public reactive adapter registry get reactive adapter registry ( ) { return this . reactive adapter registry ; }
public reactive adapter get adapter ( class < ? > reactive type ) { return get adapter ( reactive type , null ) ; }
public string [ ] get path ( ) { return ( string [ ] ) this . path . to array ( new string [ this . path . size ( ) ] ) ; }
public string get protocol ( ) { return protocol ; }
public int get task count ( ) { return this . task count ; }
public string get short description ( ) { string builder sb = new string builder ( ) ; sb . append ( `` session= [ `` ) . append ( this . session id ) . append ( `` ] ; `` ) ; sb . append ( `` user= [ `` ) . append ( this . user name ) . append ( `` ] ; `` ) ; return sb . to string ( ) ; }
public short get index ( ) { return ( short ) index ; }
public static string extract file extension ( string path ) { int end = path . index of ( ' ? ' ) ; int fragment index = path . index of ( ' # ' ) ; if ( fragment index ! = -1 & & ( end == -1 || fragment index < end ) ) { end = fragment index ; } if ( end == -1 ) { end = path . length ( ) ; } int begin = path . last index of ( '/ ' , end ) + 1 ; int param index = path . index of ( ' ; ' , begin ) ; end = ( param index ! = -1 & & param index < end ? param index : end ) ; int ext index = path . last index of ( ' . ' , end ) ; if ( ext index ! = -1 & & ext index > begin ) { return path . substring ( ext index + 1 , end ) ; } return null ; }
public float float value ( ) { return value ; }
public string get expression ( ) { return expression ; }
public boolean contains number ( number number ) { if ( number == null ) { return false ; } return contains integer ( number . int value ( ) ) ; }
public static schedule executor service default executor ( ) { return default executor holder . i ; }
public void set scope ( string scope ) { this . scope = scope ; }
public class loader get class loader ( ) { return class loader ; }
public method get method ( ) { return method ; }
public method get method ( ) { return this . method ; }
public file get file ( ) { return file ; }
protect offset source get offset source ( string field ) { if ( offset source == null ) { return super . get offset source ( field ) ; } return offset source ; }
public container get container ( ) { return container ; }
public string get char set ( ) { return this . char set ; }
public long ticket key fail ( ) { lock reader lock = context . ctx lock . read lock ( ) ; reader lock . lock ( ) ; try { return s s l context . session ticket key fail ( context . ctx ) ; } finally { reader lock . unlock ( ) ; } }
public void set visitor ( boolean visitor ) { optional attrs . put ( visitor , visitor ? boolean . true : boolean . false ) ; }
public void write record ( byte [ ] buf , int offset ) throw i o exception { if ( this . debug ) { system . err . println ( `` write record : rec idx = `` + this . curr rec idx + `` blk idx = `` + this . curr blk idx ) ; } if ( this . out stream == null ) { throw new i o exception ( `` write to an input buffer `` ) ; } if ( ( offset + this . record size ) > buf . length ) { throw new i o exception ( `` record have length ' `` + buf . length + `` ' with offset ' `` + offset + `` ' which be less than the record size of ' `` + this . record size + `` ' `` ) ; } if ( this . curr rec idx > = this . recs per block ) { this . write block ( ) ; } system . arraycopy ( buf , offset , this . block buffer , ( this . curr rec idx * this . record size ) , this . record size ) ; this . curr rec idx++ ; }
public string get table ( ) { return table ; }
public list < string > get entry ( ) { return collection . unmodifiable list ( arrays . a list ( entry ) ) ; }
public void set content ( final content content ) { this . content = content ; }
public pattern get pattern ( ) { return pattern ; }
public void set user detail service ( user detail service user detail service ) { this . user detail service = user detail service ; }
public ldap authentication provider configurer < b > group search subtree ( boolean group search subtree ) { this . group search subtree = group search subtree ; return this ; }
public ldap authentication provider configurer < b > group search base ( string group search base ) { this . group search base = group search base ; return this ; }
public basic link add to basic link object extension ( final abstract object basic link object extension ) { this . get basic link object extension ( ) . add ( basic link object extension ) ; return this ; }
public void set http client ( http client http client ) { this . http client = http client ; }
public void set username ( string username ) { this . username = username ; }
public boolean get search forward ( ) { return forward ; }
public boolean be disable conversion ( ) { return disable conversion ; }
public string get realm ( ) { return get parameter ( `` realm `` ) ; }
public logout configurer < h > delete cooky ( string . . . cookie name to clear ) { return add logout handler ( new cookie clear logout handler ( cookie name to clear ) ) ; }
public cookie get ( string cookie name ) { assert parameter . not null ( cookie name , `` cookie name `` ) ; return cooky . get ( cookie name ) ; }
public remote repository get repository ( ) { return repository ; }
public void set user detail service ( user detail service user detail service ) { this . user detail service = user detail service ; }
public void set resource ( resource resource ) { this . resource = resource ; }
public void set header ( string header ) { this . header = header ; }
public i type get handle ( ) { return this . handle ; }
public boolean support ( class < ? > clazz ) { return ( method invocation . class . be assignable from ( clazz ) ) ; }
public void set class ( class clazz ) { this . clazz = clazz ; if ( clazz == null ) { return ; } this . class loader = ( class loader == null ) ? clazz . get class loader ( ) : class loader ; this . class name = ( class name == null ) ? clazz . get name ( ) : class name ; }
public void set password ( string password ) { this . password = password ; }
public authentication builder add custom ( authentication authentication ) { if ( authentication ! = null ) { authentication . add ( authentication ) ; } return this ; }
public list < grant authority > get grant authority ( collection < string > attribute ) { list < grant authority > result = new array list < > ( attribute . size ( ) ) ; for ( string attribute : attribute ) { result . add ( get grant authority ( attribute ) ) ; } return result ; }
public list < grant authority > get grant authority ( collection < string > attribute ) { array list < grant authority > result = new array list < > ( ) ; for ( string attribute : attribute ) { collection < grant authority > grant = this . attributes2granted authority map . get ( attribute ) ; if ( grant ! = null ) { result . add all ( grant ) ; } } result . trim to size ( ) ; return result ; }
public static int initialize ( ) { return initialize ( default_seed ) ; }
public void set user detail service ( user detail service user detail service ) { this . user detail service = user detail service ; }
public void append prefix ( string prefix ) { property ref r = new property ref ( ) ; r . set prefix ( prefix ) ; add propertyref ( r ) ; }
public static text encryptor text ( char sequence password , char sequence salt ) { return new hex encode text encryptor ( standard ( password , salt ) ) ; }
public static text encryptor delux ( char sequence password , char sequence salt ) { return new hex encode text encryptor ( strong ( password , salt ) ) ; }
public string encode ( char sequence raw password ) { string salt = prefix + this . salt generator . generate key ( ) + suffix ; return digest ( salt , raw password ) ; }
public string encode ( char sequence raw pas ) { byte [ ] salt = this . salt generator . generate key ( ) ; return encode ( raw pas , salt ) ; }
protect collection < field access > field of ( class < ? > c ) { collection < field access > field = field of a s t class . get ( c ) ; if ( field ! = null ) return field ; field = new array list < field access > ( ) ; get field ( c , field ) ; field of a s t class . put ( c , field ) ; return field ; }
public bearer access token get client notification token ( ) { return client notification token ; }
public < t > t attribute ( string attribute ) { return ( t ) servlet request . get attribute ( attribute ) ; }
public long code ( ) { return code ; }
public list < format error > get error ( ) { return error ; }
public strategy get strategy ( ) { return strategy ; }
public void set number of success ( int success ) { set number of success internal ( success ) ; }
public string get url ( ) { return this . url ; } // -- string get url ( )
public x509 configurer < h > user detail service ( user detail service user detail service ) { user detail by name service wrapper < pre authenticate authentication token > authentication user detail service = new user detail by name service wrapper < > ( ) ; authentication user detail service . set user detail service ( user detail service ) ; return authentication user detail service ( authentication user detail service ) ; }
public request spec builder add param ( string parameter name , object . . . parameter value ) { spec . param ( parameter name , parameter value ) ; return this ; }
public final void set parameter ( final parameter [ ] parameter ) { this . parameter = parameter ; set initialize ( false ) ; }
public http servlet map get http servlet mapping ( ) { return this . _get http servlet request ( ) . get http servlet mapping ( ) ; }
public string get session attribute name filter ( ) { if ( session attribute name pattern == null ) { return null ; } return session attribute name pattern . to string ( ) ; }
public x509 configurer < h > user detail service ( user detail service user detail service ) { user detail by name service wrapper < pre authenticate authentication token > authentication user detail service = new user detail by name service wrapper < > ( ) ; authentication user detail service . set user detail service ( user detail service ) ; return authentication user detail service ( authentication user detail service ) ; }
public void set http only ( boolean http only ) { this . http only = http only ; }
public final web application context get web application context ( ) { return this . web application context ; }
public void set context ( string context ) { if ( context . start with ( `` / `` ) ) { this . context = context ; } else { this . context = `` / `` + context ; } }
public void set http client ( http client http client ) { this . http client = http client ; }
public boolean be allow ( string method ) { check use ( ) ; return method allow . contains ( method ) ; }
public header get ( string header name ) { not null ( header name , `` header name `` ) ; return header . get ( header name ) ; }
public string get value ( ) { return value ; }
public void set max nonce age ( int age second ) { _nonce verifier . set max age ( age second ) ; }
public uri get uri ( ) { return this . uri ; }
public string get include ( ) { return include ; }
public void set mode ( string mode ) { this . mode = mode ; }
public void set password ( string password ) { this . password = password ; }
public i content type matcher get matcher ( ) { return matcher ; }
public value extractor < iterable > get iterable value extractor ( ) { return iterable value extractor ; }
public final byte [ ] get byte array ( ) { return this . byte array ; }
public http request with body ( string body ) { this . body = new string body ( body ) ; return this ; }
public void clear ( ) { clear ( size ) ; }
public input stream get content ( ) { return this . content ; }
public string get parameter ( string name ) { if ( name == null ) { throw new illegal argument exception ( `` parameter name may not be null `` ) ; } return null ; }
public list < parameter > get all parameter ( ) { return all parameter ; }
public void set preferred locale ( list < locale > locales ) { assert . not empty ( locale , `` locale list must not be empty `` ) ; this . locale . clear ( ) ; this . locale . add all ( locale ) ; update accept language header ( ) ; }
public void add preferred locale ( locale locale ) { assert . not null ( locale , `` locale must not be null `` ) ; this . locale . add first ( locale ) ; update accept language header ( ) ; }
public void put all ( map map ) { if ( map instanceof multi map ) { for ( iterator it = map . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; collection coll = ( collection ) entry . get value ( ) ; put all ( entry . get key ( ) , coll ) ; } } else { for ( iterator it = map . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; put ( entry . get key ( ) , entry . get value ( ) ) ; } } }
public static drop table step drop table if exists ( string table ) { return dsl ( ) . drop table if exists ( table ) ; }
public void set location ( resource location ) { this . location = new resource [ ] { location } ; }
public void end test ( test test ) { f model . add run test ( test ) ; fire test change ( test , false ) ; }
protect object create default strategy ( application context context , class < ? > clazz ) { return context . get autowire capable bean factory ( ) . create bean ( clazz ) ; }
public i transaction get transaction ( ) { return this . transaction ; }
static public void assert equal ( string message , object expect , object actual ) { if ( expect == null & & actual == null ) return ; if ( expect ! = null & & expect . equal ( actual ) ) return ; if ( expect instanceof string & & actual instanceof string ) throw new comparison failure ( message , ( string ) expect , ( string ) actual ) ; else fail not equal ( message , expect , actual ) ; }
protect boolean evaluate value ( object expect , object actual ) { return ( expect == actual ) || ( ( expect ! = null ) & & expect . equal ( actual ) ) ; }
public void set target class ( class < ? > target class ) { this . target class = target class ; }
public string to string ( ) { string builder sb = new string builder ( 256 ) ; sb . append ( `` ( `` ) ; sb . append ( get subject ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get predicate ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get object ( ) ) ; sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
public request < ? > get request ( ) { return request ; }
public request matcher boolean value ( boolean value ) { return ( xpath request matcher ) request - > this . xpath helper . assert boolean ( request . get body a byte ( ) , default_encoding , value ) ; }
public request matcher exists ( ) { return ( xpath request matcher ) request - > this . xpath helper . exists ( request . get body a byte ( ) , default_encoding ) ; }
public byte [ ] get response body content ( ) { return this . response body . block ( this . timeout ) ; }
public static boolean be transmittable ( int status code ) { return ( status code == normal ) || ( status code == shutdown ) || ( status code == protocol ) || ( status code == bad_data ) || ( status code == bad_payload ) || ( status code == policy_violation ) || ( status code == message_too_large ) || ( status code == required_extension ) || ( status code == server_error ) || ( status code == service_restart ) || ( status code == try_again_later ) || ( status code == invalid_upstream_response ) ; }
public byte [ ] get request body content ( ) { return this . request body . block ( this . timeout ) ; }
public list < medium type > get support medium type ( ) { return this . supported medium type ; }
public void add param ( string name , string value ) { params . put ( name , value ) ; }
public void set preferred locale ( list < locale > locales ) { assert . not empty ( locale , `` locale list must not be empty `` ) ; this . locale . clear ( ) ; this . locale . add all ( locale ) ; update accept language header ( ) ; }
public void parse ( final set cookie cookie , final string value ) throw malformed cookie exception { if ( cookie == null ) { throw new illegal argument exception ( `` cookie may not be null `` ) ; } if ( value == null ) { throw new malformed cookie exception ( `` miss value for version attribute `` ) ; } int version = -1 ; try { version = integer . parse int ( value ) ; } catch ( number format exception e ) { version = -1 ; } if ( version < 0 ) { throw new malformed cookie exception ( `` invalid cookie version . `` ) ; } cookie . set version ( version ) ; }
public string get method name ( ) { return method name ; }
public object get result ( ) { return result ; }
public url get url ( ) { return url ; }
public static < t > t arg that ( matcher < t > matcher ) { report matcher ( matcher ) ; return ( t ) default value ( generic type of matcher ( matcher . get class ( ) ) ) ; }
public type bind resolve at type ( block scope scope , type bind u ) { if ( this . resolve type == null ) { this . resolve type = this . local . binding . type ; } return this . resolve type ; }
protect void print resolve exception ( @ nullable exception resolve exception ) throw exception { if ( resolve exception == null ) { this . printer . print value ( `` type `` , null ) ; } else { this . printer . print value ( `` type `` , resolve exception . get class ( ) . get name ( ) ) ; } }
public string uri ( ) { return uri ; }
public static < t > consumer < t > consumer ( unchecked consumer < t > consumer ) { return consumer . to consumer ( ) ; }
public static < t > t mock ( class < t > class to mock ) { return mock ( class to mock , with setting ( ) . default answer ( returns_defaults ) ) ; }
public cache control cache control ( ) { cache control result = cache control ; return result ! = null ? result : ( cache control = cache control . parse ( header ) ) ; }
public cache control s max age ( long s max age , time unit unit ) { return s max age ( duration . of second ( unit . to second ( s max age ) ) ) ; }
public static cache control max age ( long max age , time unit unit ) { return max age ( duration . of second ( unit . to second ( max age ) ) ) ; }
public int get read timeout ( ) { return this . read timeout ; }
public medium type get content type ( ) { return this . content type ; }
public mime type get mime type ( ) { return mime type ; }
public charset charset ( ) { return charset ! = null ? charset . for name ( charset ) : null ; }
public long get doc value memory in byte ( ) { return this . doc value memory in byte ; }
public void set module ( final list < module > module ) { this . module = module ; }
public boolean have message body ( ) throw i o exception { http status status = http status . resolve ( get raw status code ( ) ) ; if ( status ! = null & & ( status . is1xx informational ( ) || status == http status . no_content || status == http status . not_modified ) ) { return false ; } if ( get header ( ) . get content length ( ) == 0 ) { return false ; } return true ; }
public mime type get mime type ( ) { return mime type ; }
public static header builder < ? > option ( uri url ) { return method ( http method . option , url ) ; }
public static header builder < ? > head ( uri url ) { return method ( http method . head , url ) ; }
public status get status ( ) { return null ; }
public boolean get be read ( ) { return this . be read ; }
public string get log prefix ( ) { return this . log prefix ; }
public void write ( byte [ ] b ) { }
public int get fail ( ) { return fail ; }
public static boolean be transmittable ( int status code ) { return ( status code == normal ) || ( status code == shutdown ) || ( status code == protocol ) || ( status code == bad_data ) || ( status code == bad_payload ) || ( status code == policy_violation ) || ( status code == message_too_large ) || ( status code == required_extension ) || ( status code == server_error ) || ( status code == service_restart ) || ( status code == try_again_later ) || ( status code == invalid_upstream_response ) ; }
public int get buffer size ( ) { return buffer size ; }
public void set servlet ( servlet servlet ) { instance = servlet ; }
public oof reply get internal reply ( ) { return internal reply ; }
public void set proxy ( web proxy proxy ) { this . proxy = proxy ; }
public medium type get content type ( ) { return this . content type ; }
protected remote invocation create remote invocation ( method invocation method invocation ) { return get remote invocation factory ( ) . create remote invocation ( method invocation ) ; }
public final boolean be enable ( stream write feature f ) { return ( _generator feature & f . map feature ( ) . get mask ( ) ) ! = 0 ; }
public string get address ( ) { return this . address ; } // -- string get address ( )
public void verify ( ) throw startup exception { for ( startup check test : pre flight check ) test . execute ( ) ; }
public string get current base ( ) { return base . to string ( ) ; }
public list < medium type > get support medium type ( ) { return this . supported medium type ; }
public void set header ( string header ) { this . header = header ; }
public list < medium type > get support medium type ( ) { return this . supported medium type ; }
public string get header name ( ) { return this . header name ; }
public boolean be direct field access ( ) { return this . direct field access ; }
public final void set direct field access ( boolean direct field access ) { this . direct field access = direct field access ; }
public void override default editor ( class < ? > require type , property editor property editor ) { if ( this . overridden default editor == null ) { this . overridden default editor = new hash map < class < ? > , property editor > ( ) ; } this . overridden default editor . put ( require type , property editor ) ; }
public void set option ( string name , object value ) { string prefix = get option prefix ( ) ; if ( prefix ! = null & & prefix . length ( ) > 0 & & ! name . start with ( prefix ) ) { name = prefix + `` . `` + name ; } _options . put ( name , value ) ; }
public static server web exchange matcher matcher ( server web exchange matcher . . . matcher ) { return new or server web exchange matcher ( matcher ) ; }
public status get status ( ) { return null ; }
public string get status ( ) { return this . status ; } // -- string get status ( )
public void set target type ( class < ? > target type ) { assert . not null ( target type , `` 'target type ' must not be null `` ) ; this . target type = target type ; }
public final web application context get web application context ( ) { return this . web application context ; }
protect void init servlet context ( servlet context servlet context ) { }
public string get callback name ( ) { return callback name ; }
public synchronize void execute ( string root , runnable task ) { thread pool executor executor = executor . get ( root ) ; if ( executor == null ) { throw new runtime exception ( `` can not find root `` + root + `` for execution of task `` + task ) ; } else { executor . execute ( task ) ; } }
public boolean be async support ( ) { return request . be async support ( ) ; }
protect callable statement creator new callable statement creator ( parameter mapper in param mapper ) { assert . state ( this . callable statement factory ! = null , `` no callable statement factory available `` ) ; return this . callable statement factory . new callable statement creator ( in param mapper ) ; }
public string get callback name ( ) { return callback name ; }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public namespace get namespace ( ) { return namespace ; }
public string to string ( ) { string builder sb = new string builder ( 256 ) ; sb . append ( `` ( `` ) ; sb . append ( get subject ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get predicate ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get object ( ) ) ; sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
public string get address ( ) { return this . address ; } // -- string get address ( )
protect boolean be bean definition lazy init ( listable bean factory bean factory , string bean name ) { return ( bean factory instanceof configurable listable bean factory & & bean factory . contains bean definition ( bean name ) & & ( ( configurable listable bean factory ) bean factory ) . get bean definition ( bean name ) . be lazy init ( ) ) ; }
protect boolean be bean definition lazy init ( listable bean factory bean factory , string bean name ) { return ( bean factory instanceof configurable listable bean factory & & bean factory . contains bean definition ( bean name ) & & ( ( configurable listable bean factory ) bean factory ) . get bean definition ( bean name ) . be lazy init ( ) ) ; }
public void set servlet ( servlet servlet ) { instance = servlet ; }
public boolean be allow credential ( ) { return allow credential ; }
public static boolean be valid origin ( http request request , collection < string > allow origin ) { assert . not null ( request , `` request must not be null `` ) ; assert . not null ( allow origin , `` allow origin must not be null `` ) ; string origin = request . get header ( ) . get origin ( ) ; if ( origin == null || allow origin . contains ( `` * `` ) ) { return true ; } else if ( collection utils . be empty ( allow origin ) ) { return be same origin ( request ) ; } else { return allow origin . contains ( origin ) ; } }
public string get include ( ) { return include ; }
public string get include ( ) { return include ; }
public int max payload size ( ) { return max payload size ; }
public void set dispatch trace request ( boolean dispatch trace request ) { this . dispatch trace request = dispatch trace request ; }
public io . vertx . reactivex . ext . web . client . http request < t > set query param ( string param name , string param value ) { delegate . set query param ( param name , param value ) ; return this ; }
public void set require parameter name ( string require parameter name ) { this . require parameter name = require parameter name ; }
public string get status ( ) { return this . status ; } // -- string get status ( )
public void set tree model ( int model ) { tree model = model ; }
public model map get default model ( ) { return this . default model ; }
public iterable < item > get item ( ) { return this . item ; }
protect multipart resolver lookup multipart resolver ( ) { web application context wac = web application context utils . get web application context ( get servlet context ( ) ) ; string bean name = get multipart resolver bean name ( ) ; if ( wac ! = null & & wac . contains bean ( bean name ) ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` use multipart resolver ' `` + bean name + `` ' for multipart filter `` ) ; } return wac . get bean ( bean name , multipart resolver . class ) ; } else { return this . default multipart resolver ; } }
protect multipart resolver lookup multipart resolver ( http servlet request request ) { return lookup multipart resolver ( ) ; }
public void set filter ( tree filter filter ) { this . filter = filter ; }
public static void warn ( final logger logger , final string pattern , final object [ ] argument ) { if ( logger . be enable for ( level . warn ) ) { force log ( logger , level . warn , format ( pattern , argument ) ) ; } }
public void set chunk type ( final medium type medium type ) throw illegal argument exception { if ( medium type == null ) { throw new illegal argument exception ( localization message . chunked_input_media_type_null ( ) ) ; } this . medium type = medium type ; }
protect final method parameter obtain method parameter ( ) { assert . state ( this . method parameter ! = null , `` neither field nor method parameter `` ) ; return this . method parameter ; }
public integer get cookie max age ( ) { return this . cookie max age ; }
public final string get header name ( ) { return this . header name ; }
protect medium type get content type ( http message input message ) { medium type content type = input message . get header ( ) . get content type ( ) ; return ( content type ! = null ? content type : medium type . application_octet_stream ) ; }
public void set content ( final content content ) { this . content = content ; }
public duration get cookie max age ( ) { return this . cookie max age ; }
public void set strict parsing ( boolean be strict ) { this . be strict parse = be strict ; }
public string get entity ( ) { return entity ; }
public boolean be pattern ( ) { return pattern name ! = null ; }
public string get encode ( ) { return encode ; }
public int get end index ( ) { return end index ; }
public string remove semicolon content ( string request uri ) { return ( this . remove semicolon content ? remove semicolon content internal ( request uri ) : remove jsessionid ( request uri ) ) ; }
public void set remove semicolon content ( boolean remove semicolon content ) { this . remove semicolon content = remove semicolon content ; }
public cookie get ( string cookie name ) { assert parameter . not null ( cookie name , `` cookie name `` ) ; return cooky . get ( cookie name ) ; }
public string check origin ( @ nullable string request origin ) { if ( ! string utils . have text ( request origin ) ) { return null ; } if ( object utils . be empty ( this . allow origin ) ) { return null ; } if ( this . allow origin . contains ( all ) ) { if ( this . allow credential ! = boolean . true ) { return all ; } else { return request origin ; } } for ( string allow origin : this . allow origin ) { if ( request origin . equal ignore case ( allow origin ) ) { return request origin ; } } return null ; }
public file get directory ( ) { return builder . directory ( ) ; }
public print writer get writer ( ) throw i o exception { return this . response . get writer ( ) ; }
public decoder config default charset for content type ( string charset , string content type ) { not null ( charset , `` charset `` ) ; not null ( content type , `` content type `` ) ; map < string , string > map = new hash map < string , string > ( content type to default charset ) ; map . put ( trim ( content type ) . to lower case ( ) , trim ( charset ) ) ; return new decoder config ( charset , use no wrap for inflate decoding , true , content decoder , map ) ; }
public static transformer clone transformer ( ) { return clone transformer . instance ; }
public view controller registration add view controller ( string url path ) { view controller registration registration = new view controller registration ( url path ) ; registration . set application context ( this . application context ) ; this . registration . add ( registration ) ; return registration ; }
public static http authentication feature basic ( string username , byte [ ] password ) { return build ( mode . basic_preemptive , username , password ) ; }
public method get method ( ) { return this . method ; }
public string get uri ( ) { return uri ; }
public void set header ( string header ) { this . header = header ; }
public synchronize boolean be case sensitive ( ) { return be case sensitive ; }
public type get type ( ) { return type ; }
public void set exception handler ( final thread . uncaught exception handler exception handler ) { assert . check not null param ( `` exception handler `` , exception handler ) ; this . exception handler = exception handler ; }
public void set content ( final content content ) { this . content = content ; }
public version version ( ) { return version ; }
public composite request condition get matching condition ( server web exchange exchange ) { if ( be empty ( ) ) { return this ; } request condition holder [ ] match condition = new request condition holder [ get length ( ) ] ; for ( int i = 0 ; i < get length ( ) ; i++ ) { match condition [ i ] = this . request condition [ i ] . get matching condition ( exchange ) ; if ( match condition [ i ] == null ) { return null ; } } return new composite request condition ( matching condition ) ; }
public list < condition > get condition ( ) { return condition ; }
public int compare to ( request mapping info other , server web exchange exchange ) { int result = this . pattern condition . compare to ( other . get patterns condition ( ) , exchange ) ; if ( result ! = 0 ) { return result ; } result = this . params condition . compare to ( other . get params condition ( ) , exchange ) ; if ( result ! = 0 ) { return result ; } result = this . header condition . compare to ( other . get header condition ( ) , exchange ) ; if ( result ! = 0 ) { return result ; } result = this . consume condition . compare to ( other . get consumes condition ( ) , exchange ) ; if ( result ! = 0 ) { return result ; } result = this . produce condition . compare to ( other . get produces condition ( ) , exchange ) ; if ( result ! = 0 ) { return result ; } result = this . method condition . compare to ( other . get method condition ( ) , exchange ) ; if ( result ! = 0 ) { return result ; } result = this . custom condition holder . compare to ( other . custom condition holder , exchange ) ; if ( result ! = 0 ) { return result ; } return 0 ; }
public string get expression ( ) { return expression ; }
public result matcher method name ( string name ) { return result - > { handler method handler method = get handler method ( result ) ; assert equal ( `` handler method `` , name , handler method . get method ( ) . get name ( ) ) ; } ; }
public int compare to ( composite request condition other , server web exchange exchange ) { if ( be empty ( ) & & other . be empty ( ) ) { return 0 ; } else if ( be empty ( ) ) { return 1 ; } else if ( other . be empty ( ) ) { return -1 ; } else { assert number of condition ( other ) ; for ( int i = 0 ; i < get length ( ) ; i++ ) { int result = this . request condition [ i ] . compare to ( other . request condition [ i ] , exchange ) ; if ( result ! = 0 ) { return result ; } } return 0 ; } }
public charset get default charset ( ) { return default charset ; }
public atomic integer assert have value ( int expect value ) { be not null ( ) ; int actual value = actual . get ( ) ; if ( ! object . get comparison strategy ( ) . be equal ( actual value , expect value ) ) { throw assertion error ( should have value ( actual , expect value ) ) ; } return myself ; }
public query get query ( ) { return query ; }
public string get log prefix ( ) { return this . log prefix ; }
public void add predicate ( predicate predicate ) { if ( this . predicate == collection . empty_list ) { this . predicate = new array list ( ) ; } this . predicate . add ( predicate ) ; }
public byte buffer get payload ( ) { if ( payload == null ) return buffer util . empty_buffer ; return payload ; }
public pattern get pattern ( ) { return pattern ; }
public void set order ( int order ) { this . order = order ; }
public list < interceptor > get interceptor ( ) { return interceptor chain . get interceptor ( ) ; }
public url base view resolver registration script template ( ) { if ( ! check bean of type ( script template configurer . class ) ) { throw new bean initialization exception ( `` in addition to a script template view resolver `` + `` there must also be a single script template config bean in this web application context `` + `` ( or it parent ) : script template configurer be the usual implementation . `` + `` this bean may be give any name . `` ) ; } script registration registration = new script registration ( ) ; url base view resolver resolver = registration . get view resolver ( ) ; if ( this . application context ! = null ) { resolver . set application context ( this . application context ) ; } this . view resolvers . add ( resolver ) ; return registration ; }
protect void inject dependency ( test context test context ) throw exception { object bean = test context . get test instance ( ) ; class < ? > clazz = test context . get test class ( ) ; autowire capable bean factory bean factory = test context . get application context ( ) . get autowire capable bean factory ( ) ; bean factory . autowire bean property ( bean , autowire capable bean factory . autowire_no , false ) ; bean factory . initialize bean ( bean , clazz . get name ( ) + autowire capable bean factory . original_instance_suffix ) ; test context . remove attribute ( reinject_dependencies_attribute ) ; }
public void set context ( string context ) { if ( context . start with ( `` / `` ) ) { this . context = context ; } else { this . context = `` / `` + context ; } }
public void set context type id ( string context type id ) { assert . be not null ( context type id ) ; f context type id= context type id ; }
protect void resume trace ( ) { if ( trace logger . be loggable ( level . fine ) ) { trace input . set trace ( true ) ; trace output . set trace ( true ) ; } }
public void set servlet ( servlet servlet ) { instance = servlet ; }
public int get handler method count ( ) { return this . exception handler map . size ( ) ; }
public result matcher method name ( string name ) { return result - > { handler method handler method = get handler method ( result ) ; assert equal ( `` handler method `` , name , handler method . get method ( ) . get name ( ) ) ; } ; }
public void set init method ( string init method ) { this . init method = init method ; }
public string get alias ( ) { return alias ; }
public mapping get mapping ( ) { return mapping ; }
public static boolean be transmittable ( int status code ) { return ( status code == normal ) || ( status code == shutdown ) || ( status code == protocol ) || ( status code == bad_data ) || ( status code == bad_payload ) || ( status code == policy_violation ) || ( status code == message_too_large ) || ( status code == required_extension ) || ( status code == server_error ) || ( status code == service_restart ) || ( status code == try_again_later ) || ( status code == invalid_upstream_response ) ; }
public handler [ ] get and set handler ( final handler [ ] handler ) throw security exception { final handler [ ] safe handler = handler . clone ( ) ; for ( handler handler : safe handler ) { if ( handler == null ) { throw new illegal argument exception ( `` a handler be null `` ) ; } } return logger node . set handler ( safe handler ) ; }
public string get language ( ) { return language ; }
public void set locale ( locale locale ) { this . locale = locale ; }
public void set url ( string url ) { this . url = url ; }
public io . vertx . reactivex . redis . client . request arg ( int arg ) { delegate . arg ( arg ) ; return this ; }
public byte [ ] get response body content ( ) { return this . response body . block ( this . timeout ) ; }
public reactive adapter get adapter ( class < ? > reactive type ) { return get adapter ( reactive type , null ) ; }
public string get callback name ( ) { return callback name ; }
public void set chunk type ( final medium type medium type ) throw illegal argument exception { if ( medium type == null ) { throw new illegal argument exception ( localization message . chunked_input_media_type_null ( ) ) ; } this . medium type = medium type ; }
protect boolean match uri request pattern ( final string pattern , final string request uri ) { if ( pattern . equal ( `` * `` ) ) { return true ; } else { return ( pattern . end with ( `` * `` ) & & request uri . start with ( pattern . substring ( 0 , pattern . length ( ) - 1 ) ) ) || ( pattern . start with ( `` * `` ) & & request uri . end with ( pattern . substring ( 1 , pattern . length ( ) ) ) ) ; } }
public static web application context find web application context ( http servlet request request ) { return find web application context ( request , request . get servlet context ( ) ) ; }
public date time zone get time zone ( ) { return this . time zone ; }
public string get path ( ) { return this . path ; }
public final web application context get web application context ( ) { return this . web application context ; }
public locale get locale ( ) { return locale ; }
public cache control cache control ( ) { cache control result = cache control ; return result ! = null ? result : ( cache control = cache control . parse ( header ) ) ; }
public string get path ( ) { return path ; }
public void set delimiter ( string delimiter ) { this . delimiter = delimiter ; }
public string get delimiter ( ) { return this . delimiter ; }
public model map get default model ( ) { return this . default model ; }
public void set message ( string message ) { this . message = message ; }
public void set argument ( object [ ] argument ) { this . argument = argument ; }
public void set scope ( final scope scope ) { this . scope = scope ; }
public void write ( data output out ) throw i o exception { out . write ( code ) ; }
public void set ( int value ) { this . value = value ; }
public object get context ( ) { return context ; }
public static synchronize void set default ( default default ) { default = default ; }
public static kryo pool with byte array output stream ( int pool size , final kryo instantiator ki ) { return new kryo pool ( pool size ) { protect ser de state new instance ( ) { return new ser de state ( ki . new kryo ( ) , new input ( ) , new output ( new byte array output stream ( ) ) ) { / * * we have to take extra care of the byte array output stream * / @ override public void clear ( ) { super . clear ( ) ; byte array output stream byte stream = ( byte array output stream ) output . get output stream ( ) ; byte stream . reset ( ) ; } @ override public byte [ ] output to byte ( ) { output . flush ( ) ; byte array output stream byte stream = ( byte array output stream ) output . get output stream ( ) ; return byte stream . to byte array ( ) ; } @ override public void write output to ( output stream os ) throw i o exception { output . flush ( ) ; byte array output stream byte stream = ( byte array output stream ) output . get output stream ( ) ; byte stream . write to ( o ) ; } } ; } } ; }
public void set strip space ( int strip action ) { option . set strip space ( strip action ) ; }
public string output string ( final wire feed feed ) throw illegal argument exception , feed exception { return this . output string ( feed , true ) ; }
protect < t > t get bean ( string bean name , class < t > expect type ) { return bean factory annotation utils . qualified bean of type ( this . application context , expect type , bean name ) ; }
public boolean be require ( ) { return require ; }
public type description add type description ( type description definition ) { if ( definition == null ) { throw new null pointer exception ( `` type description be require . `` ) ; } tag tag = definition . get tag ( ) ; type tag . put ( tag , definition . get type ( ) ) ; definition . set property utils ( get property utils ( ) ) ; return type definition . put ( definition . get type ( ) , definition ) ; }
public void set tree model ( int model ) { tree model = model ; }
public j s o n marshaller create j s o n marshaller ( ) throw j a x b exception { return new j s o n marshaller impl ( this , get j s o n configuration ( ) ) ; }
public void after property set ( ) { init handler method ( ) ; }
public resource chain registration add transformer ( resource transformer transformer ) { assert . not null ( transformer , `` the provided resource transformer should not be null `` ) ; this . transformer . add ( transformer ) ; if ( transformer instanceof cs link resource transformer ) { this . have css link transformer = true ; } return this ; }
public static void main ( string [ ] args ) throw i o exception { parse args ( args ) . upgrade ( ) ; }
public string get system id ( ) { return system id ; }
public string to string ( ) { return get i d ( ) ; }
public void set root name ( string string ) { root name = string ; }
public boolean be async support ( ) { return request . be async support ( ) ; }
public final base64 variant get base64 variant ( ) { return _config . get base64 variant ( ) ; }
public string local name ( ) { return the local name ; }
public final boolean local ( ) { return local ; }
public synchronize void set parent ( part parent ) { this . parent = parent ; }
public static file resource a file resource ( file provider file provider ) { if ( file provider instanceof file resource || file provider == null ) { return ( file resource ) file provider ; } file resource result = new file resource ( file provider . get file ( ) ) ; result . set project ( project . get project ( file provider ) ) ; return result ; }
public set < string > get reference string ( ) { return reference string ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public string get provider ( ) { return provider ; }
public list < server service definition > get service ( ) { return service ; }
public void set port ( int port ) { this . port = port ; }
public logger get logger ( ) { return logger ; }
public image from dockerfile with dockerfile ( path dockerfile ) { this . dockerfile = optional . of ( dockerfile ) ; return this ; }
public image from dockerfile with dockerfile path ( string relative path from build context directory ) { this . docker file path = optional . of ( relative path from build context directory ) ; return this ; }
public string [ ] get command ( ) { return command ; }
public void set id ( string id ) { this . id = id ; }
public void set class loader ( class loader loader ) { class loader = loader ; }
public string get provider ( ) { return provider ; }
public int count ( ) { return count ; }
public int count ( ) { return count ; }
public command get command ( final string command id ) { check id ( command id ) ; command command = ( command ) handle object by id . get ( command id ) ; if ( command == null ) { command = new command ( command id ) ; command . should fire event = should command fire event ; handle object by id . put ( command id , command ) ; command . add command listener ( this ) ; if ( execution listener ! = null ) { command . add execution listener ( execution listener ) ; } } return command ; }
public string [ ] get command ( ) { return command ; }
public document parser ( parser parser ) { this . parser = parser ; return this ; }
public int read int ( ) throw i o exception { return read int ( this ) ; }
public static short to short ( object value ) throw conversion exception { number n = to number ( value , short . class ) ; if ( n instanceof short ) { return ( short ) n ; } else { return new short ( n . short value ( ) ) ; } }
public static int get int ( byte [ ] data ) { return get int ( data , 0 ) ; }
public void set resource ( resource resource ) { this . resource = resource ; }
public void add resource ( closeable resource ) { resource . add first ( resource ) ; }
public boolean have next ( ) { return false ; }
public boolean add ( final t element ) { boolean add = add elem ( element ) ; expand if necessary ( ) ; return add ; }
public string get language ( ) { return null ; }
public void set property ( string property ) { this . property = property ; }
public output < long > decode value ( ) { return decode value ; }
public static medium type create ( string type , string subtype ) { medium type medium type = create ( type , subtype , immutable list multimap . < string , string > of ( ) ) ; medium type . parse charset = optional . absent ( ) ; return medium type ; }
public static char range be ( char ch ) { return new char range ( ch , ch , false ) ; }
public mime type get mime type ( ) { return mime type ; }
public void set registry ( registry registry ) { this . registry = registry ; }
protect boolean be fallback to system locale ( ) { return this . fallback to system locale ; }
public collection < metadata > get metadata ( ) { return metadata ; }
public int get min depth ( ) { return this . min depth ; }
public string to string ( ) { string builder sb = new string builder ( 256 ) ; sb . append ( `` ( `` ) ; sb . append ( get subject ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get predicate ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get object ( ) ) ; sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
public iterator < byte cursor > descend iterator ( ) { return new descend value iterator ( ) ; }
public reader parse ( url url ) throw i o exception { metadata metadata = new metadata ( ) ; input stream stream = tika input stream . get ( url , metadata ) ; return parse ( stream , metadata ) ; }
public reader parse ( file file , metadata metadata ) throw i o exception { @ suppress warning ( `` deprecation `` ) input stream stream = tika input stream . get ( file , metadata ) ; return parse ( stream , metadata ) ; }
public int get max length ( ) { return max length ; }
public throwable get cause ( ) { return cause ; }
public i content type matcher get matcher ( ) { return matcher ; }
public int size ( ) { return size ; }
public byte [ ] get byte ( ) { return byte ; }
public i unknown get i unknown ( ) { return i unknown ; }
public member get signature ( ) { return signature ; }
public int get int value ( ) { return 0 ; }
public byte [ ] get byte ( ) { return byte ; }
public void set size ( long size ) { this . size = size ; }
static public void reset ( ) { logger factory . reset ( ) ; }
public void write to ( final output stream out ) throw i o exception { for ( final block block : block ) { out . write ( block . data , 0 , block . limit ) ; } }
public axis engine get engine ( ) { return ( engine ) ; }
public string get script ( ) { return script ; }
protect boolean be include header ( ) { return this . include header ; }
public void run ( ) { this . delegate . run ( ) ; }
public string get include ( ) { return include ; }
public void set master ( boolean master ) { m master = master ; }
public string get type ( ) { return null ; }
public string get type ( ) { return null ; }
public j s o n object to j s o n object ( ) { return to j s o n object ( true ) ; }
public void previous page ( ) { if ( ! be first page ( ) ) { this . page -- ; } }
public static string get ( string key ) throw illegal argument exception { if ( key == null ) { throw new illegal argument exception ( `` key parameter can not be null `` ) ; } if ( mdc adapter == null ) { throw new illegal state exception ( `` m d c adapter can not be null . see also `` + null_mdca_url ) ; } return mdc adapter . get ( key ) ; }
public boolean get sort by position ( ) { return sort by position ; }
public void set image ( final image image ) { this . image = image ; }
public string get path ( ) { return path ; }
public int get min length ( ) { return min length ; }
public void set file encode ( string encode ) { this . file encode = encoding ; }
public void set timeout ( time value timeout ) { this . timeout = timeout ; }
public string get language ( ) { return language ; }
public int read int ( ) throw i o exception { return read int ( this ) ; }
public void skip w p byte ( int num of byte ) throw i o exception { for ( int i = 0 ; i < num of byte ; i++ ) { read w p byte ( ) ; } }
public byte read w p byte ( ) throw i o exception { return in . read byte ( ) ; }
public boolean http only ( ) { return http only ; }
default public void attribute replace ( servlet context attribute event event ) { }
public boolean be permanent ( ) { return permanent ; }
public final boolean be cache ( ) { return cache ; }
public void set landing page ( string land page ) { this . landing page = landing page ; }
public string get landing page ( ) { return land page ; }
public boolean be require ( ) { return require ; }
public static list < z k auth info > parse auth ( string auth string ) throw bad auth format exception { list < z k auth info > ret = list . new array list ( ) ; if ( auth string == null ) { return ret ; } list < string > auth comp = list . new array list ( splitter . on ( ' , ' ) . omit empty string ( ) . trim result ( ) . split ( auth string ) ) ; for ( string comp : auth comp ) { string part [ ] = comp . split ( `` : `` , 2 ) ; if ( part . length ! = 2 ) { throw new bad auth format exception ( `` auth ' `` + comp + `` ' not of expect form scheme : auth `` ) ; } ret . add ( new z k auth info ( part [ 0 ] , part [ 1 ] . get byte ( charsets . utf_8 ) ) ) ; } return ret ; }
public principal get principal ( ) { return this . principal ; }
public boolean be enable ( ) { return this . enable ; }
public void set port ( int port ) { this . port = port ; }
public void resume ( ) { delegate . resume ( ) ; }
public int read ( ) throw i o exception { throw new i o exception ( ) ; }
public void write to ( final output stream out ) throw i o exception { for ( final block block : block ) { out . write ( block . data , 0 , block . limit ) ; } }
public string get decode request u r i ( ) { return coyote request . decode u r i ( ) . to string ( ) ; }
public input stream get input stream ( ) { return input stream ; }
public void remove tail record ( note record note ) { tail rec . remove ( note . get shape id ( ) ) ; }
public http response with cooky ( cookie . . . cooky ) { this . cooky . with entry ( cooky ) ; return this ; }
public void set id ( string id ) { this . id = id ; }
public string get namespace u r i ( ) { return name pool . get u r i from u r i code ( uri code ) ; }
static public void reset ( ) { logger factory . reset ( ) ; }
public static service get service ( container container ) { while ( container ! = null & & ! ( container instanceof engine ) ) { container = container . get parent ( ) ; } if ( container == null ) { return null ; } return ( ( engine ) container ) . get service ( ) ; }
public container get container ( ) { return container ; }
public enumeration get name ( ) { return parameter . key ( ) ; }
public boolean contains name ( final string name ) { for ( final t i : this ) { if ( i . get name ( ) . equal ( name ) ) { return true ; } } return false ; }
public void remove child ( string name ) throw m bean exception { if ( name ! = null ) { container container = do get manage resource ( ) ; container contain = container . find child ( name ) ; container . remove child ( contain ) ; } }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public string get encode ( ) { return encode ; }
public void set use naming ( boolean use naming ) { this . use name = use name ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public boolean be x h t m l ( ) { return do x h t m l ; }
public string get ref log message ( ) { return destination . get ref log message ( ) ; }
public static role role ( string name ) { return role ( name ( name ) ) ; }
public jvm stats get jvm ( ) { return jvm ; }
public boolean be unpack require ( ) { return this . unpack require ; }
public void set use naming ( boolean use naming ) { this . use name = use name ; }
public void set server ( string server ) { this . server = server ; }
public void set server ( string server ) { this . server = server ; }
public boolean be available ( ) { return impl . be available ( impl ) ; }
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public string get servlet path ( ) { return this . servlet path ; }
public container get container ( ) { return container ; }
public impl embed ( char sequence ref , resource resource ) { if ( string utils . be not empty ( ref ) & & resource ! = null ) { list < resource > resource = this . embed map . compute if absent ( ref , char sequence - > new array list < > ( ) ) ; resource . add ( resource ) ; } return ( impl ) this ; }
public string get message ( ) { return message ; }
public static string collection to comma delimited string ( collection < ? > coll ) { return collection to delimit string ( coll , `` , `` ) ; }
public void set port ( int port ) { this . port = port ; }
public boolean get boolean value ( ) { return false ; }
public boolean version ( ) { return search context . version ( ) ; }
public container get container ( ) { return container ; }
public void destroy ( ) { unregister from m bean notification ( ) ; mbean server . destroy ( ) ; }
public connector get connector ( ) { return state . get connector ( ) ; }
public string m bean server info ( ) { return m bean server manager . get server info ( ) ; }
public list < resource > get resource ( ) { return resource ; }
public string encode ( char sequence raw password ) { string salt = prefix + this . salt generator . generate key ( ) + suffix ; return digest ( salt , raw password ) ; }
public static object [ ] remove ( object [ ] array , int index ) { return ( object [ ] ) remove ( ( object ) array , index ) ; }
public void set first col ( int col ) { field_2_first_col = col ; }
public void set session attribute value class name filter ( string session attribute value class name filter ) throw pattern syntax exception { if ( session attribute value class name filter == null || session attribute value class name filter . length ( ) == 0 ) { session attribute value class name pattern = null ; } else { session attribute value class name pattern = pattern . compile ( session attribute value class name filter ) ; } }
public string get session attribute name filter ( ) { if ( session attribute name pattern == null ) { return null ; } return session attribute name pattern . to string ( ) ; }
public void set session attribute value class name filter ( string session attribute value class name filter ) throw pattern syntax exception { if ( session attribute value class name filter == null || session attribute value class name filter . length ( ) == 0 ) { session attribute value class name pattern = null ; } else { session attribute value class name pattern = pattern . compile ( session attribute value class name filter ) ; } }
public object set ( int index , object obj ) { if ( obj instanceof attribute ) { attribute attribute = ( attribute ) obj ; int duplicate = index of duplicate ( attribute ) ; if ( ( duplicate > = 0 ) & & ( duplicate ! = index ) ) { throw new illegal add exception ( `` can not set duplicate attribute `` ) ; } return set ( index , attribute ) ; } else if ( obj == null ) { throw new illegal add exception ( `` can not add null attribute `` ) ; } else { throw new illegal add exception ( `` class `` + obj . get class ( ) . get name ( ) + `` be not an attribute `` ) ; } }
public store get store ( ) { return store ; }
public long get max interval ( ) { return max interval ; }
public principal get principal ( ) { return this . principal ; }
public void remove note ( string name ) { note . remove ( name ) ; }
public method get method ( ) { return method ; }
public void set use naming ( boolean use naming ) { this . use name = use name ; }
public void set e l context ( e l context context ) { this . context = context ; }
public boolean have ( string name ) { return index by name . contains key ( name ) ; }
public void set base path ( string base path ) { this . base path = base path ; }
public void add resource ( closeable resource ) { resource . add first ( resource ) ; }
public void set password ( string password ) { this . password = password ; }
public int appe ( string pathname ) throw i o exception { return send command ( f t p command . appe , pathname ) ; }
public string get charset ( ) { return charset ; }
public boolean get be read ( ) { return this . be read ; }
public select set lock mode ( lock mode lock mode ) { lock option . set lock mode ( lock mode ) ; return this ; }
public data source builder < t > driver class name ( string driver class name ) { set ( data source property . driver_class_name , driver class name ) ; return this ; }
public void set user ( string user ) { super . set internal user ( user ) ; }
public long get timestamp ( ) { return timestamp ; }
public void set concurrency limit ( int concurrency limit ) { this . concurrency throttle . set concurrency limit ( concurrency limit ) ; }
public boolean get boolean value ( ) { return false ; }
public authentication builder add custom ( authentication authentication ) { if ( authentication ! = null ) { authentication . add ( authentication ) ; } return this ; }
public synchronize void set http connection factory timeout ( long timeout ) { this . params . set connection manager timeout ( timeout ) ; }
public string get user agent ( ) { return this . user agent ; }
public void set server ( string server ) { this . server = server ; }
public int get max size ( ) { return this . max size ; }
public int get chunk size ( ) { return chunk size ; }
public void set commit name ( string [ ] commit name ) { this . commit name = commit name ; }
public void set commit name ( string [ ] commit name ) { this . commit name = commit name ; }
public static boolean set read only ( string file name ) { return file path . get ( file name ) . set read only ( ) ; }
public static void set context class loader ( class loader loader ) { context class loader = loader ; }
public object get handler ( ) { return this . handler ; }
public synchronize boolean be s s l ( ) { return use s s l ; }
public static int read int ( byte [ ] byte , int start ) { return ( ( ( bytes [ start ] & 0xff ) < < 24 ) + ( ( bytes [ start+1 ] & 0xff ) < < 16 ) + ( ( bytes [ start+2 ] & 0xff ) < < 8 ) + ( ( bytes [ start+3 ] & 0xff ) ) ) ; }
public void recycle ( ) { encoder . reset ( ) ; leftover . position ( 0 ) ; }
public int get offset ( ) { return offset ; }
public void recycle ( ) { decoder . reset ( ) ; leftover . position ( 0 ) ; }
public method get method ( ) { return method ; }
public constraint find constraint ( session session , string name ) { constraint constraint = constraint . get ( name ) ; if ( constraint == null ) { constraint = session . find local temp table constraint ( name ) ; } return constraint ; }
public void add role name ( string role name ) { if ( role names == null ) { role name = new . array list ( ) ; } role name . add ( role name ) ; }
public static void set thread cpu time enable ( boolean enable ) { thread m x bean . set thread cpu time enable ( enable ) ; boolean check value = thread m x bean . be thread cpu time enable ( ) ; if ( enable ! = check value ) { log . error ( `` could not set thread cpu time enable to `` + enable + `` , get `` + check value + `` instead `` ) ; } }
public static boolean be thread cpu time enable ( ) { return thread m x bean . be thread cpu time enable ( ) ; }
public void set level name ( string new level name ) throw security exception { set level ( logger node . get context ( ) . get level for name ( new level name ) ) ; }
public @ not null thread get thread ( ) { return thread ; }
public static int next high power of two ( int v ) { v -- ; v |= v > > 1 ; v |= v > > 2 ; v |= v > > 4 ; v |= v > > 8 ; v |= v > > 16 ; v++ ; return v ; }
public boolean be pattern ( ) { return pattern name ! = null ; }
protect string get timestamp ( ) { date date = new date ( system . current time millis ( ) ) ; date format formatter = date format . get date time instance ( date format . short , date format . short ) ; string finish time = formatter . format ( date ) ; return finish time ; }
public void set date format ( string date format ) { super . set internal date format ( new simple date format ( date format ) ) ; }
public byte [ ] get sign content ( input stream pdf file ) throw i o exception { c o s filter input stream fis=null ; try { fis = new c o s filter input stream ( pdf file , get byte range ( ) ) ; return fis . to byte array ( ) ; } finally { if ( fis ! = null ) { fis . close ( ) ; } } }
public string get field name ( ) { return field name ; }
public int get max size ( ) { return this . max size ; }
public progress listener get progress listener ( ) { return this . listener ; }
public string get field name ( ) { return field name ; }
public io . vertx . axle . core . buffer . buffer set int ( int po , int i ) { delegate . set int ( po , i ) ; return this ; }
public int po ( ) { return po ; }
public int read int ( ) throw i o exception { return read int ( this ) ; }
public void clear ( ) { clear ( size ) ; }
public list get attribute ( ) { return attribute ; }
public string [ ] get message ( ) { throwable [ ] throwables = this . get throwables ( ) ; string [ ] msg = new string [ throwables . length ] ; for ( int i = 0 ; i < throwables . length ; i++ ) { msgs [ i ] = ( nestable . class . be instance ( throwables [ i ] ) ? ( ( nestable ) throwables [ i ] ) . get message ( 0 ) : throwables [ i ] . get message ( ) ) ; } return msg ; }
public void set host ( string host ) { this . host = host ; } // -- void set host ( string )
public static schedule executor service default executor ( ) { return default executor holder . i ; }
public void set count ( int count ) { this . count = count ; }
public string get attribute ( string key ) { return get table value ( attribute , key ) ; }
public static output stream get output stream ( socket socket , long timeout ) throw i o exception { return ( socket . get channel ( ) == null ) ? socket . get output stream ( ) : new socket output stream ( socket , timeout ) ; }
@ override public void flush ( ) throw i o exception { delegate . flush ( ) ; }
public example set property selector ( property selector selector ) { this . selector = selector ; return this ; }
public int priority ( ) { int ret = delegate . priority ( ) ; return ret ; }
public synchronize void execute ( string root , runnable task ) { thread pool executor executor = executor . get ( root ) ; if ( executor == null ) { throw new runtime exception ( `` can not find root `` + root + `` for execution of task `` + task ) ; } else { executor . execute ( task ) ; } }
public boolean need content length ( ) { return false ; }
public long count ( ) { return count ; }
public int get limit ( ) { return limit ; }
public boolean have queue thread ( thread thread ) { return sync . be queue ( thread ) ; }
public string get name ( ) { return name ; }
public static http u r i create http u r i ( string scheme , string host , int port , string path , string param , string query , string fragment ) { if ( port == 80 & & http scheme . http . be ( scheme ) ) port = 0 ; if ( port == 443 & & http scheme . http . be ( scheme ) ) port = 0 ; return new http u r i ( scheme , host , port , path , param , query , fragment ) ; }
public parameter [ ] get params ( ) { parameter [ ] params = new parameter [ parameter . size ( ) ] ; parameter . copy into ( params ) ; return params ; }
public handler [ ] get and set handler ( final handler [ ] handler ) throw security exception { final handler [ ] safe handler = handler . clone ( ) ; for ( handler handler : safe handler ) { if ( handler == null ) { throw new illegal argument exception ( `` a handler be null `` ) ; } } return logger node . set handler ( safe handler ) ; }
public final boolean have event handler ( ) { return get event handler ( ) ! =this ; }
public void set escape char ( char escape char ) { this . escape char = escape char ; }
public string to string ( ) { return new string buffer ( ) . append ( `` [ entity ref : `` ) . append ( `` & `` ) . append ( name ) . append ( `` ; `` ) . append ( `` ] `` ) . to string ( ) ; }
public static string get loader name for resource ( string resource name ) { return ri . get loader name for resource ( resource name ) ; }
public void set warn log category ( string logger name ) { this . warn logger = log factory . get log ( logger name ) ; }
public void set macro ( string macro ) { graphic frame . set macro ( macro ) ; }
public string get method name ( ) { return this . method name ; }
public static cod input stream new instance ( final byte [ ] buf ) { return new instance ( buf , 0 , buf . length ) ; }
public extend block get current block ( ) { return get d f s input stream ( ) . get current block ( ) ; }
public void replace current interpolation term ( string replacement ) { token token = new token ( replacement ) ; token . terminate ( ) ; token list . set ( current position - 1 , token ) ; }
public list get stop class ( ) { return stop class ; }
public node get parent ( ) { return parent ; }
public boolean be postfix ( ) { return be postfix ; }
public string get indent ( ) { return format indentation ; }
public void set context ( string context ) { if ( context . start with ( `` / `` ) ) { this . context = context ; } else { this . context = `` / `` + context ; } }
public document parser ( parser parser ) { this . parser = parser ; return this ; }
public void set interval ( long interval ) { this . interval = interval ; }
public void set name ( string name ) { this . name = name ; }
public long get last modified ( ) { return last modify ; }
public http request with body ( string body ) { this . body = new string body ( body ) ; return this ; }
public long get last modified ( ) { return last modify ; }
public final string get template ( ) { return template ; }
public string key ( ) { return key ; }
public string get attribute ( string key ) { return get table value ( attribute , key ) ; }
public configuration add property ( property property ) { this . property . put all ( property ) ; return this ; }
public static boolean resource exists ( string resource name ) { return ( runtime singleton . get loader name for resource ( resource name ) ! = null ) ; }
public string current name ( ) throw i o exception { return get current name ( ) ; }
public void remove ( ) { throw new unsupported operation exception ( get class ( ) . get name ( ) ) ; }
public void set class ( class clazz ) { this . clazz = clazz ; if ( clazz == null ) { return ; } this . class loader = ( class loader == null ) ? clazz . get class loader ( ) : class loader ; this . class name = ( class name == null ) ? clazz . get name ( ) : class name ; }
public object get actual value ( ) { return this . actual value ; }
public string key ( ) { return key ; }
public axis engine get engine ( ) { return ( engine ) ; }
public mime type get mime type ( ) { return mime type ; }
public string get import simple name ( ) { if ( be import on demand ) { return null ; } string import name = get import name ( ) ; return import name . substring ( import name . last index of ( ' . ' ) + 1 ) ; }
public static void write line break ( x m l writer writer ) throw i o exception { write line break ( writer , 1 ) ; }
public int get hidden state i d ( string name ) { if ( hidden state name == null ) { return -1 ; } integer tmp = hidden state name . get ( name ) ; return tmp == null ? -1 : tmp ; }
public string get validity url ( ) { return validity url ; }
public deployment option set isolation group ( string isolation group ) { this . isolation group = isolation group ; return this ; }
public string get isolation group ( ) { return isolation group ; }
public void set ( object instance ) { this . declared class = instance . get class ( ) ; this . instance = instance ; }
public long get time to live in millis ( ) throw transaction time out exception { if ( this . deadline == null ) { throw new illegal state exception ( `` no timeout specify for this resource holder `` ) ; } long time to live = this . deadline . get time ( ) - system . current time millis ( ) ; check transaction timeout ( time to live < = 0 ) ; return time to live ; }
public void set header ( string header ) { this . header = header ; }
public void set host ( string host ) { this . host = host ; } // -- void set host ( string )
public json object to json object ( ) { json object ret = delegate . to json object ( ) ; return ret ; }
public http client option set pipelining ( boolean pipelining ) { this . pipelining = pipelining ; return this ; }
public boolean be pipelining ( ) { return pipelining ; }
public void set port ( int port ) { this . port = port ; }
public int get max text message size ( ) { return max text message size ; }
public http call set header ( string key , string value ) { require non null ( key , `` header key can not be null `` ) ; require non null ( value , `` header [ `` + key + `` ] can not have null value `` ) ; header . put ( key , value ) ; return this ; }
public version get version ( ) { return this . version ; }
public void set main class ( string main class ) { this . main class = main class ; }
protect synchronized void create ( vertx option option , handler < async result < vertx > > result handler ) { final class loader original class loader = thread . current thread ( ) . get context class loader ( ) ; try { thread . current thread ( ) . set context class loader ( classloader ! = null ? classloader : get class ( ) . get class loader ( ) ) ; vertx . cluster vertx ( option , result handler ) ; } catch ( exception e ) { log . error ( `` fail to create the vert . x instance `` , e ) ; } finally { thread . current thread ( ) . set context class loader ( original class loader ) ; } }
protect synchronized vertx create ( vertx option option ) { final class loader original class loader = thread . current thread ( ) . get context class loader ( ) ; try { thread . current thread ( ) . set context class loader ( classloader ! = null ? classloader : get class ( ) . get class loader ( ) ) ; return vertx . vertx ( option ) ; } catch ( exception e ) { log . error ( `` fail to create the vert . x instance `` , e ) ; } finally { thread . current thread ( ) . set context class loader ( original class loader ) ; } return null ; }
protect void set name source start ( int start ) { this . name start= start ; }
public byte [ ] decode ( ) { return base64 codec . decode ( value ) ; }
public string get encode ( ) { return encode ; }
public string get encode ( ) { return encode ; }
public int size ( ) { return size ; }
public void set password ( string password ) { this . password = password ; }
public string get path ( ) { return this . path ; }
public void set interval ( long interval ) { this . interval = interval ; }
public integer get receive buffer size ( ) { return receive buffer size ; }
public int get receive buffer size ( ) { return receive buffer size ; }
public pem trust option add cert value ( buffer cert value ) throw null pointer exception { object . require non null ( cert value , `` no null certificate accept `` ) ; cert value . add ( cert value ) ; return this ; }
public pem key cert option add cert path ( string cert path ) { argument . require ( cert path ! = null , `` null cert path `` ) ; cert path . add ( cert path ) ; return this ; }
public void set value ( object value ) { this . value = value ; }
public option get option ( ) { return option ; }
public pem trust option get pem trust option ( ) { return trust option instanceof pem trust option ? ( pem trust option ) trust option : null ; }
public t c p s s l option set trust option ( trust option option ) { this . trust option = option ; return this ; }
public path get path ( ) { return path ; }
public string get mode ( ) { return mode ; }
public static string get cluster name ( ) { return database descriptor . get cluster name ( ) ; }
public io . vertx . reactivex . redis . client . redis a p i unwatch ( handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . unwatch ( new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . cassandra . cassandra client query stream ( com . datastax . driver . core . statement statement , handler < async result < io . vertx . reactivex . cassandra . cassandra row stream > > row stream handler ) { delegate . query stream ( statement , new handler < async result < io . vertx . cassandra . cassandra row stream > > ( ) { public void handle ( async result < io . vertx . cassandra . cassandra row stream > ar ) { if ( ar . succeed ( ) ) { row stream handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . cassandra . cassandra row stream . new instance ( ( io . vertx . cassandra . cassandra row stream ) ar . result ( ) ) ) ) ; } else { row stream handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . cassandra . cassandra client query stream ( com . datastax . driver . core . statement statement , handler < async result < io . vertx . reactivex . cassandra . cassandra row stream > > row stream handler ) { delegate . query stream ( statement , new handler < async result < io . vertx . cassandra . cassandra row stream > > ( ) { public void handle ( async result < io . vertx . cassandra . cassandra row stream > ar ) { if ( ar . succeed ( ) ) { row stream handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . cassandra . cassandra row stream . new instance ( ( io . vertx . cassandra . cassandra row stream ) ar . result ( ) ) ) ) ; } else { row stream handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . cassandra . cassandra client execute ( com . datastax . driver . core . statement statement , handler < async result < io . vertx . reactivex . cassandra . result set > > result handler ) { delegate . execute ( statement , new handler < async result < io . vertx . cassandra . result set > > ( ) { public void handle ( async result < io . vertx . cassandra . result set > ar ) { if ( ar . succeed ( ) ) { result handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . cassandra . result set . new instance ( ( io . vertx . cassandra . result set ) ar . result ( ) ) ) ) ; } else { result handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public object get handler ( ) { return this . handler ; }
public static io . vertx . axle . core . vertx vertx ( ) { io . vertx . axle . core . vertx ret = io . vertx . axle . core . vertx . new instance ( io . vertx . core . vertx . vertx ( ) ) ; return ret ; }
public object get handler ( ) { return this . handler ; }
public io . vertx . reactivex . core . http . http client request put ( int port , string host , string request u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . put ( port , host , request u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client get now ( string host , string request u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { delegate . get now ( host , request u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client request delete ( int port , string host , string request u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . delete ( port , host , request u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request put ( int port , string host , string request u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . put ( port , host , request u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client request put ( int port , string host , string request u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . put ( port , host , request u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client websocket ( string request u r i , io . vertx . reactivex . core . multi map header , io . vertx . core . http . websocket version version , string sub protocol , handler < io . vertx . reactivex . core . http . web socket > w connect ) { delegate . websocket ( request u r i , header . get delegate ( ) , version , sub protocol , new handler < io . vertx . core . http . web socket > ( ) { public void handle ( io . vertx . core . http . web socket event ) { ws connect . handle ( io . vertx . reactivex . core . http . web socket . new instance ( ( io . vertx . core . http . web socket ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client websocket ( string host , string request u r i , io . vertx . reactivex . core . multi map header , handler < io . vertx . reactivex . core . http . web socket > w connect ) { delegate . websocket ( host , request u r i , header . get delegate ( ) , new handler < io . vertx . core . http . web socket > ( ) { public void handle ( io . vertx . core . http . web socket event ) { ws connect . handle ( io . vertx . reactivex . core . http . web socket . new instance ( ( io . vertx . core . http . web socket ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http client request put ab ( string absolute u r i , handler < io . vertx . reactivex . core . http . http client response > response handler ) { io . vertx . reactivex . core . http . http client request ret = io . vertx . reactivex . core . http . http client request . new instance ( ( io . vertx . core . http . http client request ) delegate . put ab ( absolute u r i , new handler < io . vertx . core . http . http client response > ( ) { public void handle ( io . vertx . core . http . http client response event ) { response handler . handle ( io . vertx . reactivex . core . http . http client response . new instance ( ( io . vertx . core . http . http client response ) event ) ) ; } } ) ) ; return ret ; }
public void render ( json object context , string template file name , handler < async result < io . vertx . reactivex . core . buffer . buffer > > handler ) { delegate . render ( context , template file name , new handler < async result < io . vertx . core . buffer . buffer > > ( ) { public void handle ( async result < io . vertx . core . buffer . buffer > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . core . buffer . buffer . new instance ( ( io . vertx . core . buffer . buffer ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; }
public io . vertx . reactivex . core . http . http client request connection handler ( handler < io . vertx . reactivex . core . http . http connection > handler ) { delegate . connection handler ( new handler < io . vertx . core . http . http connection > ( ) { public void handle ( io . vertx . core . http . http connection event ) { handler . handle ( io . vertx . reactivex . core . http . http connection . new instance ( ( io . vertx . core . http . http connection ) event ) ) ; } } ) ; return this ; }
public io . vertx . reactivex . core . http . http server exception handler ( handler < java . lang . throwable > handler ) { delegate . exception handler ( handler ) ; return this ; }
public io . vertx . reactivex . core . http . http connection shutdown handler ( handler < void > handler ) { delegate . shutdown handler ( handler ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt server listen ( ) { delegate . listen ( ) ; return this ; }
public boolean be deploy ( string name ) { return deploy . contains key ( name ) ; }
public void clear ( ) { clear ( size ) ; }
public io . vertx . reactivex . ext . auth . hash strategy put ( string id , io . vertx . reactivex . ext . auth . hash algorithm algorithm ) { delegate . put ( id , algorithm . get delegate ( ) ) ; return this ; }
public io . vertx . reactivex . ext . auth . hash algorithm get ( string id ) { io . vertx . reactivex . ext . auth . hash algorithm ret = io . vertx . reactivex . ext . auth . hash algorithm . new instance ( ( io . vertx . ext . auth . hash algorithm ) delegate . get ( id ) ) ; return ret ; }
public string encode ( char sequence raw password ) { string salt = prefix + this . salt generator . generate key ( ) + suffix ; return digest ( salt , raw password ) ; }
public static io . vertx . reactivex . ext . auth . jdbc . j d b c hash strategy create p b k d f2 ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . auth . jdbc . j d b c hash strategy ret = io . vertx . reactivex . ext . auth . jdbc . j d b c hash strategy . new instance ( ( io . vertx . ext . auth . jdbc . j d b c hash strategy ) io . vertx . ext . auth . jdbc . j d b c hash strategy . create p b k d f2 ( vertx . get delegate ( ) ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . jdbc . j d b c hash strategy create s h a512 ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . auth . jdbc . j d b c hash strategy ret = io . vertx . reactivex . ext . auth . jdbc . j d b c hash strategy . new instance ( ( io . vertx . ext . auth . jdbc . j d b c hash strategy ) io . vertx . ext . auth . jdbc . j d b c hash strategy . create s h a512 ( vertx . get delegate ( ) ) ) ; return ret ; }
public void set user ( io . vertx . reactivex . ext . auth . user user ) { delegate . set user ( user . get delegate ( ) ) ; }
public algorithm get algorithm ( ) { return algorithm ; }
public void set algorithm ( io . vertx . ext . auth . mongo . hash algorithm algorithm ) { delegate . set algorithm ( algorithm ) ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . google auth . create ( vertx . get delegate ( ) , client id , client secret ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . google auth . create ( vertx . get delegate ( ) , client id , client secret ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . google auth . create ( vertx . get delegate ( ) , client id , client secret ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . facebook auth . create ( vertx . get delegate ( ) , client id , client secret ) ) ; return ret ; }
public static io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth create ( io . vertx . reactivex . core . vertx vertx , string client id , string client secret ) { io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth ret = io . vertx . reactivex . ext . auth . oauth2 . o auth2 auth . new instance ( ( io . vertx . ext . auth . oauth2 . o auth2 auth ) io . vertx . ext . auth . oauth2 . provider . google auth . create ( vertx . get delegate ( ) , client id , client secret ) ) ; return ret ; }
public io . vertx . reactivex . ext . consul . consul client health state ( io . vertx . ext . consul . health state health state , handler < async result < io . vertx . ext . consul . check list > > result handler ) { delegate . health state ( health state , result handler ) ; return this ; }
public io . vertx . reactivex . ext . consul . consul client delete value ( string key , handler < async result < void > > result handler ) { delegate . delete value ( key , result handler ) ; return this ; }
public json object get metric snapshot ( string base name ) { json object ret = delegate . get metric snapshot ( base name ) ; return ret ; }
public json object get metric snapshot ( io . vertx . reactivex . core . metric . measure measure ) { json object ret = delegate . get metric snapshot ( measure . get delegate ( ) ) ; return ret ; }
public io . vertx . reactivex . mqtt . mqtt server listen ( ) { delegate . listen ( ) ; return this ; }
public io . vertx . reactivex . redis . client . request arg ( int arg ) { delegate . arg ( arg ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client list index ( string collection , handler < async result < json array > > result handler ) { delegate . list index ( collection , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client count ( string collection , json object query , handler < async result < long > > result handler ) { delegate . count ( collection , query , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client count ( string collection , json object query , handler < async result < long > > result handler ) { delegate . count ( collection , query , result handler ) ; return this ; }
public io . vertx . reactivex . ext . mongo . mongo client list index ( string collection , handler < async result < json array > > result handler ) { delegate . list index ( collection , result handler ) ; return this ; }
public string [ ] get command ( ) { return command ; }
public void readline ( string prompt , handler < string > line handler , handler < io . vertx . reactivex . ext . shell . cli . completion > completion handler ) { delegate . readline ( prompt , line handler , new handler < io . vertx . ext . shell . cli . completion > ( ) { public void handle ( io . vertx . ext . shell . cli . completion event ) { completion handler . handle ( io . vertx . reactivex . ext . shell . cli . completion . new instance ( ( io . vertx . ext . shell . cli . completion ) event ) ) ; } } ) ; }
public io . vertx . reactivex . ext . shell . command . command build ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . ext . shell . command . command ret = io . vertx . reactivex . ext . shell . command . command . new instance ( ( io . vertx . ext . shell . command . command ) delegate . build ( vertx . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . shell . command . command builder process handler ( handler < io . vertx . reactivex . ext . shell . command . command process > handler ) { delegate . process handler ( new handler < io . vertx . ext . shell . command . command process > ( ) { public void handle ( io . vertx . ext . shell . command . command process event ) { handler . handle ( io . vertx . reactivex . ext . shell . command . command process . new instance ( ( io . vertx . ext . shell . command . command process ) event ) ) ; } } ) ; return this ; }
public static io . vertx . reactivex . ext . shell . term . term server create http term server ( io . vertx . reactivex . core . vertx vertx , io . vertx . reactivex . ext . web . router router ) { io . vertx . reactivex . ext . shell . term . term server ret = io . vertx . reactivex . ext . shell . term . term server . new instance ( ( io . vertx . ext . shell . term . term server ) io . vertx . ext . shell . term . term server . create http term server ( vertx . get delegate ( ) , router . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . ext . shell . shell create shell ( io . vertx . reactivex . ext . shell . term . term term ) { io . vertx . reactivex . ext . shell . shell ret = io . vertx . reactivex . ext . shell . shell . new instance ( ( io . vertx . ext . shell . shell ) delegate . create shell ( term . get delegate ( ) ) ) ; return ret ; }
public long get resume offset ( ) { return resume offset ; }
public void complete ( io . vertx . reactivex . ext . shell . cli . completion completion ) { delegate . complete ( completion . get delegate ( ) ) ; }
public io . vertx . reactivex . ext . shell . shell create shell ( io . vertx . reactivex . ext . shell . term . term term ) { io . vertx . reactivex . ext . shell . shell ret = io . vertx . reactivex . ext . shell . shell . new instance ( ( io . vertx . ext . shell . shell ) delegate . create shell ( term . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . redis . client . redis a p i unwatch ( handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . unwatch ( new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public void set default auto commit ( boolean default auto commit ) { this . default auto commit = default auto commit ; }
public io . vertx . reactivex . ext . stomp . stomp client connection send ( string destination , java . util . map < string , string > header , io . vertx . reactivex . core . buffer . buffer body ) { delegate . send ( destination , header , body . get delegate ( ) ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client connection send ( java . util . map < string , string > header , io . vertx . reactivex . core . buffer . buffer body ) { delegate . send ( header , body . get delegate ( ) ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client connection send ( string destination , java . util . map < string , string > header , io . vertx . reactivex . core . buffer . buffer body ) { delegate . send ( destination , header , body . get delegate ( ) ) ; return this ; }
public io . vertx . reactivex . ext . stomp . stomp client connection send ( java . util . map < string , string > header , io . vertx . reactivex . core . buffer . buffer body ) { delegate . send ( header , body . get delegate ( ) ) ; return this ; }
public void set count ( int count ) { this . count = count ; }
public boolean to boolean ( ) { boolean ret = delegate . to boolean ( ) ; return ret ; }
public io . vertx . reactivex . ext . unit . test completion run ( io . vertx . reactivex . core . vertx vertx , io . vertx . ext . unit . test option option ) { io . vertx . reactivex . ext . unit . test completion ret = io . vertx . reactivex . ext . unit . test completion . new instance ( ( io . vertx . ext . unit . test completion ) delegate . run ( vertx . get delegate ( ) , option ) ) ; return ret ; }
static public void assert not equal ( string message , long first , long second ) { assert not equal ( message , ( long ) first , ( long ) second ) ; }
public static io . vertx . axle . core . vertx vertx ( ) { io . vertx . axle . core . vertx ret = io . vertx . axle . core . vertx . new instance ( io . vertx . core . vertx . vertx ( ) ) ; return ret ; }
public static io . vertx . reactivex . ext . web . handler . cookie handler create ( ) { io . vertx . reactivex . ext . web . handler . cookie handler ret = io . vertx . reactivex . ext . web . handler . cookie handler . new instance ( ( io . vertx . ext . web . handler . cookie handler ) io . vertx . ext . web . handler . cookie handler . create ( ) ) ; return ret ; }
public list < string > form parameter names ( ) { list < string > ret = delegate . form parameter names ( ) ; return ret ; }
public list < string > cookie parameter names ( ) { list < string > ret = delegate . cookie parameter names ( ) ; return ret ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add form params array with pattern ( string parameter name , string pattern , boolean require ) { delegate . add form params array with pattern ( parameter name , pattern , require ) ; return this ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add query params array with pattern ( string array name , string pattern , boolean require ) { delegate . add query params array with pattern ( array name , pattern , require ) ; return this ; }
public void set content type ( string content type ) { assert . not null ( content type , `` 'content type ' must not be null `` ) ; this . content type = content type ; }
public io . vertx . reactivex . ext . web . api . validation . h t t p request validation handler add expect content type ( string content type ) { delegate . add expected content type ( content type ) ; return this ; }
public http method get method ( ) { return this . method ; }
public call method builder with param type ( class < ? > . . . param type ) { this . param type = param type ; if ( param type ! = null ) { this . param count = param type . length ; } else { param count = 0 ; } return this ; }
public redirect config max redirects ( int value ) { return new redirect config ( follow redirects , allow circular redirects , reject relative redirect , value , true ) ; }
public static io . vertx . reactivex . ext . web . handler . cookie handler create ( ) { io . vertx . reactivex . ext . web . handler . cookie handler ret = io . vertx . reactivex . ext . web . handler . cookie handler . new instance ( ( io . vertx . ext . web . handler . cookie handler ) io . vertx . ext . web . handler . cookie handler . create ( ) ) ; return ret ; }
public io . vertx . reactivex . core . http . http client response body handler ( handler < io . vertx . reactivex . core . buffer . buffer > body handler ) { delegate . body handler ( new handler < io . vertx . core . buffer . buffer > ( ) { public void handle ( io . vertx . core . buffer . buffer event ) { body handler . handle ( io . vertx . reactivex . core . buffer . buffer . new instance ( ( io . vertx . core . buffer . buffer ) event ) ) ; } } ) ; return this ; }
public boolean be development ( ) { return be development ; }
public boolean to boolean ( ) { boolean ret = delegate . to boolean ( ) ; return ret ; }
public list < grant authority > get grant authority ( collection < string > attribute ) { list < grant authority > result = new array list < > ( attribute . size ( ) ) ; for ( string attribute : attribute ) { result . add ( get grant authority ( attribute ) ) ; } return result ; }
public boolean be handle ( ) { if ( handler == null ) { return false ; } return handler . be handle ( ) ; }
public io . vertx . reactivex . ext . web . api . contract . router factory set body handler ( io . vertx . reactivex . ext . web . handler . body handler body handler ) { delegate . set body handler ( body handler . get delegate ( ) ) ; return this ; }
public static io . vertx . reactivex . ext . web . handler . response content type handler create ( ) { io . vertx . reactivex . ext . web . handler . response content type handler ret = io . vertx . reactivex . ext . web . handler . response content type handler . new instance ( ( io . vertx . ext . web . handler . response content type handler ) io . vertx . ext . web . handler . response content type handler . create ( ) ) ; return ret ; }
public static template handler new instance ( io . vertx . ext . web . handler . template handler arg ) { return arg ! = null ? new template handler ( arg ) : null ; }
public static template handler new instance ( io . vertx . ext . web . handler . template handler arg ) { return arg ! = null ? new template handler ( arg ) : null ; }
public io . vertx . reactivex . core . http . http client websocket ( string host , string request u r i , io . vertx . reactivex . core . multi map header , handler < io . vertx . reactivex . core . http . web socket > w connect ) { delegate . websocket ( host , request u r i , header . get delegate ( ) , new handler < io . vertx . core . http . web socket > ( ) { public void handle ( io . vertx . core . http . web socket event ) { ws connect . handle ( io . vertx . reactivex . core . http . web socket . new instance ( ( io . vertx . core . http . web socket ) event ) ) ; } } ) ; return this ; }
public static io . vertx . reactivex . ext . web . handler . cookie handler create ( ) { io . vertx . reactivex . ext . web . handler . cookie handler ret = io . vertx . reactivex . ext . web . handler . cookie handler . new instance ( ( io . vertx . ext . web . handler . cookie handler ) io . vertx . ext . web . handler . cookie handler . create ( ) ) ; return ret ; }
public void set session ( session session ) { this . session = session ; }
public int get min length ( ) { return this . min length ; }
public byte [ ] get last name ( ) { if ( partial listing . length == 0 ) { return null ; } return partial listing [ partial listing . length-1 ] . get local name in byte ( ) ; }
public list < medium type > get support medium type ( ) { return this . supported medium type ; }
public static favicon handler new instance ( io . vertx . ext . web . handler . favicon handler arg ) { return arg ! = null ? new favicon handler ( arg ) : null ; }
public path get path ( ) { return path ; }
public void add group ( string group ) { if ( be wild card a c l value ( group ) ) { throw new illegal argument exception ( `` group `` + group + `` can not be add `` ) ; } if ( ! be all allow ( ) ) { list < string > group list = new link list < string > ( ) ; group list . add ( group ) ; group map . cache group add ( group list ) ; group . add ( group ) ; } }
public void add handler ( w s d d handler handler ) { handler . add ( handler ) ; }
public void set user ( string user ) { super . set internal user ( user ) ; }
public static io . vertx . reactivex . ext . web . client . web client create ( io . vertx . reactivex . core . vertx vertx , io . vertx . ext . web . client . web client option option ) { io . vertx . reactivex . ext . web . client . web client ret = io . vertx . reactivex . ext . web . client . web client . new instance ( ( io . vertx . ext . web . client . web client ) io . vertx . ext . web . client . web client . create ( vertx . get delegate ( ) , option ) ) ; return ret ; }
public void end offset ( io . vertx . kafka . client . common . topic partition topic partition , handler < async result < long > > handler ) { delegate . end offset ( topic partition , handler ) ; }
public void close ( ) { delegate . close ( ) ; }
public void end offset ( io . vertx . kafka . client . common . topic partition topic partition , handler < async result < long > > handler ) { delegate . end offset ( topic partition , handler ) ; }
public void close ( ) { delegate . close ( ) ; }
public single < list < io . vertx . kafka . client . common . partition info > > rx partition for ( string topic ) { return async result single . to single ( handler - > { partition for ( topic , handler ) ; } ) ; }
public void end offset ( io . vertx . kafka . client . common . topic partition topic partition , handler < async result < long > > handler ) { delegate . end offset ( topic partition , handler ) ; }
public io . vertx . reactivex . mqtt . mqtt client unsubscribe ( string topic ) { delegate . unsubscribe ( topic ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt client subscribe ( string topic , int qos ) { delegate . subscribe ( topic , qos ) ; return this ; }
public object get handler ( ) { return this . handler ; }
public io . vertx . reactivex . mqtt . mqtt endpoint publish completion handler ( handler < integer > handler ) { delegate . publish completion handler ( handler ) ; return this ; }
public io . vertx . reactivex . mqtt . mqtt client subscribe ( string topic , int qos ) { delegate . subscribe ( topic , qos ) ; return this ; }
public static io . vertx . reactivex . mqtt . mqtt server create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . mqtt . mqtt server ret = io . vertx . reactivex . mqtt . mqtt server . new instance ( ( io . vertx . mqtt . mqtt server ) io . vertx . mqtt . mqtt server . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . mqtt . mqtt server listen ( ) { delegate . listen ( ) ; return this ; }
public static io . vertx . reactivex . mqtt . mqtt server create ( io . vertx . reactivex . core . vertx vertx ) { io . vertx . reactivex . mqtt . mqtt server ret = io . vertx . reactivex . mqtt . mqtt server . new instance ( ( io . vertx . mqtt . mqtt server ) io . vertx . mqtt . mqtt server . create ( vertx . get delegate ( ) ) ) ; return ret ; }
public io . vertx . reactivex . pgclient . pubsub . pg channel channel ( string name ) { io . vertx . reactivex . pgclient . pubsub . pg channel ret = io . vertx . reactivex . pgclient . pubsub . pg channel . new instance ( ( io . vertx . pgclient . pubsub . pg channel ) delegate . channel ( name ) ) ; return ret ; }
public io . vertx . reactivex . pgclient . pg connection cancel request ( handler < async result < void > > handler ) { io . vertx . reactivex . pgclient . pg connection ret = io . vertx . reactivex . pgclient . pg connection . new instance ( ( io . vertx . pgclient . pg connection ) delegate . cancel request ( handler ) ) ; return ret ; }
public boolean remove ( string key ) { boolean ret = delegate . remove ( key ) ; return ret ; }
public static void request ( subscription s , int prefetch ) { s . request ( prefetch < 0 ? long . max_value : prefetch ) ; }
public io . vertx . reactivex . ext . consul . consul client delete value ( string key , handler < async result < void > > result handler ) { delegate . delete value ( key , result handler ) ; return this ; }
public synchronize boolean be connect ( ) { return connect ; }
public io . vertx . reactivex . redis . client . redis a p i geodist ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . geodist ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i hvals ( string arg0 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . hvals ( arg0 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i bitfield ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . bitfield ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i ltrim ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . ltrim ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i ltrim ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . ltrim ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i bitfield ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . bitfield ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i dump ( string arg0 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . dump ( arg0 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i getrange ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . getrange ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i bitfield ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . bitfield ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i bitfield ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . bitfield ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i ltrim ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . ltrim ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i dump ( string arg0 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . dump ( arg0 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i bitfield ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . bitfield ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i bitfield ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . bitfield ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i bitfield ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . bitfield ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i ltrim ( string arg0 , string arg1 , string arg2 , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . ltrim ( arg0 , arg1 , arg2 , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public io . vertx . reactivex . redis . client . redis a p i bitfield ( list < string > args , handler < async result < io . vertx . reactivex . redis . client . response > > handler ) { delegate . bitfield ( args , new handler < async result < io . vertx . redis . client . response > > ( ) { public void handle ( async result < io . vertx . redis . client . response > ar ) { if ( ar . succeed ( ) ) { handler . handle ( io . vertx . core . future . succeed future ( io . vertx . reactivex . redis . client . response . new instance ( ( io . vertx . redis . client . response ) ar . result ( ) ) ) ) ; } else { handler . handle ( io . vertx . core . future . failed future ( ar . cause ( ) ) ) ; } } } ) ; return this ; }
public void close ( ) { delegate . close ( ) ; }
public string get arg name ( ) { return default arg name ; }
public byte [ ] get byte ( ) { return byte ; }
public boolean be change ( ) { boolean ret = delegate . be change ( ) ; return ret ; }
public io . vertx . reactivex . redis . redis client command ( handler < async result < json array > > handler ) { delegate . command ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client command ( handler < async result < json array > > handler ) { delegate . command ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client role ( handler < async result < json array > > handler ) { delegate . role ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client command ( handler < async result < json array > > handler ) { delegate . command ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client command ( handler < async result < json array > > handler ) { delegate . command ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client persist ( string key , handler < async result < long > > handler ) { delegate . persist ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client command ( handler < async result < json array > > handler ) { delegate . command ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client exists ( string key , handler < async result < long > > handler ) { delegate . exists ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client command ( handler < async result < json array > > handler ) { delegate . command ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client exists ( string key , handler < async result < long > > handler ) { delegate . exists ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client subscribe ( string channel , handler < async result < json array > > handler ) { delegate . subscribe ( channel , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client exists ( string key , handler < async result < long > > handler ) { delegate . exists ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client command ( handler < async result < json array > > handler ) { delegate . command ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client exists ( string key , handler < async result < long > > handler ) { delegate . exists ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client srem ( string key , string member , handler < async result < long > > handler ) { delegate . srem ( key , member , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client exists ( string key , handler < async result < long > > handler ) { delegate . exists ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client exists ( string key , handler < async result < long > > handler ) { delegate . exists ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client exists ( string key , handler < async result < long > > handler ) { delegate . exists ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client command ( handler < async result < json array > > handler ) { delegate . command ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client exists ( string key , handler < async result < long > > handler ) { delegate . exists ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client sadd ( string key , string member , handler < async result < long > > handler ) { delegate . sadd ( key , member , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client exists ( string key , handler < async result < long > > handler ) { delegate . exists ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client publish ( string channel , string message , handler < async result < long > > handler ) { delegate . publish ( channel , message , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client sadd ( string key , string member , handler < async result < long > > handler ) { delegate . sadd ( key , member , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client exists ( string key , handler < async result < long > > handler ) { delegate . exists ( key , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client sadd ( string key , string member , handler < async result < long > > handler ) { delegate . sadd ( key , member , handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client command ( handler < async result < json array > > handler ) { delegate . command ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis client command ( handler < async result < json array > > handler ) { delegate . command ( handler ) ; return this ; }
public io . vertx . reactivex . redis . redis transaction multi ( handler < async result < string > > handler ) { delegate . multi ( handler ) ; return this ; }
public boolean match ( service reference < ? > reference ) { return matches0 ( ( reference ! = null ) ? service reference map . a map ( reference ) : collection . empty map ( ) ) ; }
public void update ( io . vertx . servicediscovery . record record , handler < async result < io . vertx . servicediscovery . record > > result handler ) { delegate . update ( record , result handler ) ; }
public void update ( io . vertx . servicediscovery . record record , handler < async result < io . vertx . servicediscovery . record > > result handler ) { delegate . update ( record , result handler ) ; }
public io . vertx . reactivex . ext . mongo . mongo client list index ( string collection , handler < async result < json array > > result handler ) { delegate . list index ( collection , result handler ) ; return this ; }
public io . vertx . reactivex . sqlclient . sql result < t > next ( ) { io . vertx . reactivex . sqlclient . sql result < t > ret = io . vertx . reactivex . sqlclient . sql result . new instance ( ( io . vertx . sqlclient . sql result ) delegate . next ( ) , __type arg_0 ) ; return ret ; }
public void close ( ) { delegate . close ( ) ; }
public io . vertx . reactivex . sqlclient . query < io . vertx . reactivex . sqlclient . row set < io . vertx . reactivex . sqlclient . row > > query ( string sql ) { io . vertx . reactivex . sqlclient . query < io . vertx . reactivex . sqlclient . row set < io . vertx . reactivex . sqlclient . row > > ret = io . vertx . reactivex . sqlclient . query . new instance ( ( io . vertx . sqlclient . query ) delegate . query ( sql ) , type_arg_0 ) ; return ret ; }
public void close ( ) { delegate . close ( ) ; }
public io . vertx . reactivex . sqlclient . query < io . vertx . reactivex . sqlclient . row set < io . vertx . reactivex . sqlclient . row > > query ( string sql ) { io . vertx . reactivex . sqlclient . query < io . vertx . reactivex . sqlclient . row set < io . vertx . reactivex . sqlclient . row > > ret = io . vertx . reactivex . sqlclient . query . new instance ( ( io . vertx . sqlclient . query ) delegate . query ( sql ) , type_arg_0 ) ; return ret ; }
public string get auth type ( ) { return this . auth type ; }
public string get url ( ) { return url ; }
public long get last modified ( ) { return last modify ; }
public int get min idle ( ) { final int max idle save = get max idle ( ) ; if ( this . min idle > max idle save ) { return max idle save ; } return min idle ; }
public int get max text message buffer size ( ) { return get policy ( ) . get max text message buffer size ( ) ; }
public int get max text message size ( ) { return max text message size ; }
public byte [ ] buffer ( ) { return this . buffer ; }
public data buffer get payload ( ) { return this . payload ; }
public void on error ( callable < v > callback ) { this . error callback = callback ; }
public static boolean be transmittable ( int status code ) { return ( status code == normal ) || ( status code == shutdown ) || ( status code == protocol ) || ( status code == bad_data ) || ( status code == bad_payload ) || ( status code == policy_violation ) || ( status code == message_too_large ) || ( status code == required_extension ) || ( status code == server_error ) || ( status code == service_restart ) || ( status code == try_again_later ) || ( status code == invalid_upstream_response ) ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public void set status code value ( @ nullable integer status code ) { if ( this . state . get ( ) ! = state . commit ) { this . status code = status code ; } }
public static boolean same language ( automaton a1 , automaton a2 ) { if ( a1 == a2 ) { return true ; } return subset of ( a2 , a1 ) & & subset of ( a1 , a2 ) ; }
public cherry pick command set progress monitor ( progress monitor monitor ) { if ( monitor == null ) { monitor = null progress monitor . instance ; } this . monitor = monitor ; return this ; }
public double next gaussian ( ) { if ( ! double . be na n ( cache normal deviate ) ) { double dev = cache normal deviate ; cache normal deviate = double . na n ; return dev ; } double v1 = 0 ; double v2 = 0 ; double s = 1 ; while ( s > =1 ) { v1 = 2 * next double ( ) - 1 ; v2 = 2 * next double ( ) - 1 ; s = v1 * v1 + v2 * v2 ; } if ( s ! = 0 ) { s = fast math . sqrt ( -2 * fast math . log ( s ) / s ) ; } cache normal deviate = v2 * s ; return v1 * s ; }
public int cardinality ( ) { return ( int ) bit util . pop_array ( bit , 0 , bit . length ) ; }
protect final element generate simple element ( final string name , final string value ) { final element element = new element ( name , get d c namespace ( ) ) ; element . add content ( value ) ; return element ; }
public boolean contains ( final object object ) { return map . contains key ( object ) ; }
public final o get o s ( ) { return o ; }
public boolean equal ( object other ) { return ( this == other || ( other instanceof bean component definition & & super . equal ( other ) ) ) ; }
public string to string ( ) { return to string ( `` `` ) ; }
public static boolean be valid utf8 ( byte string byte string ) { return byte string . be valid utf8 ( ) ; }
protect final boolean be lock owner thread ( ) { return manager . be lock owner ( ) ; }
public void unlock ( ) { thread owner = this . owner ; if ( owner == thread . current thread ( ) ) { if ( -- level == 0 ) this . owner = null ; } else { throw new illegal monitor state exception ( ) ; } }
public void set owner ( storage owner owner ) { this . owner = owner ; }
public inet address get address ( ) { return address ; }
public string get address ( ) { return this . address ; } // -- string get address ( )
public class < ? > get exception class ( ) { return this . exception class ; }
public string to string ( ) { return new string buffer ( ) . append ( `` [ entity ref : `` ) . append ( `` & `` ) . append ( name ) . append ( `` ; `` ) . append ( `` ] `` ) . to string ( ) ; }
public static < t > t be a ( class < t > clazz ) { report matcher ( new instance of ( clazz ) ) ; return null ; }
public boolean be boolean ( ) { return false ; }
public string find uri by prefix ( string prefix ) { / * this be quite simple : just need to locate the last mapping * for the prefix , if any : * / string [ ] strs = m ns string ; int phash = prefix . hash code ( ) ; for ( int ix = m scope end - 2 ; ix > = 0 ; ix -= 2 ) { string this p = strs [ ix ] ; if ( this p == prefix || ( this p . hash code ( ) == phash & & this p . equal ( prefix ) ) ) { return strs [ ix+1 ] ; } } return null ; }
public final boolean be struct start ( ) { return _is struct start ; }
public iterator get namespaces ( ) { if ( _namespaces ! = null ) return _namespaces . iterator ( ) ; return empty iterator . get instance ( ) ; }
public namespace get namespace ( ) { return namespace ; }
public struct validator new instance ( ) { return this ; }
public string get entity ( ) { return entity ; }
public string get prefix string ( ) { return prefix ; }
public bytes reference get source internal ( ) { return get result . internal source ref ( ) ; }
public string [ ] index ( ) { return index ; }
public void set namespace aware ( boolean namespace aware ) { this . namespace aware = namespace aware ; }
public object mapper config jaxb object mapper factory ( j a x b object mapper factory jaxb object mapper factory ) { return new object mapper config ( default object mapper , default object mapper type , gson object mapper factory , jackson1 object mapper factory , jackson2 object mapper factory , jaxb object mapper factory , johnzon object mapper factory , jsonb object mapper factory , true ) ; }
public xml path use ( j a x b object mapper factory factory ) { return new xml path ( this , get xml path config ( ) . jaxb object mapper factory ( factory ) ) ; }
public big fraction add ( final int i ) { return add ( big integer . value of ( i ) ) ; }
public boolean be true ( ) { return value == true ; }
public boolean be normalize ( ) { return be normalize ; }
public boolean acquire ( ) { return acquire ( 1 ) ; }
public static boolean be x m l whitespace ( char c ) { if ( c== ' ' || c=='\n ' || c=='\t ' || c=='\r ' ) { return true ; } return false ; }
public static boolean be whitespace ( int c ) { return c == ' ' || c == '\t ' || c == '\n ' || c == '\f ' || c == '\r ' ; }
public static boolean be valid ( string name ) { if ( name == null ) { throw new illegal argument exception ( `` name be miss `` ) ; } boolean slash = false ; for ( int i = 0 ; i < name . length ( ) ; i++ ) { char ch = name . char at ( i ) ; if ( ch < = ' ' || ch > = 127 || ch == ' ( ' || ch == ' ) ' || ch == ' < ' || ch == ' > ' || ch == ' @ ' || ch == ' , ' || ch == ' ; ' || ch == ' : ' || ch == '\\ ' || ch == ' `` ' || ch == ' [ ' || ch == ' ] ' || ch == ' ? ' || ch == '= ' ) { return false ; } else if ( ch == '/ ' ) { if ( slash || i == 0 || i + 1 == name . length ( ) ) { return false ; } slash = true ; } } return slash ; }
public void add ( string name ) { if ( _is finite ) _finite set . add ( name ) ; else _finite set . remove ( name ) ; }
public name set invert ( ) { return new instance ( ! _is finite , _finite set ) ; }
public void set type ( int type ) { this . type = type ; }
public int get ( final int index , final byte [ ] a ) { return get ( index , a , 0 , a . length ) ; }
public void set header ( string header ) { this . header = header ; }
public iterator get all header ( ) { return header . iterator ( ) ; }
public throwable init cause ( throwable cause ) { this . cause = cause ; return this ; }
public boolean be no prefix ( ) { return no prefix ; }
public boolean be no prefix ( ) { return no prefix ; }
public static byte [ ] encode data with length ( final base64 u r l data ) { byte [ ] bytes = data ! = null ? data . decode ( ) : null ; return encode data with length ( byte ) ; }
public output < long > decode value ( ) { return decode value ; }
protect object process parse value ( object value , format formatter ) { big decimal decimal = null ; if ( value instanceof long ) { decimal = big decimal . value of ( ( ( long ) value ) . long value ( ) ) ; } else { decimal = new big decimal ( value . to string ( ) ) ; } int scale = determine scale ( ( number format ) formatter ) ; if ( scale > = 0 ) { decimal = decimal . set scale ( scale , big decimal . round_down ) ; } return decimal ; }
public final q name get name ( ) { return name ; }
public boolean be empty ( ) { return name . be empty ( ) ; }
public string get name ( ) { if ( ( name == null ) & & ( qname ! = null ) ) { return qname . get local part ( ) ; } return name ; }
protect void set base u r i ( parse u r i base u r i ) { this . base u r i = base u r i ; }
public int get ( duration field type type ) { if ( type == get field type ( ) ) { return get value ( ) ; } return 0 ; }
public property year ( ) { return new property ( this , get chronology ( ) . year ( ) ) ; }
public set < type > get type ( ) { return type ; }
public static xml option mask null ( xml option o ) { return ( o == null ) ? empty_options : o ; }
public optional < configuration option > get ( configuration option option ) { return default option . stream ( ) . filter ( o- > o . equal ( option ) ) . find first ( ) ; }
public list iterator list iterator ( ) { if ( fast ) { return new list iter ( 0 ) ; } else { return list . list iterator ( ) ; } }
public void set owner document ( document doc ) { document = doc ; }
public void set pathname ( string pathname ) { this . pathname = pathname ; this . pathname old = pathname + `` . old `` ; this . pathname new = pathname + `` . new `` ; }
public void set connection ( string connection ) { this . connection = connection ; } // -- void set connection ( string )
public boolean be normalize ( ) { return be normalize ; }
public static builder source ( source s ) { return new transformation builder ( s ) ; }
public string get file name ( ) { return file name ; }
public source get source ( ) { return source ; }
public x path context get x path context object ( ) { return context object ; }
public static string wrap ( string input , formatter formatter ) throw formatter exception { return string wrapper . wrap ( formatter . max_line_length , input , formatter ) ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public boolean be string comparison case insensitive ( ) { return true ; }
public static element selector and ( final element selector . . . selector ) { if ( selector == null ) { throw new illegal argument exception ( selectors_must_not_be_null ) ; } final collection < element selector > s = array . a list ( selector ) ; if ( any ( s , new be null predicate ( ) ) ) { throw new illegal argument exception ( `` selector must not contain null value `` ) ; } return new element selector ( ) { @ override public boolean can be compare ( element control element , element test element ) { return all ( s , new can be compare predicate ( control element , test element ) ) ; } } ; }
public static element selector not ( final element selector e ) { if ( e == null ) { throw new illegal argument exception ( `` es must not be null `` ) ; } return new element selector ( ) { @ override public boolean can be compare ( element control element , element test element ) { return ! e . can be compare ( control element , test element ) ; } } ; }
public static element selector and ( final element selector . . . selector ) { if ( selector == null ) { throw new illegal argument exception ( selectors_must_not_be_null ) ; } final collection < element selector > s = array . a list ( selector ) ; if ( any ( s , new be null predicate ( ) ) ) { throw new illegal argument exception ( `` selector must not contain null value `` ) ; } return new element selector ( ) { @ override public boolean can be compare ( element control element , element test element ) { return all ( s , new can be compare predicate ( control element , test element ) ) ; } } ; }
public sort set selector . type get selector ( ) { return selector ; }
public resource chain registration add transformer ( resource transformer transformer ) { assert . not null ( transformer , `` the provided resource transformer should not be null `` ) ; this . transformer . add ( transformer ) ; if ( transformer instanceof cs link resource transformer ) { this . have css link transformer = true ; } return this ; }
public void push input source ( x m l input source input source ) { f document scanner . push input source ( input source ) ; } // push input source ( x m l input source )
public static < e > list < e > get list ( object list ) { return get list ( list , false ) ; }
public static < t > t find ( final iterable < t > collection , final predicate < ? super t > predicate ) { return predicate ! = null ? iterable utils . find ( collection , predicate ) : null ; }
public stripper get another ( ) { stripper clone = new stripper ( stripper mode ) ; clone . set pipeline configuration ( get pipeline configuration ( ) ) ; clone . strip all = strip all ; clone . preserve all = preserve all ; return clone ; }
public string to string ( ) { return to string ( `` `` ) ; }
public xml path use ( j a x b object mapper factory factory ) { return new xml path ( this , get xml path config ( ) . jaxb object mapper factory ( factory ) ) ; }
public static boolean have manager ( i document [ ] document ) { for ( i document document : document ) { if ( have manager ( document ) ) return true ; } return false ; }
public void set property name ( string property name ) { this . property name = property name ; }
public void set available ( long available ) { long old available = this . available ; if ( available > system . current time millis ( ) ) this . available = available ; else this . available = 0l ; support . fire property change ( `` available `` , long . value of ( old available ) , long . value of ( this . available ) ) ; }
public static synchronize void set default ( default default ) { default = default ; }
public string get new node name ( ) { return new node name ; }
public string get path ( ) { return path ; }
public string get name ( ) { return property name ; }
public string name ( ) { return name ; }
public static builder builder ( ) { return new builder ( ) ; }
public void set driver name ( string driver name ) { this . driver name = driver name ; }
public deserializer bind get deserializer binding ( ) { return deserializer binding ; }
public binary node binary node ( byte [ ] data ) { return binary node . value of ( data ) ; }
public void set strict parsing ( boolean be strict ) { this . be strict parse = be strict ; }
public void set creator tool ( string creator ) { set text property ( prefix + `` : creator tool `` , creator ) ; }
public database structure get database structure ( ) { return database structure ; }
public @ not null i serializer get serializer ( ) { return serializer ; }
public void set order ( int order ) { this . order = order ; }
public class < ? > get value class ( ) { return object . class ; }
public @ not null i serializer get serializer ( ) { return serializer ; }
public i deserializer provider get deserializer provider ( ) { return deserializer provider ; }
public string to string ( comparison formatter formatter ) { return formatter . get description ( this ) ; }
public static annotation [ ] get filtering annotation ( final annotation [ ] annotation ) { if ( annotation == null || annotation . length == 0 ) { return filter helper . empty_annotations ; } final list < annotation > filtering annotation = new array list < > ( annotation . length ) ; for ( final annotation annotation : annotation ) { final class < ? extend annotation > annotation type = annotation . annotation type ( ) ; for ( final annotation meta annotation : annotation type . get declared annotation ( ) ) { if ( meta annotation instanceof entity filter ) { filter annotation . add ( annotation ) ; } } } return filter annotation . to array ( new annotation [ filter annotation . size ( ) ] ) ; }
public io . vertx . reactivex . ext . web . client . http request < t > set query param ( string param name , string param value ) { delegate . set query param ( param name , param value ) ; return this ; }
public static optional < class > resolve interface type argument ( class type , class interface type ) { type [ ] generic interface = type . get generic interface ( ) ; for ( type generic interface : generic interface ) { if ( generic interface instanceof parameterized type ) { parameterized type pt = ( parameterized type ) generic interface ; if ( pt . get raw type ( ) == interface type ) { return resolve single type argument ( generic interface ) ; } } } class super class = type . get superclass ( ) ; if ( super class ! = null & & super class ! = object . class ) { return resolve interface type argument ( super class , interface type ) ; } return optional . empty ( ) ; }
public boolean be wrapper for ( class < ? > iface ) throw s q l exception { throw unsupported ( `` be wrapper for `` ) ; }
public static final rev filter before ( date t ) { return before ( t . get time ( ) ) ; }
public static type [ ] get type argument ( final type type ) { if ( ! ( type instanceof parameterized type ) ) { return null ; } return ( ( parameterized type ) type ) . get actual type argument ( ) ; }
protect string format with formatter ( t value , date time formatter formatter ) { return formatter . format ( to temporal accessor ( value ) ) ; }
public string to json ( t object , jsonb date formatter formatter , jsonb context jsonb context ) { if ( jsonb date format . time_in_millis . equal ( formatter . get format ( ) ) ) { return string . value of ( to instant ( object ) . to epoch milli ( ) ) ; } else if ( formatter . get date time formatter ( ) ! = null ) { return format with formatter ( object , formatter . get date time formatter ( ) ) ; } else { date time formatter config date time formatter = jsonb context . get config property ( ) . get config date formatter ( ) . get date time formatter ( ) ; if ( config date time formatter ! = null ) { return format with formatter ( object , config date time formatter ) ; } } if ( jsonb context . get config property ( ) . be strict i json ( ) ) { return format strict i json ( object ) ; } return format default ( object , jsonb context . get config property ( ) . get locale ( formatter . get locale ( ) ) ) ; }
public type [ ] get generic parameter type ( ) { return be . get generic parameter type ( ) ; }
public deserializer bind get deserializer binding ( ) { return deserializer binding ; }
public document parser ( parser parser ) { this . parser = parser ; return this ; }
public field set set field ( field field ) { return set field ( new field description . for loaded field ( field ) ) ; }
public state get state ( ) { return state . get ( ) . get state ( ) ; }
public uuid get alt version ( ) { return alt version ; }
public value reduce ( ) throw x path exception { return new sequence extent ( iterate ( ) ) . reduce ( ) ; }
public boolean equal ( object other ) { return ( this == other || ( other instanceof bean component definition & & super . equal ( other ) ) ) ; }
protect int validate range ( int start index , int end index ) { if ( start index < 0 ) { throw new string index out of bound exception ( start index ) ; } if ( end index > size ) { end index = size ; } if ( start index > end index ) { throw new string index out of bound exception ( `` end < start `` ) ; } return end index ; }
public void set print grammar ( boolean print grammar ) { this . print grammar = print grammar ; }
public string get location ( ) { return location ; }
public boolean add token ( token < ? extend token identifier > token ) { return ( token ! = null ) ? add token ( token . get service ( ) , token ) : false ; }
public string to string ( ) { return to string ( `` `` ) ; }
protect s state ( ) { return state ; }
public list < format error > get error ( ) { return error ; }
public boolean be verbose ( ) { return verbose ; }
public list < grammar > get indirect delegate ( grammar g ) { list < grammar > direct = get direct delegate ( g ) ; list < grammar > delegate = get delegate ( g ) ; if ( direct ! =null ) { delegate . remove all ( direct ) ; } return delegate ; }
public x path exception make static ( ) { set be static error ( true ) ; return this ; }
public proto syntax get syntax ( ) { return syntax ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public void set buffer debug ( boolean debug ) { this . buffer . set debug ( debug ) ; }
protect void validate index ( int index ) { if ( index < 0 || index > size ) { throw new string index out of bound exception ( index ) ; } }
public token stream normalize ( token stream input ) { return input ; }
public void add child ( unknown element child ) { if ( child == null ) { child = new array list ( ) ; } child . add ( child ) ; }
public void set token type ( string token type ) { this . token type = token type ; }
public pattern get pattern ( ) { return pattern ; }
public list < node > get node ( ) { return node ; }
public string get message ( ) { return message ; }
public secret key get secret key ( ) { return ( ( octet sequence key ) get j w k set ( ) . get key ( ) . get ( 0 ) ) . to secret key ( ) ; }
public int get max length ( ) { return max length ; }
public string get password ( ) { return password ; }
public void set valid end ( kerberos time valid end ) { this . valid end = valid end ; }
public void set name ( string name ) { this . name = name ; }
public kerberos time get valid end ( ) { return valid end ; }
public deployment option set instance ( int instance ) { this . instance = instance ; return this ; }
public void init ( database database ) throw auth config exception { if ( skip default initialization ) { return ; } if ( initialize ) { return ; } synchronize ( this ) { if ( initialize ) { return ; } trace trace = database . get trace ( trace . database ) ; url h2 authenticator configuration url = null ; try { string config file = sys property . auth_config_file ; if ( config file ! = null ) { if ( trace . be debug enable ( ) ) { trace . debug ( `` default authenticator . config : configuration read from system property `` + `` h2auth . configurationfile= { 0 } `` , config file ) ; } h2 authenticator configuration url = new url ( config file ) ; } if ( h2 authenticator configuration url == null ) { if ( trace . be debug enable ( ) ) { trace . debug ( `` default authenticator . config : default configuration `` ) ; } default configuration ( ) ; } else { configure from url ( h2 authenticator configuration url ) ; } } catch ( exception e ) { trace . error ( e , `` default authenticator . config : an error occur during configuration from { 0 } `` , h2 authenticator configuration url ) ; throw new auth config exception ( `` fail to configure authentication from `` + h2 authenticator configuration url , e ) ; } initialize = true ; } }
public int compute length ( ) { enc kdc rep part length = enc kdc rep part . compute length ( ) ; return 1 + tlv . get nb byte ( enc kdc rep part length ) + enc kdc rep part length ; }
public e get entry ( ) { return entry ; }
public list < format error > get error ( ) { return error ; }
public void set index ( int index ) { this . index = index ; }
public string get realm ( ) { return get parameter ( `` realm `` ) ; }
public boolean be true ( ) { return value == true ; }
public string to string ( ) { string builder result = new string builder ( ) ; if ( be flag set ( ticket flag . reserve ) ) { result . append ( `` reserve ( 0 ) `` ) ; } if ( be flag set ( ticket flag . forwardable ) ) { result . append ( `` forwardable ( 1 ) `` ) ; } if ( be flag set ( ticket flag . forward ) ) { result . append ( `` forward ( 2 ) `` ) ; } if ( be flag set ( ticket flag . proxiable ) ) { result . append ( `` proxiable ( 3 ) `` ) ; } if ( be flag set ( ticket flag . proxy ) ) { result . append ( `` proxy ( 4 ) `` ) ; } if ( be flag set ( ticket flag . may_postdate ) ) { result . append ( `` may_postdate ( 5 ) `` ) ; } if ( be flag set ( ticket flag . postdate ) ) { result . append ( `` postdate ( 6 ) `` ) ; } if ( be flag set ( ticket flag . invalid ) ) { result . append ( `` invalid ( 7 ) `` ) ; } if ( be flag set ( ticket flag . renewable ) ) { result . append ( `` renewable ( 8 ) `` ) ; } if ( be flag set ( ticket flag . initial ) ) { result . append ( `` initial ( 9 ) `` ) ; } if ( be flag set ( ticket flag . pre_authent ) ) { result . append ( `` pre_authent ( 10 ) `` ) ; } if ( be flag set ( ticket flag . hw_authent ) ) { result . append ( `` hw_authent ( 11 ) `` ) ; } if ( be flag set ( ticket flag . transited_policy_checked ) ) { result . append ( `` transited_policy_checked ( 12 ) `` ) ; } if ( be flag set ( ticket flag . ok_as_delegate ) ) { result . append ( `` ok_as_delegate ( 13 ) `` ) ; } return result . to string ( ) . trim ( ) ; }
public void add entry ( last req entry last req entry ) { last reqs . add ( last req entry ) ; }
public void create new l r ( ) { current l r = new last req entry ( ) ; last reqs . add ( current l r ) ; }
public int compare to ( m d5 hash that ) { return writable comparator . compare bytes ( this . digest , 0 , md5_len , that . digest , 0 , md5_len ) ; }
public string to string ( ) { string builder result = new string builder ( ) ; if ( be flag set ( ticket flag . reserve ) ) { result . append ( `` reserve ( 0 ) `` ) ; } if ( be flag set ( ticket flag . forwardable ) ) { result . append ( `` forwardable ( 1 ) `` ) ; } if ( be flag set ( ticket flag . forward ) ) { result . append ( `` forward ( 2 ) `` ) ; } if ( be flag set ( ticket flag . proxiable ) ) { result . append ( `` proxiable ( 3 ) `` ) ; } if ( be flag set ( ticket flag . proxy ) ) { result . append ( `` proxy ( 4 ) `` ) ; } if ( be flag set ( ticket flag . may_postdate ) ) { result . append ( `` may_postdate ( 5 ) `` ) ; } if ( be flag set ( ticket flag . postdate ) ) { result . append ( `` postdate ( 6 ) `` ) ; } if ( be flag set ( ticket flag . invalid ) ) { result . append ( `` invalid ( 7 ) `` ) ; } if ( be flag set ( ticket flag . renewable ) ) { result . append ( `` renewable ( 8 ) `` ) ; } if ( be flag set ( ticket flag . initial ) ) { result . append ( `` initial ( 9 ) `` ) ; } if ( be flag set ( ticket flag . pre_authent ) ) { result . append ( `` pre_authent ( 10 ) `` ) ; } if ( be flag set ( ticket flag . hw_authent ) ) { result . append ( `` hw_authent ( 11 ) `` ) ; } if ( be flag set ( ticket flag . transited_policy_checked ) ) { result . append ( `` transited_policy_checked ( 12 ) `` ) ; } if ( be flag set ( ticket flag . ok_as_delegate ) ) { result . append ( `` ok_as_delegate ( 13 ) `` ) ; } return result . to string ( ) . trim ( ) ; }
public boolean be initial ( ) { return be flag set ( ticket flag . initial ) ; }
public static date parse date ( string date value ) throw date parse exception { return parse date ( date value , null ) ; }
public option get option ( ) { return option ; }
public int compute length ( ) { enc kdc rep part length = enc kdc rep part . compute length ( ) ; return 1 + tlv . get nb byte ( enc kdc rep part length ) + enc kdc rep part length ; }
public void set enc kdc rep part ( enc kdc rep part enc kdc rep part ) { this . enc kdc rep part = enc kdc rep part ; }
public final byte [ ] copy of use byte ( ) { byte [ ] copy = new byte [ po ] ; system . arraycopy ( buf , 0 , copy , 0 , po ) ; return copy ; }
public byte buffer get byte buffer ( ) throw i o exception { byte buf byte buf = file upload . get byte buf ( ) ; if ( byte buf == null ) { throw new i o exception ( `` the byte buffer have already be release `` ) ; } try { return byte buf . nio buffer ( ) ; } finally { if ( control release ) { byte buf . release ( ) ; } } }
public byte [ ] get data ( ) { byte [ ] copy = new byte [ byte . length + 1 ] ; system . arraycopy ( byte , 0 , copy , 1 , byte . length ) ; copy [ 0 ] = ( byte ) nb unused bit ; return copy ; }
public long get char index ( ) { return char index ; }
public float get b ( ) { return b ; }
public static boolean be valid name for component ( string component ) { if ( component . equal ( `` . `` ) || component . equal ( `` . . `` ) || component . index of ( `` : `` ) > = 0 || component . index of ( `` / `` ) > = 0 ) { return false ; } return ! be reserve path component ( component ) ; }
public static int to int ( byte buffer bytes ) { return byte . get int ( byte . position ( ) ) ; }
public static char byte to char ( byte [ ] bytes ) { return bytes to char ( byte , 0 ) ; }
public source get source ( ) { return source ; }
public string get property ( ) { return property ; }
public static void legal property key value array ( final object . . . property key value ) throw illegal argument exception { if ( property key value . length % 2 ! = 0 ) throw element . exception . provide key value must be a multiple of two ( ) ; for ( int i = 0 ; i < property key value . length ; i = i + 2 ) { if ( ! ( property key value [ i ] instanceof string ) & & ! ( property key value [ i ] instanceof t ) ) throw element . exception . provide key value must have a legal key on even index ( ) ; if ( null == property key value [ i + 1 ] ) { throw property . exception . property value can not be null ( ) ; } } }
public configuration get configuration ( ) { return config ; }
public boolean get boolean value ( ) { return false ; }
public change get change ( ) { return f change ; }
public property create property ( ) { final property prop = new property ( ) ; property list . add element ( prop ) ; return prop ; }
public string get id ( ) { return this . id ; } // -- string get id ( )
public void set site ( site site ) { this . site = site ; } // -- void set site ( site )
public void set resource ( resource resource ) { this . resource = resource ; }
public void set file ( file file ) { this . file = file ; }
public void set property ( java . util . property property ) { this . property = property ; } // -- void set property ( java . util . property )
public void set encoding ( string encode encode ) { this . encode = encoding ; }
public string get language ( ) { return language ; }
public static void check not null ( object o ) throw null argument exception { if ( o == null ) { throw new null argument exception ( ) ; } }
public string get configuration ( ) { return this . configuration ; } // -- string get configuration ( )
public string get event ( ) { return event ; }
public void set class loader ( class loader loader ) { class loader = loader ; }
public cancellable activate watch async ( activate watch request request , request option option , action listener < activate watch response > listener ) { return rest high level client . perform request async and parse entity ( request , watcher request converter : : activate watch , option , activate watch response : : from x content , listener , singleton ( 404 ) ) ; }
public final throwable get throwable ( ) { return throwable ; }
public double pdf ( double x ) { double diff = x - mean ; return normalizer * math . exp ( - ( diff * diff ) / ( 2 . 0 * variance ) ) ; }
public void set image ( final image image ) { this . image = image ; }
public strategy get strategy ( ) { return strategy ; }
public strategy get strategy ( ) { return strategy ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public string to turtle ( ) { string val = this . value ; val = val . replace ( `` \ `` `` , `` \\\ `` `` ) ; val = `` \ `` `` +val+ `` \ `` `` ; if ( data type == null ) { if ( language ! = null ) { val = val+ `` @ `` +language ; } } else { val = val+ `` ^^ < `` + data type . get xml schema u r i string ( ) + `` > `` ; } return val ; }
public class get enum class ( ) { return get class ( ) ; }
public artifact descriptor result set dependency ( list < dependency > dependency ) { if ( dependency == null ) { this . dependency = collection . empty list ( ) ; } else { this . dependency = dependency ; } return this ; }
public string to string ( ) { return new string buffer ( ) . append ( `` [ entity ref : `` ) . append ( `` & `` ) . append ( name ) . append ( `` ; `` ) . append ( `` ] `` ) . to string ( ) ; }
public remote repository get repository ( ) { return repository ; }
public synchronize local variable table copy from pack state ( ) { if ( ! be in packed state ) throw new illegal state exception ( `` no in packed state `` ) ; try { return new local variable table ( name index , length , new data input stream ( new byte array input stream ( data ) ) , get constant pool ( ) ) ; } catch ( i o exception e ) { throw new runtime exception ( `` fail to unpack clone `` , e ) ; } }
public int get position ( ) { return this . position ; }
public int get position ( ) { return position ; }
public void add proc ( instruction sequence child ) { this . instruction . add ( child ) ; }
public boolean reference interface ( ) { java class jc = repository . lookup class ( classname ) ; if ( jc == null ) { return false ; } else { return ! jc . be class ( ) ; } }
public boolean reference class ( ) { java class jc = repository . lookup class ( classname ) ; if ( jc == null ) { return false ; } else { return jc . be class ( ) ; } }
public pattern parameter configurator set container kind ( container kind container kind ) { current parameter . set container kind ( container kind ) ; return this ; }
public boolean handle message ( i message message ) throw abort exception { if ( ( null ! = message ) & & ! be ignore ( message . get kind ( ) ) ) { string result = render ( message ) ; if ( null ! = result ) { writer . println ( result ) ; writer . flush ( ) ; if ( abort on failure & & ( message . be failed ( ) || message . be abort ( ) ) ) { throw new abort exception ( message ) ; } } } return true ; }
public i message handler get message handler ( ) { return message handler ; }
public i message handler get message handler ( ) { return message handler ; }
public i message handler get message handler ( ) { return message handler ; }
public static boolean handle all except ( i message handler sink , i message holder source , i message . kind kind , boolean or great , boolean fast fail ) { lang util . throw iax if null ( sink , `` sink `` ) ; lang util . throw iax if null ( source , `` source `` ) ; if ( null == kind ) { return true ; } i message [ ] message = get message except ( source , kind , or great ) ; return handle all ( sink , message , fast fail ) ; }
public static boolean handle all ( i message handler sink , i message holder source , i message . kind kind , boolean or great , boolean fast fail ) { lang util . throw iax if null ( sink , `` sink `` ) ; lang util . throw iax if null ( source , `` source `` ) ; return handle all ( sink , source . get message ( kind , or great ) , fast fail ) ; }
public static boolean abort ( i message handler handler , string message ) { return ( ( null ! = handler ) & & handler . handle message ( abort ( message ) ) ) ; }
public void set declaration ( body declaration declaration ) { f declaration= declaration ; }
public static string error_parameter_type_processing ( object arg0 ) { return localizer . localize ( localizable e r r o r_ p a r a m e t e r_ t y p e_ p r o c e s s i n g ( arg0 ) ) ; }
public void set error ( file error ) { this . error = error ; incompatible with spawn = true ; }
public void reset buffer ( ) { reset buffer ( false ) ; }
public static char value a char ( string key , char default val ) { string val = value for ( key ) ; if ( val == null ) { return default val ; } if ( val . length ( ) > 1 ) { x r log . exception ( `` property ' `` + key + `` ' be request a a character . the value of ' `` + val + `` ' be too long to be a char . return only the first character . `` ) ; } return val . char at ( 0 ) ; }
protect void trim stack frame ( list stack ) { for ( int size=stacks . size ( ) , i=size-1 ; i > 0 ; i -- ) { string [ ] curr = ( string [ ] ) stack . get ( i ) ; string [ ] next = ( string [ ] ) stack . get ( i-1 ) ; list curr list = new array list ( arrays . a list ( curr ) ) ; list next list = new array list ( arrays . a list ( next ) ) ; exception utils . remove common frame ( curr list , next list ) ; int trim = curr . length - curr list . size ( ) ; if ( trim > 0 ) { curr list . add ( `` \t . . . `` +trimmed+ `` more `` ) ; stack . set ( i , curr list . to array ( new string [ curr list . size ( ) ] ) ) ; } } }
protect resource get resource by path ( string path ) { if ( path ! = null & & path . start with ( `` / `` ) ) { path = path . substring ( 1 ) ; } return new file system resource ( path ) ; }
public static int get bit ( long bit , int i ) { long mask = ( 1l < < i ) ; return ( bit & mask ) ! = 0 ? 1 : 0 ; }
public collection value ( ) { collection v = value ; return ( vs ! = null ) ? v : ( value = new value ( ) ) ; }
public boolean be empty ( ) { return map . be empty ( ) ; }
public boolean get test set ( ) { return set ; }
public static object add array ( object list , object [ ] array ) { for ( int i = 0 ; array ! = null & & i < array . length ; i++ ) { list = lazy list . add ( list , array [ i ] ) ; } return list ; }
public synchronize boolean be s s l ( ) { return use s s l ; }
public boolean be ignore error ( ) { return ignore error ; }
public file get dir ( ) { return this . dir ; }
public file get dir ( ) { return this . dir ; }
public static boolean be parent class loader ( final class loader parent , class loader child ) { while ( child ! = null ) { if ( child == parent ) { return true ; } child = child . get parent ( ) ; } return false ; }
public static string repeat ( char ch , int count ) { string builder buffer = new string builder ( ) ; for ( int i = 0 ; i < count ; ++i ) buffer . append ( ch ) ; return buffer . to string ( ) ; }
public static boolean handle all ( i message handler sink , i message holder source , i message . kind kind , boolean or great , boolean fast fail ) { lang util . throw iax if null ( sink , `` sink `` ) ; lang util . throw iax if null ( source , `` source `` ) ; return handle all ( sink , source . get message ( kind , or great ) , fast fail ) ; }
public boolean be explicitly convertible ( class formal , class actual , boolean possible var arg ) { / * * for consistency , we also have to check standard implicit convertibility * since it may not have be check before by the call code * / if ( formal == actual || introspection utils . be method invocation convertible ( formal , actual , possible var arg ) || get need converter ( formal , actual ) ! = null ) { return true ; } / * check var arg * / if ( possible var arg & & formal . be array ( ) ) { if ( actual . be array ( ) ) { actual = actual . get component type ( ) ; } return be explicitly convertible ( formal . get component type ( ) , actual , false ) ; } return false ; }
public void set response body advice ( @ nullable list < response body advice < ? > > response body advice ) { this . response body advice . clear ( ) ; if ( response body advice ! = null ) { this . response body advice . add all ( response body advice ) ; } }
public node get node ( ) { return node ; }
public parameter [ ] get params ( ) { parameter [ ] params = new parameter [ parameter . size ( ) ] ; parameter . copy into ( params ) ; return params ; }
public type bind resolve at type ( block scope scope , type bind u ) { if ( this . resolve type == null ) { this . resolve type = this . local . binding . type ; } return this . resolve type ; }
public output < long > rt nested split ( ) { return rt nest split ; }
public static optional < class > resolve interface type argument ( class type , class interface type ) { type [ ] generic interface = type . get generic interface ( ) ; for ( type generic interface : generic interface ) { if ( generic interface instanceof parameterized type ) { parameterized type pt = ( parameterized type ) generic interface ; if ( pt . get raw type ( ) == interface type ) { return resolve single type argument ( generic interface ) ; } } } class super class = type . get superclass ( ) ; if ( super class ! = null & & super class ! = object . class ) { return resolve interface type argument ( super class , interface type ) ; } return optional . empty ( ) ; }
public type annotation walker to method return ( ) { return to target ( annotation target type constant . method_return ) ; }
public member get member ( ) { return this . executable ; }
public byte [ ] get signature ( ) { return signature ; }
public void parse ( string . . . args ) { string builder sb = new string builder ( `` parse \ `` `` ) ; sb . append ( join ( args ) . append ( `` \ `` \n with : `` ) . append ( join ( m_objects . to array ( ) ) ) ) ; p ( sb . to string ( ) ) ; create description ( ) ; initialize default value ( ) ; parse value ( expand args ( args ) ) ; validate option ( ) ; }
public dependency resolver get resolver ( ) { return resolver ; }
public object get handler ( ) { return this . handler ; }
public void set cache ( boolean cache ) { this . cache = cache ; }
public string get context name ( ) { return context name ; }
public void set type pattern ( string type pattern ) { assert . not null ( type pattern ) ; this . type pattern = type pattern ; this . aspect j type pattern matcher = pointcut parser . get pointcut parser support all primitive and use context classloader for resolution ( ) . parse type pattern ( replace boolean operator ( type pattern ) ) ; }
public static boolean info ( i message handler handler , string message ) { return ( ( null ! = handler ) & & handler . handle message ( info ( message ) ) ) ; }
public int get threshold ( ) { return threshold ; }
public void remove extra field ( zip short type ) { if ( extra field == null ) { throw new java . util . no such element exception ( ) ; } if ( extra field . remove ( type ) == null ) { throw new java . util . no such element exception ( ) ; } set extra ( ) ; }
public final void dump ( data output stream file ) throw i o exception { super . dump ( file ) ; if ( be in packed state ) { file . write ( data ) ; } else { file . write short ( local variable table length ) ; for ( int i = 0 ; i < local variable table length ; i++ ) local variable table [ i ] . dump ( file ) ; } }
protect string get declare type name ( string qualify name ) { return qualify name . substring ( 0 , have inner type ( qualified name ) ) ; }
public string get type descriptor ( ) { if ( type descriptor == null ) { string buffer buf = new string buffer ( name . length ( ) + parameter . length * 10 ) ; buf . append ( return type . get name ( ) ) ; buf . append ( ' ' ) ; buf . append ( name ) ; buf . append ( ' ( ' ) ; for ( int i = 0 ; i < parameter . length ; i++ ) { if ( i > 0 ) { buf . append ( `` , `` ) ; } parameter param = parameter [ i ] ; buf . append ( param . get type ( ) . get name ( ) ) ; } buf . append ( ' ) ' ) ; type descriptor = buf . to string ( ) ; } return type descriptor ; }
public static void clear ( ) { constant string lookup . clear ( ) ; }
public mapping get mapping ( ) { return mapping ; }
public int length ( ) { return get size ( ) ; }
public @ not null i serializer get serializer ( ) { return serializer ; }
public void set token boundary ( token start token , token stop token ) { if ( start token ! =null ) start index = start token . get token index ( ) ; if ( stop token ! =null ) stop index = stop token . get token index ( ) ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public void set rebuild ( boolean rebuild ) { this . always rebuild = rebuild ; }
public static byte [ ] copy all byte from ( byte buffer bb ) { if ( bb == null ) { return null ; } if ( bb . have array ( ) ) { return array . copy of range ( bb . array ( ) , bb . array offset ( ) , bb . array offset ( ) + bb . limit ( ) ) ; } byte buffer copy = bb . a read only buffer ( ) ; copy . rewind ( ) ; byte [ ] dst = new byte [ copy . remain ( ) ] ; copy . get ( dst ) ; return dst ; }
public select set lock mode ( lock mode lock mode ) { lock option . set lock mode ( lock mode ) ; return this ; }
public string get unique id ( ) { return unique id ; }
public statement set serial consistency level ( consistency level serial consistency ) { if ( ! serial consistency . be serial ( ) ) throw new illegal argument exception ( `` supply consistency level be not serial : `` + serial consistency ) ; this . serial consistency = serial consistency ; return this ; }
protect connection do create connection ( ) throw resource exception { connection factory connection factory = get target connection factory ( ) ; assert . state ( connection factory ! = null , `` no 'target connection factory ' set `` ) ; return connection factory . get connection ( ) ; }
public static void set default ( codec codec ) { default codec = codec ; }
public void close ( ) throw i o exception { internal in . close ( ) ; }
public file get file ( ) { return file ; }
public void remove node meta data ( object key ) { if ( key==null ) throw new groovy bug error ( `` try to remove meta data with null key `` +this+ `` . `` ) ; meta data map . remove ( key ) ; if ( meta data map . size ( ) ==0 ) meta data map=null ; }
public string get field name ( ) { return field name ; }
public boolean have ( string field name ) { return get ( field name ) ! = null ; }
public object get ( string field name ) { return get ( schema ( ) . get field ( field name ) ) ; }
public int get buffer size ( ) { return buffer size ; }
public final void process trail implicit action ( ) throw i o exception { while ( pos > = 1 ) { symbol top = stack [ pos - 1 ] ; if ( top . kind == symbol . kind . implicit_action & & ( ( symbol . implicit action ) top ) . be trail ) { po -- ; symbol handler . do action ( null , top ) ; } else { break ; } } }
public final void process implicit action ( ) throw i o exception { while ( pos > 1 ) { symbol top = stack [ pos - 1 ] ; if ( top . kind == symbol . kind . implicit_action ) { po -- ; symbol handler . do action ( null , top ) ; } else if ( top . kind ! = symbol . kind . terminal ) { po -- ; push production ( top ) ; } else { break ; } } }
public final void process trail implicit action ( ) throw i o exception { while ( pos > = 1 ) { symbol top = stack [ pos - 1 ] ; if ( top . kind == symbol . kind . implicit_action & & ( ( symbol . implicit action ) top ) . be trail ) { po -- ; symbol handler . do action ( null , top ) ; } else { break ; } } }
public update request doc ( index request doc ) { this . doc = doc ; return this ; }
public schema type get schema type ( ) { return schema type ; }
public static map synchronize map ( map map ) { return collection . synchronize map ( map ) ; }
public long get length ( ) { return length ; }
public data buffer get payload ( ) { return this . payload ; }
public void start run ( ) { if ( enable ) start run ( null ) ; }
public string get protocol ( ) { return protocol ; }
public final i region [ ] compute project master region ( int offset in master , int length in master ) throw bad location exception { i region image region= f mapping . to image region ( new region ( offset in master , length in master ) ) ; return image region ! = null ? f mapping . to exact origin region ( image region ) : null ; }
public void set strict parsing ( boolean be strict ) { this . be strict parse = be strict ; }
public progress listener get progress listener ( ) { return this . listener ; }
public object get result ( ) { return result ; }
public boolean get cache response metadata ( ) { return cache response metadata ; }
protect server socket factory get server socket factory ( ) throw exception { return server socket factory . get default ( ) ; }
public void add text ( string text ) { this . text = text ; }
public byte string hash ( ) { byte [ ] result = message digest ! = null ? message digest . digest ( ) : mac . do final ( ) ; return byte string . of ( result ) ; }
public int read sign byte ( ) throw i o exception { int sign byte = read ( ) ; return sign byte < 127 ? sign byte : sign byte - 256 ; }
protect string get timestamp ( ) { date date = new date ( system . current time millis ( ) ) ; date format formatter = date format . get date time instance ( date format . short , date format . short ) ; string finish time = formatter . format ( date ) ; return finish time ; }
public int get day since epoch ( ) { return day since epoch ; }
public collection < statement > get statement ( ) { return statement ; }
public json object to json ( ) { json object json = super . to json ( ) ; http client option converter . to json ( this , json ) ; return json ; }
public void set resource ( resource resource ) { this . resource = resource ; }
public static condition condition ( boolean value ) { return condition ( tool . field ( value ) ) ; }
protect void validate profile ( string profile ) { if ( ! string utils . have text ( profile ) ) { throw new illegal argument exception ( `` invalid profile [ `` + profile + `` ] : must contain text `` ) ; } if ( profile . char at ( 0 ) == ' ! ' ) { throw new illegal argument exception ( `` invalid profile [ `` + profile + `` ] : must not begin with ! operator `` ) ; } }
public string get property ( ) { return property ; }
public credential get credential ( ) { return credential ; }
public byte [ ] hash ( string text ) throw sdk client exception { return abstract a w s signer . do hash ( text ) ; }
public request < ? > get request ( ) { return request ; }
public void put field ( string key , string value ) { this . field . put ( key , value ) ; }
public int get max connection ( ) { debug code call ( `` get max connection `` ) ; return 0 ; }
public authentication builder add custom ( authentication authentication ) { if ( authentication ! = null ) { authentication . add ( authentication ) ; } return this ; }
public void set min gzip size ( int min gzip size ) { _min gzip size = min gzip size ; }
public int get min idle ( ) { final int max idle save = get max idle ( ) ; if ( this . min idle > max idle save ) { return max idle save ; } return min idle ; }
public response metadata get response metadata ( ) { return response metadata ; }
public void set http client ( http client http client ) { this . http client = http client ; }
protect response input stream get input stream ( ) { return input ; }
public void shutdown now ( ) { weld . shutdown ( ) ; }
public collect request get request ( ) { return request ; }
public static boolean register connection manager ( http client connection manager connection manager , long max idle in m ) { if ( instance == null ) { synchronize ( idle connection reaper . class ) { if ( instance == null ) { instance = new idle connection reaper ( ) ; instance . start ( ) ; } } } return connection manager . put ( connection manager , max idle in m ) == null ; }
public static boolean register connection manager ( http client connection manager connection manager ) { return register connection manager ( connection manager , default_max_idle_millis ) ; }
public autodiscover error code get error code ( ) { return error code ; }
public void set construct type ( int type ) { construct type = type ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public string get server info ( ) { return mbean server . dump ( ) ; }
public static void disable metric ( ) { set metric collector ( metric collector . none ) ; }
public static < t extend request metric collector > t get request metric collector ( ) { if ( mc == null ) { if ( be default metric enable ( ) ) enable default metric ( ) ; } @ suppress warning ( `` unchecked `` ) t t = ( t ) ( mc == null ? request metric collector . none : mc . get request metric collector ( ) ) ; return t ; }
public static < t extend request metric collector > t get request metric collector ( ) { if ( mc == null ) { if ( be default metric enable ( ) ) enable default metric ( ) ; } @ suppress warning ( `` unchecked `` ) t t = ( t ) ( mc == null ? request metric collector . none : mc . get request metric collector ( ) ) ; return t ; }
public set < type > get type ( ) { return type ; }
protect char [ ] get password from credential provider ( string name ) throw i o exception { char [ ] pas = null ; try { list < credential provider > provider = credential provider factory . get provider ( this ) ; if ( provider ! = null ) { for ( credential provider provider : provider ) { try { credential entry entry = provider . get credential entry ( name ) ; if ( entry ! = null ) { pas = entry . get credential ( ) ; break ; } } catch ( i o exception ioe ) { throw new i o exception ( `` ca n't get key `` + name + `` from key provider `` + `` of type : `` + provider . get class ( ) . get name ( ) + `` . `` , ioe ) ; } } } } catch ( i o exception ioe ) { throw new i o exception ( `` configuration problem with provider path . `` , ioe ) ; } return pas ; }
public static void set jvm metric name ( string jvm metric name ) { aws sdk metric . jvm metric name = jvm metric name ; }
public static string get jvm metric name ( ) { return jvm metric name ; }
public string get host ( ) { return host ; }
public credential get credential ( ) { return credential ; }
public string get suffix ( ) { return suffix ; }
public boolean be boolean ( ) { return false ; }
public list < server service definition > get service ( ) { return service ; }
public boolean have http endpoint ( string service name ) { return region impl . have http endpoint ( service name ) ; }
public boolean have https endpoint ( string service name ) { return region impl . have https endpoint ( service name ) ; }
public static backoff policy wrap ( backoff policy delegate , runnable on backoff ) { return new wrap backoff policy ( delegate , on backoff ) ; }
public list < exception > get exception ( ) { return exception ; }
public boolean be boolean ( ) { return false ; }
public boolean test expression ( string expression ) { if ( expression . equal ( `` . `` ) ) return true ; return stack string . end with ( expression ) ; }
public string get expression ( ) { return expression ; }
public string get event ( ) { return event ; }
public byte [ ] get byte ( ) { return byte ; }
public static string encode a string ( byte . . . byte ) { if ( bytes == null ) return null ; return byte . length == 0 ? `` `` : codec utils . to string direct ( codec . encode ( byte ) ) ; }
public static uuid uuid ( byte buffer bb ) { bb = bb . slice ( ) ; return new uuid ( bb . get long ( ) , bb . get long ( ) ) ; }
public synchronize void acquire ( ) throw interrupted exception { while ( try to acquire ( ) == false ) { wait ( ) ; } }
protect string get timestamp ( ) { date date = new date ( system . current time millis ( ) ) ; date format formatter = date format . get date time instance ( date format . short , date format . short ) ; string finish time = formatter . format ( date ) ; return finish time ; }
public static < k , v > java . util . map < k , v > of ( k k1 , v v1 , k k2 , v v2 , k k3 , v v3 , k k4 , v v4 ) { return map n ( k1 , v1 , k2 , v2 , k3 , v3 , k4 , v4 ) ; }
public static long copy and close ( input stream in , output stream out ) throw i o exception { try { long len = copy and close input ( in , out ) ; out . close ( ) ; return len ; } catch ( exception e ) { throw db exception . convert to i o exception ( e ) ; } finally { close silently ( out ) ; } }
public string get version ( ) { return version ; }
public json object to json ( ) { json object json = super . to json ( ) ; http client option converter . to json ( this , json ) ; return json ; }
public static byte [ ] decode base64 ( string base64 value ) { return base64 . get decoder ( ) . decode ( base64 value . replace all ( `` \\s `` , `` `` ) ) ; }
public void set parameter value type name ( string value ) { this . parameter value type name = value ; }
public static string join ( collection < string > part , string separator , string last separator ) { string builder sb = new string builder ( ) ; int i = 0 ; int last index = part . size ( ) - 1 ; for ( string part : part ) { sb . append ( part ) ; if ( i == last index - 1 ) { sb . append ( last separator ) ; } else if ( i ! = last index ) { sb . append ( separator ) ; } i++ ; } return sb . to string ( ) ; }
public static boolean be empty ( string str ) { return ( str == null || str . length ( ) == 0 ) ; }
public ast node get expression ( ) { return expression ; }
public output < boolean > output ( ) { return output ; }
public send message result send message ( send message request request ) { request = before client execution ( request ) ; return execute send message ( request ) ; }
public receive message result receive message ( receive message request request ) { request = before client execution ( request ) ; return execute receive message ( request ) ; }
public tag tag ( ) { return tag ; }
public void set batch size ( int batch size ) { this . batch size = batch size ; }
public long get w ( ) { if ( w == null ) { return 0l ; } else { return w ; } }
public object get attribute ( string name ) { return this . attribute . get ( name ) ; }
public void set message ( string message ) { this . message = message ; }
public boolean be queue ( ) { return queue ; }
protect final void public api only ( ) { visibility = visibility . public ; }
public void set max wait ( long time ) { max wait millis = time ; }
public void set label ( name label ) { this . label = label ; if ( label ! = null ) label . set parent ( this ) ; }
public void remove header ( header header ) { header . remove ( header ) ; }
public attachment collection get attachment ( ) throw exception { return ( attachment collection ) this . get object from property definition ( item schema . attachment ) ; }
public void set in stream ( in stream stream ) { this . stream = stream ; }
public int get chunk size ( ) { return this . chunk size ; }
public void set content type ( string content type ) { assert . not null ( content type , `` 'content type ' must not be null `` ) ; this . content type = content type ; }
public void set fault node ( string node ) { fault node = node ; }
public string get fault node ( ) { return ( fault node ) ; }
public static int get call id ( ) { call call = cur call . get ( ) ; return call ! = null ? call . call id : rpc constant . invalid_call_id ; }
public void init quit action ( quit action quit action ) { if ( quit action == null ) throw new illegal argument exception ( `` quit action be null `` ) ; if ( this . quit action ! = null ) throw new illegal argument exception ( `` the method be once-call . `` ) ; this . quit action = quit action ; }
public string quit ( option opt ) throw exception { process opts ( opts ) ; return quit ( ) ; }
public string get input file ( ) { return input file name ; }
public list < operation > static operation ( ) { return static operation ; }
public void set s o a p action u r i ( string s o a p action u r i ) { use s o a p action = true ; this . s o a p action u r i = s o a p action u r i ; } // set s o a p action u r i
public boolean use s o a p action ( ) { return use s o a p action ; } // use s o a p action
public void disable transport ( string transport name ) { if ( valid transport ! = null ) { valid transport . remove element ( transport name ) ; } }
public void set require parameter name ( string require parameter name ) { this . require parameter name = require parameter name ; }
public set < type > get type ( ) { return type ; }
public final q name get name ( ) { return name ; }
public int get port ( ) { return port ; }
public static string get version ( ) { return message . get message ( `` axis version `` ) + `` \n `` + message . get message ( `` build on `` ) ; }
public boolean be attachment ( object value ) { return attachment utils . be attachment ( value ) ; }
public void set header ( string header ) { this . header = header ; }
public final http params get request params ( ) { return request params ; }
public static annotation engine get annotation engine ( ) { return registry . get annotation engine ( ) ; }
public javax . xml . soap . s o a p header add header ( ) throw s o a p exception { if ( header == null ) { header = new s o a p header ( this , soap constant ) ; header . set owner document ( get owner document ( ) ) ; return header ; } else { throw new s o a p exception ( message . get message ( `` header present `` ) ) ; } }
public void set url ( string url ) { this . url = url ; } // -- void set url ( string )
public void set default handler ( element handler handler ) { default handler = handler ; }
public namespace get namespace ( ) { return namespace ; }
public print writer get writer ( ) throw i o exception { return this . response . get writer ( ) ; }
public void set registry ( registry registry ) { this . registry = registry ; }
public data flow node create new node ( node node ) { return data flow handler . create data flow node ( data flow , node ) ; }
public mapping get mapping ( ) { return mapping ; }
public style get binding style ( ) { return bind style ; } // get binding style
public static string get element content ( final element element ) throw exception { return get element content ( element , null ) ; }
public boolean be boolean ( ) { return false ; }
public void set nillable ( boolean nillable ) { this . nillable = nillable ; }
public static void debug ( final string message ) { log ( debug , message ) ; }
public string get desc ( ) { return descriptor ; }
public final cancellable mget async ( multi get request multi get request , request option option , action listener < multi get response > listener ) { return perform request async and parse entity ( multi get request , request converter : : multi get , option , multi get response : : from x content , listener , singleton ( 404 ) ) ; }
public void add type mapping ( w s d d type map mapping ) { type mapping . add ( map ) ; }
public void set make ( boolean make ) { this . make = make ; }
public string to turtle ( ) { string val = this . value ; val = val . replace ( `` \ `` `` , `` \\\ `` `` ) ; val = `` \ `` `` +val+ `` \ `` `` ; if ( data type == null ) { if ( language ! = null ) { val = val+ `` @ `` +language ; } } else { val = val+ `` ^^ < `` + data type . get xml schema u r i string ( ) + `` > `` ; } return val ; }
public string get name ( ) { return name ; }
public list < server service definition > get service ( ) { return service ; }
public w s d d transport find transport ( string qname ) { return service admin . get transport ( new q name ( qname ) ) ; }
public void disable transport ( string transport name ) { if ( valid transport ! = null ) { valid transport . remove element ( transport name ) ; } }
protect void set name source start ( int start ) { this . name start= start ; }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public void set recorder ( s a x2 event recorder rec ) { recorder = rec ; }
public s a x2 event recorder get recorder ( ) { return recorder ; }
public envelope copy ( ) { return new envelope ( this ) ; }
public void validate ( document document ) throw s a x exception { if ( document ! = null ) { x m l reader reader = get x m l reader ( ) ; if ( error handler ! = null ) { reader . set error handler ( error handler ) ; } try { reader . parse ( new document input source ( document ) ) ; } catch ( i o exception e ) { throw new runtime exception ( `` catch and exception that should `` + `` never happen : `` + e ) ; } } }
public void add child ( unknown element child ) { if ( child == null ) { child = new array list ( ) ; } child . add ( child ) ; }
public final q name get name ( ) { return name ; }
public s o a p element add child element ( name child name ) throw s o a p exception { message element child = new message element ( child name . get local name ( ) , child name . get prefix ( ) , child name . get u r i ( ) ) ; add child ( child ) ; return child ; }
public document get document ( ) { return doc ; }
public query node get child ( ) { list < query node > child = get child ( ) ; if ( child == null || child . size ( ) == 0 ) { return null ; } return child . get ( 0 ) ; }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public static void debug ( final string message ) { log ( debug , message ) ; }
public javax . xml . soap . s o a p body get body ( ) throw s o a p exception { return body ; }
public void set header ( string header ) { this . header = header ; }
public javax . xml . soap . s o a p body add body ( ) throw s o a p exception { if ( body == null ) { body = new s o a p body ( this , soap constant ) ; _is dirty = true ; body . set owner document ( get owner document ( ) ) ; return body ; } else { throw new s o a p exception ( message . get message ( `` body present `` ) ) ; } }
public string get fault node ( ) { return ( fault node ) ; }
public object get context ( ) { return context ; }
public void finalize ( ) { close ( ) ; }
public void set registry ( registry registry ) { this . registry = registry ; }
protect void close session ( ) { synchronize ( this . session ) { for ( final i o session session : this . session ) { session . close ( ) ; } } }
public static distance feature query builder distance feature query ( string name , origin origin , string pivot ) { return new distance feature query builder ( name , origin , pivot ) ; }
public string get target name ( ) { return f target name ; }
public string get name ( ) { return name ; }
public void set counter ( counter counter ) { this . counter = counter ; }
public string get path ( ) { return path ; }
public static boolean development ( ) { boolean ret = io . vertx . ext . web . common . web environment . development ( ) ; return ret ; }
public void remove server socket ( instrumented < server stats > server , instrument < socket stats > socket ) { server socket map socket of server = per server socket . get ( id ( server ) ) ; assert socket of server ! = null ; remove ( socket of server , socket ) ; }
protect void set name source start ( int start ) { this . name start= start ; }
public long get timeout ( ) { return timeout ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public void set property ( string property ) { this . property = property ; }
public long long value ( ) { return value ; }
public void set calendar ( calendar calendar ) { this . calendar = calendar ; }
public void set st offset ( int st ) { this . st offset = st ; }
public bean property descriptor get any property desc ( ) { if ( type desc == null ) return null ; return type desc . get any desc ( ) ; }
public calendar get a calendar ( ) { return get a calendar ( calendar . get instance ( ) ) ; }
public double get time ( ) { return time ; }
public static boolean to boolean ( object value ) { if ( value instanceof boolean ) { return ( boolean ) value ; } if ( value instanceof string ) { string s = ( string ) value ; if ( project . to boolean ( s ) ) { return boolean . true ; } if ( `` off `` . equal ignore case ( s ) || `` false `` . equal ignore case ( s ) || `` no `` . equal ignore case ( s ) ) { return boolean . false ; } } return null ; }
public string get path ( ) { return path ; }
public string uri ( ) { return uri ; }
protect boolean be valid scheme ( string scheme ) { if ( scheme == null ) { return false ; } if ( ! scheme_pattern . matcher ( scheme ) . match ( ) ) { return false ; } if ( be off ( allow_all_schemes ) ) { if ( ! this . allow scheme . contains ( scheme ) ) { return false ; } } return true ; }
public void write ( byte [ ] b ) { }
public void set class loader ( class loader loader ) { class loader = loader ; }
public void set argument ( object [ ] argument ) { this . argument = argument ; }
public final string get id ( ) { return id ; }
public final string get name ( ) { return name ; }
public string to string ( ) { string builder sb = new string builder ( 256 ) ; sb . append ( `` ( `` ) ; sb . append ( get subject ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get predicate ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get object ( ) ) ; sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
public void set component type ( q name component type ) { this . component type = component type ; }
public void set class name ( string class name ) { reader class name = class name ; }
public boolean be value ( ) { return value ; }
public string get remain flag ( ) { string buffer sb = null ; int loop ; for ( loop = 0 ; loop < args . length ; loop++ ) { if ( args [ loop ] == null || args [ loop ] . length ( ) == 0 ) continue ; if ( args [ loop ] . char at ( 0 ) ! = '- ' ) continue ; if ( sb == null ) sb = new string buffer ( ) ; sb . append ( args [ loop ] . substring ( 1 ) ) ; } return ( sb == null ? null : sb . to string ( ) ) ; }
public int be flag set ( char opt char ) { int value = 0 ; int loop ; int i ; for ( loop = 0 ; use args ! = null & & loop < use args . size ( ) ; loop++ ) { string arg = ( string ) use args . element at ( loop ) ; if ( arg . char at ( 0 ) ! = '- ' ) continue ; for ( i = 0 ; i < arg . length ( ) ; i++ ) if ( arg . char at ( i ) == opt char ) value++ ; } for ( loop = 0 ; loop < args . length ; loop++ ) { if ( args [ loop ] == null || args [ loop ] . length ( ) == 0 ) continue ; if ( args [ loop ] . char at ( 0 ) ! = '- ' ) continue ; while ( args [ loop ] ! = null & & ( i = args [ loop ] . index of ( opt char ) ) ! = -1 ) { args [ loop ] = args [ loop ] . substring ( 0 , i ) + args [ loop ] . substring ( i+1 ) ; if ( args [ loop ] . length ( ) == 1 ) args [ loop ] = null ; value++ ; if ( use args == null ) use args = new vector ( ) ; use args . add ( `` - `` + opt char ) ; } } return ( value ) ; }
public static string capitalize ( string str ) { int str len ; if ( str == null || ( str len = str . length ( ) ) == 0 ) { return str ; } return new string buffer ( str len ) . append ( character . to title case ( str . char at ( 0 ) ) ) . append ( str . substring ( 1 ) ) . to string ( ) ; }
public static string strip end ( string str , string strip char ) { int end = get strip end ( str , strip char ) ; return ( end < 0 ) ? str : str . substring ( 0 , end ) ; }
public static string strip ( string str ) { return strip ( str , null ) ; }
public message get message ( ) { return message ; } // get message
public static string extract full service name ( string full method name ) { int index = check not null ( full method name , `` full method name `` ) . last index of ( '/ ' ) ; if ( index == -1 ) { return null ; } return full method name . substring ( 0 , index ) ; }
public void set type ( class < ? > type ) { this . type = type ; }
public boolean be stop ( ) { return run state . be stop ( ) ; }
public static string get element content ( final element element ) throw exception { return get element content ( element , null ) ; }
public bean property descriptor get any property desc ( ) { if ( type desc == null ) return null ; return type desc . get any desc ( ) ; }
public namespace get namespace ( ) { return namespace ; }
public void set style ( style style ) { this . style = style ; }
public string get name ( ) { return name ; }
public string get message ( ) { return message ; }
public void add ( q name qname ) { if ( ! _inverted ) add impl ( qname ) ; else remove impl ( qname ) ; }
public static string parse text node ( node node ) { final int node count = node . get child node ( ) . get length ( ) ; if ( node count == 0 ) { return `` `` ; } string builder buffer = new string builder ( ) ; for ( int i = 0 ; i < node count ; i++ ) { node child node = node . get child node ( ) . item ( i ) ; if ( child node . get node type ( ) == node . cdata_section_node || child node . get node type ( ) == node . text_node ) { buffer . append ( child node . get node value ( ) ) ; } } return buffer . to string ( ) ; }
protect map create index ( ) { return new hash map ( ) ; }
public int get port ( ) { return port ; }
public node get node ( ) { return node ; }
public final type literal < t > get type literal ( ) { return type literal ; }
public static boolean be valid name for component ( string component ) { if ( component . equal ( `` . `` ) || component . equal ( `` . . `` ) || component . index of ( `` : `` ) > = 0 || component . index of ( `` / `` ) > = 0 ) { return false ; } return ! be reserve path component ( component ) ; }
public string to string ( ) { return to string buffer ( ) . to string ( ) ; }
public set < type > get type ( ) { return type ; }
public file get dir ( ) { return this . dir ; }
public void set scope ( final scope scope ) { this . scope = scope ; }
public void set package ( string pkg ) { this . option . default package = pkg ; }
public synchronize void set excludes ( string [ ] exclude ) { if ( excludes == null ) { this . exclude = null ; } else { this . exclude = new string [ excludes . length ] ; for ( int i = 0 ; i < excludes . length ; i++ ) { this . exclude [ i ] = normalize pattern ( excludes [ i ] ) ; } } }
public file get file ( ) { return file ; }
public string get import simple name ( ) { if ( be import on demand ) { return null ; } string import name = get import name ( ) ; return import name . substring ( import name . last index of ( ' . ' ) + 1 ) ; }
public void set ( boolean value ) { this . value = value ; }
public void set file ( file file ) { this . file = file ; }
public int get modifier ( ) { return modifier . public ; }
public string [ ] get generate key name ( ) { return this . generate key name ; }
public void write ( file new file ) throw i o exception { try ( p o i f s file system fs = p o i f s file system . create ( new file ) ) { write ( f ) ; f . write filesystem ( ) ; } }
public void generate ( ) throw i o exception { string fqcn = get package ( ) + `` . `` + get class name ( ) ; if ( emitter . be deploy ( ) ) { if ( ! emitter . do exist ( fqcn ) ) { super . generate ( ) ; } } else { super . generate ( ) ; } }
public void generate ( ) throw i o exception { string fqcn = get package ( ) + `` . `` + get class name ( ) ; if ( emitter . be deploy ( ) ) { if ( ! emitter . do exist ( fqcn ) ) { super . generate ( ) ; } } else { super . generate ( ) ; } }
public void set extends ( string value ) { this . _extends = value ; }
public string get u r l ( ) { return service . get u r l ( ) ; }
public get request refresh ( boolean refresh ) { this . refresh = refresh ; return this ; }
public int get max reduce attempt ( ) { return conf . get max reduce attempt ( ) ; }
public void set proxy username ( string proxy username ) { this . proxy username = proxy username ; }
public string get proxy username ( ) { return this . proxy username ; }
public int get read timeout ( ) { return read timeout ; }
public input stream get input stream ( ) { return stream ; }
public void update info ( info info ) { box a p i connection api = this . get a p i ( ) ; url url = membership_url_template . build ( api . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( api , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; info . update ( json object ) ; }
public void set date format ( string date format ) { super . set internal date format ( new simple date format ( date format ) ) ; }
public list < string > get modify file ( ) { return modify file ; }
protect full http response new handshake response ( full http request req , http header header ) { char sequence key = req . header ( ) . get ( http header name . sec_websocket_key ) ; if ( key == null ) { throw new web socket server handshake exception ( `` not a web socket request : missing key `` , req ) ; } full http response res = new default full http response ( http_1_1 , http response status . switching_protocols , req . content ( ) . alloc ( ) . buffer ( 0 ) ) ; if ( header ! = null ) { re . header ( ) . add ( header ) ; } string accept seed = key + websocket_13_accept_guid ; byte [ ] sha1 = web socket util . sha1 ( accept seed . get byte ( charset util . us_ascii ) ) ; string accept = web socket util . base64 ( sha1 ) ; if ( logger . be debug enable ( ) ) { logger . debug ( `` web socket version 13 server handshake key : { } , response : { } `` , key , accept ) ; } res . header ( ) . set ( http header name . upgrade , http header value . websocket ) . set ( http header name . connection , http header value . upgrade ) . set ( http header name . sec_websocket_accept , accept ) ; string subprotocols = req . header ( ) . get ( http header name . sec_websocket_protocol ) ; if ( subprotocols ! = null ) { string select subprotocol = select subprotocol ( subprotocols ) ; if ( select subprotocol == null ) { if ( logger . be debug enable ( ) ) { logger . debug ( `` request subprotocol ( s ) not support : { } `` , subprotocols ) ; } } else { re . header ( ) . set ( http header name . sec_websocket_protocol , select subprotocol ) ; } } return re ; }
public void set part ( integer part ) { set integer property ( prefix+ `` : part `` , part ) ; }
protect void set size ( long size ) { this . size = size ; }
public int get offset ( ) { return offset ; }
public void load from xml ( ews service xml reader reader ) throw exception { this . id = reader . read element value ( xml namespace . message , xml element name . subscription id ) ; if ( this . get uses watermark ( ) ) { this . watermark = reader . read element value ( xml namespace . message , xml element name . watermark ) ; } }
public void set read timeout ( int read timeout ) { this . read timeout = read timeout ; }
public void update info ( box legal hold policy . info info ) { url url = legal_hold_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object response j s o n = json object . read from ( response . get j s o n ( ) ) ; info . update ( response j s o n ) ; }
public void update info ( box task . info info ) { url url = task_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; info . update ( json object ) ; }
public void update info ( box task . info info ) { url url = task_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; info . update ( json object ) ; }
public string get scope ( ) { return this . scope ; }
public v put ( k key , v value ) { return put ( key , value , false ) ; }
protect boolean be assignment context ( ) { return false ; }
public string get scope ( ) { return this . scope ; }
public void update info ( box legal hold policy . info info ) { url url = legal_hold_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object response j s o n = json object . read from ( response . get j s o n ( ) ) ; info . update ( response j s o n ) ; }
public void update info ( box task assignment . info info ) { url url = task_assignment_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; info . update ( json object ) ; }
public info get info ( ) { url url = task_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box a p i request request = new box a p i request ( this . get a p i ( ) , url , `` get `` ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object response j s o n = json object . read from ( response . get j s o n ( ) ) ; return new info ( response j s o n ) ; }
public void update info ( box task . info info ) { url url = task_url_template . build ( this . get a p i ( ) . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( this . get a p i ( ) , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; info . update ( json object ) ; }
public final byte ref term ( ) { return term ; }
public get request refresh ( boolean refresh ) { this . refresh = refresh ; return this ; }
public void insert ( java token new token ) { assert not null ( new token ) ; get previous token ( ) . if present ( p - > { p . next token = new token ; new token . previous token = p ; } ) ; previous token = new token ; new token . next token = this ; }
public void update info ( info info ) { box a p i connection api = this . get a p i ( ) ; url url = membership_url_template . build ( api . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( api , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; info . update ( json object ) ; }
public void set access ( string value ) { this . access = value ; }
public boolean be enable ( ) { return this . enable ; }
public string get status ( ) { return this . status ; } // -- string get status ( )
public int get chunk size ( ) { return chunk size ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public void set content ( @ nullable byte [ ] content ) { this . content = content ; this . input stream = null ; this . reader = null ; }
public boolean be repeat upload ( ) { return m repeat upload ; }
public progress listener get general progress listener ( ) { return progress listener ; }
public void remove ( k key ) { synchronize ( cache ) { cache . remove ( key ) ; } }
public string get private key ( ) { return this . private key ; } // -- string get private key ( )
public string get path ( ) { return this . path ; }
public static value array get ( value [ ] list ) { return new value array ( list ) ; }
public void update info ( info info ) { box a p i connection api = this . get a p i ( ) ; url url = membership_url_template . build ( api . get base u r l ( ) , this . get i d ( ) ) ; box j s o n request request = new box j s o n request ( api , url , `` put `` ) ; request . set body ( info . get pending change ( ) ) ; box j s o n response response = ( box j s o n response ) request . send ( ) ; json object json object = json object . read from ( response . get j s o n ( ) ) ; info . update ( json object ) ; }
public list < resource model issue > get issue list ( ) { return issue list ; }
public long get upper bound at ( final int index ) { return upper bound [ index ] ; }
public url get url ( ) { return url ; }
public void set class loader ( class loader loader ) { class loader = loader ; }
public node get parent ( ) { return parent ; }
public set < string > get reference string ( ) { return reference string ; }
public string get import simple name ( ) { if ( be import on demand ) { return null ; } string import name = get import name ( ) ; return import name . substring ( import name . last index of ( ' . ' ) + 1 ) ; }
public void import package ( string package name ) { import package . add ( package name ) ; }
protect < t extend member > t [ ] array ( t [ ] array ) { array begin ( ) ; try { class < ? > array class = array . get class ( ) . get component type ( ) ; constructor < ? > ctor = array class . get declared constructor ( new class [ ] { array class . get enclosing class ( ) } ) ; object [ ] parameter = { struct . this } ; for ( int i = 0 ; i < array . length ; ++i ) { array [ i ] = ( t ) ctor . new instance ( parameter ) ; } } catch ( exception ex ) { throw new runtime exception ( ex ) ; } array end ( ) ; return array ; }
public string get table ( ) { return table ; }
public void set type ( class < ? > type ) { this . type = type ; }
public field set set field ( field field ) { return set field ( new field description . for loaded field ( field ) ) ; }
public class < t > get type ( ) { return type ; }
public void ensure capacity ( @ non negative long maximum size ) { require argument ( maximum size > = 0 ) ; int maximum = ( int ) math . min ( maximum size , integer . max_value > > > 1 ) ; if ( ( table ! = null ) & & ( table . length > = maximum ) ) { return ; } table = new long [ ( maximum == 0 ) ? 1 : caffeine . ceiling power of two ( maximum ) ] ; table mask = math . max ( 0 , table . length - 1 ) ; sample size = ( maximum size == 0 ) ? 10 : ( 10 * maximum ) ; if ( sample size < = 0 ) { sample size = integer . max_value ; } size = 0 ; }
public boolean have queue thread ( ) { return sync . have queue thread ( ) ; }
public boolean be queue ( ) { return queue ; }
public list < condition > get condition ( ) { return condition ; }
public static role role ( string name ) { return role ( name ( name ) ) ; }
public thread pool stats get thread pool ( ) { return this . thread pool ; }
public disk status get disk status ( ) throw i o exception { return new disk status ( dfs . get disk status ( ) ) ; }
public static create keyspace create keyspace ( string keyspace name ) { return new create keyspace ( keyspace name ) ; }
public keyspace get keyspace instance ( string keyspace name ) { return keyspace instance . get ( keyspace name ) ; }
public semantic context get semantic context for alt ( d f a state d , int alt ) { map < integer , semantic context > alt to pred map = state to alt set with semantic predicate map . get ( d ) ; if ( alt to pred map==null ) { return null ; } return alt to pred map . get ( utils . integer ( alt ) ) ; }
public static builder new builder ( ) { return new builder ( ) ; }
public i undoable operation get operation ( ) { return operation ; }
public boolean be empty ( ) { return name . be empty ( ) ; }
public immutable list < c > column key list ( ) { return column list ; }
public criterion in ( collection value ) { return restriction . in ( get property name ( ) , value ) ; }
public final int column count ( ) { return column ; }
protect string builder append to ( string builder builder ) { return task id . append to ( builder ) . append ( separator ) . append ( id ) ; }
public void set use naming ( boolean use naming ) { this . use name = use name ; }
public static < t extend ring position < t > > set < bound < t > > get non overlap bound ( iterable < bound < t > > bound ) { array list < bound < t > > sort bound = list . new array list ( bound ) ; collection . sort ( sorted bound , new comparator < bound < t > > ( ) { public int compare ( bound < t > o1 , bound < t > o2 ) { return o1 . leave . compare to ( o2 . left ) ; } } ) ; set < bound < t > > non overlap bound = set . new hash set ( ) ; peek iterator < bound < t > > it = iterators . peek iterator ( sorted bound . iterator ( ) ) ; while ( it . have next ( ) ) { bound < t > begin bound = it . next ( ) ; bound < t > end bound = begin bound ; while ( it . have next ( ) & & end bound . right . compare to ( it . peek ( ) . leave ) > = 0 ) end bound = it . next ( ) ; non overlap bound . add ( new bound < > ( begin bound . leave , end bound . right ) ) ; } return non overlap bound ; }
public boolean be async support ( ) { return request . be async support ( ) ; }
public local result get key ( session session ) { database db = session == null ? null : session . get database ( ) ; if ( boolean . false . equal ( generate key request ) ) { clear ( null ) ; return new local result ( ) ; } array list < expression column > expression column ; if ( boolean . true . equal ( generate key request ) ) { expression column = new array list < > ( all column . size ( ) ) ; for ( column column : all column ) { expression column . add ( new expression column ( db , column ) ) ; } } else if ( generate key request instanceof int [ ] ) { if ( table ! = null ) { int [ ] index = ( int [ ] ) generate keys request ; column [ ] column = table . get columns ( ) ; int cnt = column . length ; all column . clear ( ) ; expression columns = new array list < > ( index . length ) ; for ( int idx : index ) { if ( idx > = 1 & & idx < = cnt ) { column column = column [ idx - 1 ] ; expression column . add ( new expression column ( db , column ) ) ; all column . add ( column ) ; } } } else { clear ( null ) ; return new local result ( ) ; } } else if ( generate key request instanceof string [ ] ) { if ( table ! = null ) { string [ ] name = ( string [ ] ) generate keys request ; all column . clear ( ) ; expression columns = new array list < > ( names . length ) ; for ( string name : name ) { column column ; search : if ( table . do column exist ( name ) ) { column = table . get column ( name ) ; } else { name = string utils . to upper english ( name ) ; if ( table . do column exist ( name ) ) { column = table . get column ( name ) ; } else { for ( column c : table . get columns ( ) ) { if ( c . get name ( ) . equal ignore case ( name ) ) { column = c ; break search ; } } continue ; } } expression column . add ( new expression column ( db , column ) ) ; all column . add ( column ) ; } } else { clear ( null ) ; return new local result ( ) ; } } else { clear ( null ) ; return new local result ( ) ; } int column count = expression column . size ( ) ; if ( column count == 0 ) { clear ( null ) ; return new local result ( ) ; } local result result = new local result ( session , expression column . to array ( new expression [ 0 ] ) , column count ) ; for ( map < column , value > map : data ) { value [ ] row = new value [ column count ] ; for ( map . entry < column , value > entry : map . entry set ( ) ) { int idx = all column . index of ( entry . get key ( ) ) ; if ( idx > = 0 ) { row [ idx ] = entry . get value ( ) ; } } for ( int i = 0 ; i < column count ; i++ ) { if ( row [ i ] == null ) { row [ i ] = value null . instance ; } } result . add row ( row ) ; } clear ( null ) ; return result ; }
public sort set selector . type get selector ( ) { return selector ; }
public static < t > boolean list contains duplicate ( list < t > list ) { return list . size ( ) ! = new hash set < > ( list ) . size ( ) ; }
public select set where clause ( string where clause ) { this . where clause = where clause ; this . guesstimate buffer size += where clause . length ( ) ; return this ; }
public string get prefix ( ) { return prefix ; }
public void invalidate uri component view ( ) { this . decoded query params view = null ; this . encoded query params view = null ; }
public future < commit log position > dump memtable ( ) { synchronize ( data ) { final flush flush = new flush ( true ) ; flush executor . execute ( flush ) ; post flush executor . execute ( flush . post flush task ) ; return flush . post flush task ; } }
public long get size max ( ) { return size max ; }
public listenable future < commit log position > switch memtable ( ) { synchronize ( data ) { log flush ( ) ; flush flush = new flush ( false ) ; flush executor . execute ( flush ) ; post flush executor . execute ( flush . post flush task ) ; return flush . post flush task ; } }
public output < v > idx ( ) { return idx ; }
public local result get key ( session session ) { database db = session == null ? null : session . get database ( ) ; if ( boolean . false . equal ( generate key request ) ) { clear ( null ) ; return new local result ( ) ; } array list < expression column > expression column ; if ( boolean . true . equal ( generate key request ) ) { expression column = new array list < > ( all column . size ( ) ) ; for ( column column : all column ) { expression column . add ( new expression column ( db , column ) ) ; } } else if ( generate key request instanceof int [ ] ) { if ( table ! = null ) { int [ ] index = ( int [ ] ) generate keys request ; column [ ] column = table . get columns ( ) ; int cnt = column . length ; all column . clear ( ) ; expression columns = new array list < > ( index . length ) ; for ( int idx : index ) { if ( idx > = 1 & & idx < = cnt ) { column column = column [ idx - 1 ] ; expression column . add ( new expression column ( db , column ) ) ; all column . add ( column ) ; } } } else { clear ( null ) ; return new local result ( ) ; } } else if ( generate key request instanceof string [ ] ) { if ( table ! = null ) { string [ ] name = ( string [ ] ) generate keys request ; all column . clear ( ) ; expression columns = new array list < > ( names . length ) ; for ( string name : name ) { column column ; search : if ( table . do column exist ( name ) ) { column = table . get column ( name ) ; } else { name = string utils . to upper english ( name ) ; if ( table . do column exist ( name ) ) { column = table . get column ( name ) ; } else { for ( column c : table . get columns ( ) ) { if ( c . get name ( ) . equal ignore case ( name ) ) { column = c ; break search ; } } continue ; } } expression column . add ( new expression column ( db , column ) ) ; all column . add ( column ) ; } } else { clear ( null ) ; return new local result ( ) ; } } else { clear ( null ) ; return new local result ( ) ; } int column count = expression column . size ( ) ; if ( column count == 0 ) { clear ( null ) ; return new local result ( ) ; } local result result = new local result ( session , expression column . to array ( new expression [ 0 ] ) , column count ) ; for ( map < column , value > map : data ) { value [ ] row = new value [ column count ] ; for ( map . entry < column , value > entry : map . entry set ( ) ) { int idx = all column . index of ( entry . get key ( ) ) ; if ( idx > = 0 ) { row [ idx ] = entry . get value ( ) ; } } for ( int i = 0 ; i < column count ; i++ ) { if ( row [ i ] == null ) { row [ i ] = value null . instance ; } } result . add row ( row ) ; } clear ( null ) ; return result ; }
public static < v > void apply ( object [ ] btree , consumer < v > function , predicate < v > stop condition , boolean reverse ) { if ( reverse ) apply reverse ( btree , function , stop condition ) ; else apply forward ( btree , function , stop condition ) ; }
public coordinate [ ] get intersection segment ( ) { return int segment ; }
public void set file ( file file ) { this . file = file ; }
public void set interval ( long interval ) { this . interval = interval ; }
public string get family name ( ) { return family name ; }
public strategy get strategy ( ) { return strategy ; }
public double get estimate ( ) { return estimate ; }
public state get state ( ) { return state . get ( ) . get state ( ) ; }
public object get fetch value ( ) { return fetch value ; }
public void set snapshot ( snapshot snapshot ) { this . snapshot = snapshot ; } // -- void set snapshot ( snapshot )
public final void cancel ( ) { super . cancel ( ) ; }
public long get timestamp ( ) { return timestamp ; }
public void row process ( string [ ] row , t context ) { row . add ( row ) ; }
public list < k > get deletion ( ) { if ( deletions==null ) return immutable list . of ( ) ; return deletion ; }
public void row process ( string [ ] row , t context ) { row . add ( row ) ; }
public static row iterator log iterator ( row iterator iterator , final string id ) { c f meta data metadata = iterator . metadata ( ) ; logger . info ( `` [ { } ] log iterator on { } . { } , partition key= { } , reversed= { } `` , id , metadata . k name , metadata . cf name , metadata . get key validator ( ) . get string ( iterator . partition key ( ) . get key ( ) ) , iterator . be reverse order ( ) ) ; class log extend transformation { @ override public row apply to static ( row row ) { if ( ! row . be empty ( ) ) logger . info ( `` [ { } ] { } `` , id , row . to string ( metadata ) ) ; return row ; } @ override public row apply to row ( row row ) { logger . info ( `` [ { } ] { } `` , id , row . to string ( metadata ) ) ; return row ; } } return transformation . apply ( iterator , new log ( ) ) ; }
public static single partition read command create ( c f meta data metadata , int now in sec , decorate key key , slice slice ) { return create ( metadata , now in sec , key , slice . with ( metadata . comparator , slice ) ) ; }
public static single partition read command full partition read ( c f meta data metadata , int now in sec , decorate key key ) { return create ( metadata , now in sec , key , slice . all ) ; }
public final boolean local ( ) { return local ; }
public void record bound ( final planet model planet model , final lat lon bound bound info , final plane p , final membership . . . bound ) { find intersection bound ( planet model , bound info , p , bound ) ; }
public keyspace get keyspace instance ( string keyspace name ) { return keyspace instance . get ( keyspace name ) ; }
public file get file ( ) { return f file ; }
public configuration builder set scanner ( scanner . . . scanner ) { this . scanner = new hash set < > ( arrays . a list ( scanner ) ) ; return this ; }
public int get position ( ) { return position ; }
public double compression ( ) { return compression ; }
public file get file ( ) { return file ; }
public void remove from move ( inet address endpoint ) { assert endpoint ! = null ; lock . write lock ( ) . lock ( ) ; try { for ( pair < token , inet address > pair : moving endpoint ) { if ( pair . right . equal ( endpoint ) ) { move endpoint . remove ( pair ) ; break ; } } invalidate cached ring ( ) ; } finally { lock . write lock ( ) . unlock ( ) ; } }
public void set endpoint address ( @ nullable string endpoint address ) { this . endpoint address = endpoint address ; }
public long get n ( ) { return n ; }
public boolean contains ( char sequence s ) { return back . contains ( s ) ; }
public boolean have map ( string name ) { return meta . contains key ( `` name . `` + name ) ; }
public string [ ] index ( ) { return index ; }
public static boolean be native ( int flag ) { return ( flags & acc native ) ! = 0 ; }
public void set server ( server server ) { this . server = server ; }
public void end test ( test test ) { f model . add run test ( test ) ; fire test change ( test , false ) ; }
public void progress ( float progress ) throw i o exception { progress value = progress ; reporter . progress ( ) ; if ( record reader ! = null ) { progress key . set ( progress ) ; record reader . next ( progress key , null value ) ; } }
public void apply ( consumer < column definition > function , boolean reverse ) { b tree . apply ( column , function , reverse ) ; }
public byte [ ] get byte ( ) { return byte ; }
public static char byte to char ( byte [ ] bytes ) { return bytes to char ( byte , 0 ) ; }
public synchronize void wait on barrier ( ) throw exception { wait on barrier ( -1 , null ) ; }
public void set refid ( reference ref ) { this . ref = ref ; }
public j tree get tree ( ) { return f tree ; }
public long get timestamp ( ) { return timestamp ; }
public static array < long > of all ( long [ ] array ) { object . require non null ( array , `` array be null `` ) ; return of all ( iterator . of all ( array ) ) ; }
public object [ ] get value ( ) { t v = get value ( ) ; return v ! = null ? new object [ ] { v } : new object [ 0 ] ; }
public big integer get abstract num i d ( big integer num i d ) { x w p f num num = get num ( num i d ) ; if ( num == null ) return null ; if ( num . get c t num ( ) == null ) return null ; if ( num . get c t num ( ) . get abstract num id ( ) == null ) return null ; return num . get c t num ( ) . get abstract num id ( ) . get val ( ) ; }
public window frame unit get unit ( ) { return unit ; }
protect static byte value of ( final byte b ) { return new byte ( b ) ; }
public vector3 d get u ( ) { return u ; }
public option get option ( ) { return option ; }
public static void init ( ) { }
public final void remove job change listener ( i job change listener listener ) { super . remove job change listener ( listener ) ; }
public long get high trackable value ( ) { return high trackable value ; }
public static void set default ( codec codec ) { default codec = codec ; }
public static < t > list < t > a list ( t [ ] a ) { if ( a == null ) return collection . empty list ( ) ; return array . a list ( a ) ; }
public string get protocol ( ) { return protocol ; }
public static double day in month ( x path context context ) throw x path exception { return day in month ( date time ( context ) ) ; }
public version get version ( ) { return version ; }
public string get speculative retry ( ) { return speculative retry ; }
public statement set page state ( page state paging state , codec registry codec registry ) { if ( this instanceof batch statement ) { throw new unsupported operation exception ( `` can not set the page state on a batch statement `` ) ; } else { if ( page state == null ) { this . page state = null ; } else if ( page state . match ( this , codec registry ) ) { this . page state = page state . get raw state ( ) ; } else { throw new page state exception ( `` page state mismatch , `` + `` this mean that either the paging state content be alter , `` + `` or you 're try to apply it to a different statement `` ) ; } } return this ; }
public schema get schema ( ) { return schema ; }
public call get call ( ) { return call ; }
public string get node rack name ( ) { this . read lock . lock ( ) ; try { return this . node rack name ; } finally { this . read lock . unlock ( ) ; } }
public int get d s e patch ( ) { return dse patch ; }
public static builder builder ( ) { return new builder ( ) ; }
public int get day since epoch ( ) { return day since epoch ; }
public static local date from day since epoch ( int day since epoch ) { return new local date ( day since epoch ) ; }
public void set host ( string host ) { this . host = host ; } // -- void set host ( string )
public synchronize boolean be connect ( ) { return connect ; }
public int get num open connection ( ) { return connection manager . size ( ) ; }
public int get receive buffer size ( ) { return receive buffer size ; }
protect void append ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i++ ) { append ( str . char at ( i ) ) ; } }
public void set reconnection delay ( int delay ) { this . reconnection delay = delay ; }
public void set idx ( long value ) { this . idx = value ; }
public void set fetch size ( int fetch size ) { this . fetch size = fetch size ; }
protect void set up ( ) throw exception { }
public get request refresh ( boolean refresh ) { this . refresh = refresh ; return this ; }
public get request refresh ( boolean refresh ) { this . refresh = refresh ; return this ; }
public term vector request builder set type ( string type ) { request . type ( type ) ; return this ; }
public void set before exist advisor ( boolean before exist advisor ) { this . before exist advisor = before exist advisor ; }
public create add u d t static column ( string column name , u d t type udt type ) { validate not empty ( table name , `` column name `` ) ; validate not null ( udt type , `` column udt type `` ) ; validate not key word ( column name , string . format ( `` the static column name ' % s ' be not allow because it be a reserved keyword `` , column name ) ) ; static column . put ( column name , udt type ) ; return this ; }
public t add u d t set column ( string column name , u d t type udt type ) { validate not empty ( column name , `` column name `` ) ; validate not null ( udt type , `` column element type `` ) ; validate not key word ( column name , string . format ( `` the column name ' % s ' be not allow because it be a reserved keyword `` , column name ) ) ; simple column . put ( column name , u d t type . set ( udt type ) ) ; return self ; }
public keyspace get keyspace instance ( string keyspace name ) { return keyspace instance . get ( keyspace name ) ; }
public type get type ( ) { return type ; }
public string get speculative retry ( ) { return speculative retry ; }
public void set cache ( boolean cache ) { this . cache = cache ; }
public int read timeout millis ( ) { return read timeout ; }
public static < e > void so element ( e [ ] buffer , long offset , e e ) { unsafe . put ordered object ( buffer , offset , e ) ; }
public int get receive buffer size ( ) { return receive buffer size ; }
public dedicate multi row uniqueness constraint < c > with consistency level ( consistency level consistency level ) { this . consistency level = consistency level ; return this ; }
public page state get page state ( ) { if ( this . page state == null ) return null ; return new page state ( this . page state , this . statement , this . protocol version , this . codec registry ) ; }
public boolean get be read ( ) { return this . be read ; }
public int get speculative execution ( ) { return speculative execution ; }
public schedule executor service get schedule executor ( ) throw illegal state exception { assert . state ( this . schedule executor ! = null , `` thread pool task scheduler not initialize `` ) ; return this . schedule executor ; }
public boolean be wrap around ( ) { return start . compare to ( end ) > 0 & & ! end . equal ( factory . min token ( ) ) ; }
public boolean be empty ( ) { return start . equal ( end ) & & ! start . equal ( factory . min token ( ) ) ; }
public static string capitalize ( string str ) { int str len ; if ( str == null || ( str len = str . length ( ) ) == 0 ) { return str ; } return new string buffer ( str len ) . append ( character . to title case ( str . char at ( 0 ) ) ) . append ( str . substring ( 1 ) ) . to string ( ) ; }
public static string generate uuid ( ) { return storage_id_prefix + uuid . random u u i d ( ) ; }
public static long unix timestamp ( uuid uuid ) { if ( uuid . version ( ) ! = 1 ) throw new illegal argument exception ( string . format ( `` can only retrieve the unix timestamp for version 1 uuid ( provide version % d ) `` , uuid . version ( ) ) ) ; long timestamp = uuid . timestamp ( ) ; return ( timestamp / 10000 ) + start_epoch ; }
public static uuid start of ( long timestamp ) { return new uuid ( make m s b ( from unix timestamp ( timestamp ) ) , min_clock_seq_and_node ) ; }
public patch type get patch type ( ) { return patch type ; }
public boolean be cluster ( ) { return event bus option . be cluster ( ) ; }
public kryo instantiator set instantiator strategy ( final instantiator strategy inst ) { return new kryo instantiator ( ) { public kryo new kryo ( ) { kryo k = kryo instantiator . this . new kryo ( ) ; k . set instantiator strategy ( inst ) ; return k ; } } ; }
public kryo instantiator set instantiator strategy ( final instantiator strategy inst ) { return new kryo instantiator ( ) { public kryo new kryo ( ) { kryo k = kryo instantiator . this . new kryo ( ) ; k . set instantiator strategy ( inst ) ; return k ; } } ; }
public kryo instantiator set class loader ( final class loader cl ) { return new kryo instantiator ( ) { public kryo new kryo ( ) { kryo k = kryo instantiator . this . new kryo ( ) ; k . set class loader ( cl ) ; return k ; } } ; }
public byte [ ] to byte array ( ) throw i o exception { byte array output stream output = new byte array output stream ( ) ; input stream be = null ; try { be = create input stream ( ) ; i o utils . copy ( be , output ) ; } finally { if ( be ! = null ) { be . close ( ) ; } } return output . to byte array ( ) ; }
public byte [ ] get signature ( ) { return signature ; }
public boolean be info enable ( ) { return be level enable ( info ) ; }
public header configurer < h > default disable ( ) { this . content type option . disable ( ) ; this . xss protection . disable ( ) ; this . cache control . disable ( ) ; this . hsts . disable ( ) ; this . frame option . disable ( ) ; return this ; }
public class graph enable remote jar scanning ( ) { scan spec . enable remote jar scan = true ; return this ; }
public void set module ( final list < module > module ) { this . module = module ; }
public class graph disable jar scanning ( ) { scan spec . scan jar = false ; return this ; }
public list < framework field > get annotate field ( class < ? extend annotation > annotation class ) { return get annotated member ( f field for annotation , annotation class ) ; }
public static object get value ( annotation annotation , string attribute name ) { if ( annotation == null || ! string utils . have text ( attribute name ) ) { return null ; } try { method method = annotation . annotation type ( ) . get declared method ( attribute name ) ; reflection utils . make accessible ( method ) ; return method . invoke ( annotation ) ; } catch ( exception ex ) { return null ; } }
public static object get value ( annotation annotation , string attribute name ) { if ( annotation == null || ! string utils . have text ( attribute name ) ) { return null ; } try { method method = annotation . annotation type ( ) . get declared method ( attribute name ) ; reflection utils . make accessible ( method ) ; return method . invoke ( annotation ) ; } catch ( exception ex ) { return null ; } }
public class info list get class implement ( final string interface name ) { if ( close . get ( ) ) { throw new illegal argument exception ( `` can not use a scan result after it have be close `` ) ; } if ( ! scan spec . enable class info ) { throw new illegal argument exception ( `` please call class graph # enable class info ( ) before # scan ( ) `` ) ; } final class info class info = class name to class info . get ( interface name ) ; return class info == null ? class info list . empty_list : class info . get class implement ( ) ; }
public final string get name ( ) { return name ; }
public final boolean be synchronize ( ) { return modifier . be synchronize ( get modifier ( ) ) ; }
public string get descriptor ( ) { return descriptor ; }
public list < resource > get resource ( ) { return resource ; }
public long get last modified ( ) { return last modify ; }
public list < resource > get resource ( ) { return resource ; }
public void set class info name index ( int class info name index ) { this . class info name index = class info name index ; }
public string get path ( ) { return path ; }
public file entry get parent ( ) { return parent ; }
public string to string ( ) { if ( i to string == null ) { string buffer buf = new string buffer ( 4 ) ; if ( be negate ( ) ) { buf . append ( '^ ' ) ; } buf . append ( start ) ; if ( start ! = end ) { buf . append ( '- ' ) ; buf . append ( end ) ; } i to string = buf . to string ( ) ; } return i to string ; }
protect collection < field access > field of ( class < ? > c ) { collection < field access > field = field of a s t class . get ( c ) ; if ( field ! = null ) return field ; field = new array list < field access > ( ) ; get field ( c , field ) ; field of a s t class . put ( c , field ) ; return field ; }
public boolean be empty ( ) { return name . be empty ( ) ; }
public int get position ( ) { return position ; }
public boolean add token ( token < ? extend token identifier > token ) { return ( token ! = null ) ? add token ( token . get service ( ) , token ) : false ; }
public string get path ( ) { final string builder buf = new string builder ( ) ; append path ( buf ) ; return buf . to string ( ) ; }
public string to string ( ) { if ( i to string == null ) { string buffer buf = new string buffer ( 4 ) ; if ( be negate ( ) ) { buf . append ( '^ ' ) ; } buf . append ( start ) ; if ( start ! = end ) { buf . append ( '- ' ) ; buf . append ( end ) ; } i to string = buf . to string ( ) ; } return i to string ; }
public static option builder with long opt ( string new longopt ) { option builder . longopt = new longopt ; return instance ; }
public static option builder be require ( boolean require ) { instance . require = require ; return instance ; }
public deployment option set instance ( int instance ) { this . instance = instance ; return this ; }
public static option builder be require ( boolean new require ) { option builder . require = new require ; return instance ; }
public void set description ( string description ) { this . description = description ; }
public void set option ( string opt ) { option . set ( 0 , new c o s string ( opt ) ) ; }
public void set option ( string opt ) { option . set ( 0 , new c o s string ( opt ) ) ; }
public static boolean be array ( object obj ) { return ( obj ! = null & & obj . get class ( ) . be array ( ) ) ; }
public static boolean be empty ( string str ) { return ( str == null || str . length ( ) == 0 ) ; }
public void set comparator ( final int index , final comparator < e > comparator ) throw index out of bound exception { set comparator ( index , comparator , false ) ; }
public static sort set decorate ( sorted set set , transformer transformer ) { return new transform sort set ( set , transformer ) ; }
public object remove ( final long timeout ) { synchronize ( lock ) { final long expiration = system . current time millis ( ) + timeout ; long time leave = expiration - system . current time millis ( ) ; while ( time leave > 0 & & collection . be empty ( ) ) { try { lock . wait ( time leave ) ; time leave = expiration - system . current time millis ( ) ; } catch ( interrupted exception e ) { print writer out = new print writer ( new string writer ( ) ) ; e . print stack trace ( out ) ; throw new buffer underflow exception ( `` cause by interrupted exception : `` + out . to string ( ) ) ; } } if ( collection . be empty ( ) ) { throw new buffer underflow exception ( `` timeout expired `` ) ; } return get buffer ( ) . remove ( ) ; } }
public object get ( ) { synchronize ( lock ) { while ( collection . be empty ( ) ) { try { if ( timeout < = 0 ) { lock . wait ( ) ; } else { return get ( timeout ) ; } } catch ( interrupted exception e ) { print writer out = new print writer ( new string writer ( ) ) ; e . print stack trace ( out ) ; throw new buffer underflow exception ( `` cause by interrupted exception : `` + out . to string ( ) ) ; } } return get buffer ( ) . get ( ) ; } }
public int size ( ) { return size ; }
public boolean be empty ( ) { return head == null ; }
public static string collection to comma delimited string ( collection < ? > coll ) { return collection to delimit string ( coll , `` , `` ) ; }
public boolean equal ( final object obj ) { if ( obj instanceof map ) { final map < ? , ? > map = ( map < ? , ? > ) obj ; return this . entry set ( ) . equal ( map . entry set ( ) ) ; } return false ; }
public output < v > idx ( ) { return idx ; }
protect void validate index ( int index ) { if ( index < 0 || index > size ) { throw new string index out of bound exception ( index ) ; } }
public final boolean content equal ( byte iterator other ) { assert . check not null param ( `` other `` , other ) ; for ( ; ; ) { if ( have next ( ) ) { if ( ! other . have next ( ) ) { return false ; } if ( next ( ) ! = other . next ( ) ) { return false ; } } else { return ! other . have next ( ) ; } } }
public object get value ( ) { return this . value ; }
public synchronize void set include ( string include ) { check attribute allow ( ) ; default pattern . set include ( include ) ; ds = null ; }
public int iterator key iterator ( ) { return new int to int hash map key iterator ( ) ; }
public boolean add all ( int index , collection collection ) { if ( fast ) { synchronize ( this ) { array list temp = ( array list ) list . clone ( ) ; boolean result = temp . add all ( index , collection ) ; list = temp ; return ( result ) ; } } else { synchronize ( list ) { return ( list . add all ( index , collection ) ) ; } } }
public void add ( int index , object element ) { if ( fast ) { synchronize ( this ) { array list temp = ( array list ) list . clone ( ) ; temp . add ( index , element ) ; list = temp ; } } else { synchronize ( list ) { list . add ( index , element ) ; } } }
public void add ( int index , object element ) { if ( fast ) { synchronize ( this ) { array list temp = ( array list ) list . clone ( ) ; temp . add ( index , element ) ; list = temp ; } } else { synchronize ( list ) { list . add ( index , element ) ; } } }
public list iterator list iterator ( int index ) { if ( fast ) { return new list iter ( index ) ; } else { return list . list iterator ( index ) ; } }
public list iterator list iterator ( ) { if ( fast ) { return new list iter ( 0 ) ; } else { return list . list iterator ( ) ; } }
public closure < ? super e > [ ] get closure ( ) { return functor utils . < e > copy ( i closure ) ; }
public resource chain registration add transformer ( resource transformer transformer ) { assert . not null ( transformer , `` the provided resource transformer should not be null `` ) ; this . transformer . add ( transformer ) ; if ( transformer instanceof cs link resource transformer ) { this . have css link transformer = true ; } return this ; }
public boolean retain all ( final collection < ? > coll ) { if ( coll instanceof bag ) { return retain all ( ( bag < ? > ) coll ) ; } return retain all ( new hash bag < > ( coll ) ) ; }
public set entry set ( ) { composite set entry = new composite set ( ) ; for ( int i = this . composite . length - 1 ; i > = 0 ; -- i ) { entry . add composited ( this . composite [ i ] . entry set ( ) ) ; } return entry ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public static map invert map ( map map ) { map out = new hash map ( map . size ( ) ) ; for ( iterator it = map . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; out . put ( entry . get value ( ) , entry . get key ( ) ) ; } return out ; }
public static map synchronize map ( map map ) { return collection . synchronize map ( map ) ; }
public static map invert map ( map map ) { map out = new hash map ( map . size ( ) ) ; for ( iterator it = map . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; out . put ( entry . get value ( ) , entry . get key ( ) ) ; } return out ; }
public static sort set decorate ( sorted set set , transformer transformer ) { return new transform sort set ( set , transformer ) ; }
public static map unmodifiable map ( map map ) { return unmodifiable map . decorate ( map ) ; }
public static float get float ( map map , object key , float default value ) { float answer = get float ( map , key ) ; if ( answer == null ) { answer = default value ; } return answer ; }
public static object get object ( map map , object key , object default value ) { if ( map ! = null ) { object answer = map . get ( key ) ; if ( answer ! = null ) { return answer ; } } return default value ; }
public void put all ( map map ) { if ( map instanceof multi map ) { for ( iterator it = map . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; collection coll = ( collection ) entry . get value ( ) ; put all ( entry . get key ( ) , coll ) ; } } else { for ( iterator it = map . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; put ( entry . get key ( ) , entry . get value ( ) ) ; } } }
protect map create map ( ) { return collection . synchronize map ( new hash map ( ) ) ; }
public static order map decorate ( ordered map map ) { if ( map instanceof unmodifiable ) { return map ; } return new unmodifiable order map ( map ) ; }
public static map unmodifiable map ( map map ) { return unmodifiable map . decorate ( map ) ; }
public static map unmodifiable sort map ( sort map map ) { return unmodifiable sort map . decorate ( map ) ; }
public argument write argument ( argument c ) { item . add ( c ) ; return this ; }
public string to string ( ) { return to string ( `` `` ) ; }
public static sort map decorate ( sort map map , transformer key transformer , transformer value transformer ) { return new transform sort map ( map , key transformer , value transformer ) ; }
public set < type > get type ( ) { return type ; }
public resource chain registration add transformer ( resource transformer transformer ) { assert . not null ( transformer , `` the provided resource transformer should not be null `` ) ; this . transformer . add ( transformer ) ; if ( transformer instanceof cs link resource transformer ) { this . have css link transformer = true ; } return this ; }
public void close ( ) throw i o exception { if ( ! this . close ) { this . close = true ; this . out . flush ( ) ; } }
public static int [ ] new int array ( int len ) { if ( len == 0 ) { return empty_int_array ; } return new int [ len ] ; }
public boolean be load ( ) { return load ; }
public void save ( string file name ) throw i o exception { save ( new file ( file name ) ) ; }
public string get u r l ( ) { return service . get u r l ( ) ; }
public void set bean factory ( bean factory bean factory ) { if ( this . target bean name == null ) { throw new illegal state exception ( `` property 'target bean name ' be require `` ) ; } this . bean factory = bean factory ; }
public string get configuration ( ) { return this . configuration ; } // -- string get configuration ( )
public node get node ( ) { return node ; }
public string get configuration ( ) { return this . configuration ; } // -- string get configuration ( )
public string get configuration ( ) { return this . configuration ; } // -- string get configuration ( )
public int get length ( ) { return buffer . get length ( ) ; }
protect error handler get error handler ( ) { return this . error handler ; }
public string get root name ( ) { return m root name ; }
public void set value ( t t ) { this . value = t ; }
public void value ( final byte array list list ) { list . clear ( ) ; for each key ( new byte procedure ( ) { @ override public boolean apply ( byte key ) { list . add ( get ( key ) ) ; return true ; } } ) ; }
public void set integer value ( int integer value ) { this . integer value = integer value ; }
public void set calendar ( calendar calendar ) { this . calendar = calendar ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public string get event ( ) { return event ; }
public string get prefix ( ) { return prefix ; }
public short value ( ) { return value ; }
public subnode configuration configuration at ( string key ) { return configuration at ( key , false ) ; }
public string key ( ) { return key ; }
public void set name ( string name ) { this . name = name ; }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public node get node ( ) { return node ; }
public object writer with view ( class < ? > view ) { return _new ( this , _config . with view ( view ) ) ; }
public void set transaction attribute source ( @ nullable transaction attribute source transaction attribute source ) { this . transaction attribute source = transaction attribute source ; }
public int get po ( ) { return po ; }
public static value array get ( value [ ] list ) { return new value array ( list ) ; }
public boolean be load ( ) { return load ; }
protect void add node before ( final node < e > node , final e value ) { final node < e > new node = create node ( value ) ; add node ( new node , node ) ; }
public string get configuration ( ) { return this . configuration ; } // -- string get configuration ( )
public static boolean be valid name for component ( string component ) { if ( component . equal ( `` . `` ) || component . equal ( `` . . `` ) || component . index of ( `` : `` ) > = 0 || component . index of ( `` / `` ) > = 0 ) { return false ; } return ! be reserve path component ( component ) ; }
public static crypto random get crypto random ( property prop ) throw general security exception { final list < string > name = utils . split class name ( get random class string ( prop ) , `` , `` ) ; if ( name . size ( ) == 0 ) { throw new illegal argument exception ( `` no classname ( s ) provide `` ) ; } string builder error message = new string builder ( ) ; crypto random random = null ; exception last exception = null ; for ( string klass name : name ) { try { final class < ? > klass = reflection utils . get class by name ( klass name ) ; random = ( crypto random ) reflection utils . new instance ( klass , prop ) ; if ( random ! = null ) { break ; } } catch ( class cast exception e ) { last exception = e ; error message . append ( `` class : [ `` + klass name + `` ] be not a crypto random . `` ) ; } catch ( class not find exception e ) { last exception = e ; error message . append ( `` crypto random : [ `` + klass name + `` ] not find . `` ) ; } catch ( exception e ) { last exception = e ; error message . append ( `` crypto random : [ `` + klass name + `` ] fail with `` + e . get message ( ) ) ; } } if ( random ! = null ) { return random ; } throw new general security exception ( error message . to string ( ) , last exception ) ; }
public static crypto random get crypto random ( ) throw general security exception { property property = new property ( ) ; return get crypto random ( property ) ; }
public int get buffer size ( ) { return buffer size ; }
public int get offset ( ) { return offset ; }
public static void read fully ( input stream input , byte [ ] buffer , int offset , int length ) throw i o exception { int actual = read ( input , buffer , offset , length ) ; if ( actual ! = length ) { throw new e o f exception ( `` length to read : `` + length + `` actual : `` + actual ) ; } }
public void set header ( string header ) { this . header = header ; }
public boolean be quote ( ) { return be quote ; }
public boolean have comment ( ) { return comment ! = null ; }
public string get comment ( ) { return comment ; }
protect void set last used ( final long last used millis ) { this . last used millis = last use millis ; }
public long get last used ( ) { return last used millis ; }
public class loader get class loader ( ) { return class loader ; }
public void set abandon config ( final abandon config abandon config ) { if ( abandon config == null ) { this . abandon config = null ; } else { this . abandon config = new abandon config ( ) ; this . abandon config . set log abandon ( abandon config . get log abandon ( ) ) ; this . abandon config . set log writer ( abandon config . get log writer ( ) ) ; this . abandon config . set remove abandon on borrow ( abandon config . get remove abandon on borrow ( ) ) ; this . abandon config . set remove abandon on maintenance ( abandon config . get remove abandon on maintenance ( ) ) ; this . abandon config . set remove abandon timeout ( abandon config . get remove abandon timeout duration ( ) ) ; this . abandon config . set use usage tracking ( abandon config . get use usage tracking ( ) ) ; this . abandon config . set require full stack trace ( abandon config . get require full stack trace ( ) ) ; } }
public void rollback ( ) { rollback to ( current version ) ; }
public void set log writer ( final print writer out ) { log writer = out ; }
public void set abandon config ( final abandon config abandon config ) { if ( abandon config == null ) { this . abandon config = null ; } else { this . abandon config = new abandon config ( ) ; this . abandon config . set log abandon ( abandon config . get log abandon ( ) ) ; this . abandon config . set log writer ( abandon config . get log writer ( ) ) ; this . abandon config . set remove abandon on borrow ( abandon config . get remove abandon on borrow ( ) ) ; this . abandon config . set remove abandon on maintenance ( abandon config . get remove abandon on maintenance ( ) ) ; this . abandon config . set remove abandon timeout ( abandon config . get remove abandon timeout duration ( ) ) ; this . abandon config . set use usage tracking ( abandon config . get use usage tracking ( ) ) ; this . abandon config . set require full stack trace ( abandon config . get require full stack trace ( ) ) ; } }
public void set jmx name base ( final string jmx name base ) { this . jmx name base = jmx name base ; }
public collection < statement > get statement ( ) { return statement ; }
public int get min idle ( ) { return this . min idle ; }
public boolean be active ( ) { return this . active ; } // -- boolean be active ( )
public string get username ( ) { return user name ; }
public static void close ( final u r l connection conn ) { if ( conn instanceof http u r l connection ) { ( ( http u r l connection ) conn ) . disconnect ( ) ; } }
public void set connection ( string connection ) { this . connection = connection ; } // -- void set connection ( string )
public void set transaction manager ( final transaction manager transaction manager ) { this . transaction manager = transaction manager ; }
public transaction manager get transaction manager ( ) { return transaction manager ; }
public string get username ( ) { return user name ; }
public synchronize void set pool prepared statement ( final boolean pool statement ) { this . pool prepare statement = pooling statement ; }
public print writer get writer ( ) throw i o exception { return this . response . get writer ( ) ; }
public static < t > object pool < t > erode pool ( final object pool < t > pool ) { return erode pool ( pool , 1f ) ; }
public string [ ] get generate key name ( ) { return this . generate key name ; }
public object get result ( ) { return result ; }
public class loader get class loader ( ) { return class loader ; }
public void set resource ( resource resource ) { this . resource = resource ; }
public void release ( ) { }
public static class get class ( class loader class loader , string class name ) throw class not find exception { return get class ( class loader , class name , true ) ; }
public static class loader get class loader ( ) { return get class loader ( loader . class , null ) ; }
public void set port ( int value ) { this . port = value ; }
public void write ( byte [ ] b ) { }
public static data output stream new data output stream ( file file ) throw i o exception { return new data output stream ( new file output stream ( file ) ) ; }
public void close ( ) throw i o exception { input . close ( ) ; }
public hash code builder append ( int [ ] array ) { if ( array == null ) { i total = i total * i constant ; } else { for ( int i = 0 ; i < array . length ; i++ ) { append ( array [ i ] ) ; } } return this ; }
public hash code builder append ( int [ ] array ) { if ( array == null ) { i total = i total * i constant ; } else { for ( int i = 0 ; i < array . length ; i++ ) { append ( array [ i ] ) ; } } return this ; }
public hash code builder append ( int [ ] array ) { if ( array == null ) { i total = i total * i constant ; } else { for ( int i = 0 ; i < array . length ; i++ ) { append ( array [ i ] ) ; } } return this ; }
public static string format ( long millis , string pattern , time zone time zone , locale locale ) { return format ( new date ( millis ) , pattern , time zone , locale ) ; }
public static string format ( long millis , string pattern , time zone time zone ) { return format ( new date ( millis ) , pattern , time zone , null ) ; }
public sqm expression < ? > get right hand operand ( ) { return rh operand ; }
public void warn ( object message , throwable t ) { if ( message ! = null ) { get logger ( ) . warn ( string . value of ( message ) , t ) ; } }
public boolean be warn enabled ( ) { return get logger ( ) . be warn enable ( ) ; }
public void warn ( object message , throwable exception ) { log ( level . warning , string . value of ( message ) , exception ) ; }
public boolean be function ( ) { return this . function ; }
public int get iteration count ( ) { return iteration count ; }
public int get iteration count ( ) { return iteration count ; }
public static string get element content ( final element element ) throw exception { return get element content ( element , null ) ; }
public string format ( ) { string result = message ; for ( object object : object ) { string s = result . replace first ( `` % % `` , matcher . quote replacement ( stringify ( object ) ) ) ; if ( result . equal ( s ) ) { throw new illegal state exception ( `` too many parameter `` ) ; } result = s ; } if ( result . contains ( `` % % `` ) ) { throw new illegal state exception ( `` not enough parameter `` ) ; } return result ; }
public boolean be na n ( ) { return float . be na n ( value ) ; }
public boolean be boolean ( ) { return false ; }
public double get scale ( ) { return scale ; }
public double get numerator degree of freedom ( ) { return numerator degree of freedom ; }
public void set authentication success handler ( authentication success handler success handler ) { assert . not null ( success handler , `` success handler can not be null `` ) ; this . success handler = success handler ; }
public int get upper bound byte ( ) { return this . upper bound byte ; }
public void clear ( ) { list < x s l f shape > shape = new array list < > ( get shape ( ) ) ; for ( x s l f shape shape : shape ) { remove shape ( shape ) ; } }
public long estimate key ( ) { return estimate total key ; }
public big fraction multiply ( final long l ) { return multiply ( big integer . value of ( l ) ) ; }
public big fraction add ( final int i ) { return add ( big integer . value of ( i ) ) ; }
public double distance ( vector v1 , vector v2 ) { return math . pow ( v1 . aggregate ( v2 , function . plus , function . minus abs pow ( exponent ) ) , 1 . 0 / exponent ) ; }
public static int next high power of two ( int v ) { v -- ; v |= v > > 1 ; v |= v > > 2 ; v |= v > > 4 ; v |= v > > 8 ; v |= v > > 16 ; v++ ; return v ; }
public static < t > t [ ] valid index ( t [ ] array , int index , string message , object . . . value ) { validate . not null ( array ) ; if ( index < 0 || index > = array . length ) { throw new index out of bound exception ( string . format ( message , value ) ) ; } return array ; }
public boolean be na n ( ) { return be na n ; }
public final boolean have event handler ( ) { return get event handler ( ) ! =this ; }
public state get state ( ) { return state . get ( ) . get state ( ) ; }
public boolean be empty ( ) { return name . be empty ( ) ; }
public final boolean have event handler ( ) { return get event handler ( ) ! =this ; }
public void set object i d seed ( int seed ) { little endian . put int ( _data,0 , seed ) ; }
public static double function mod ( final double b ) { return new double function ( ) { @ override public double apply ( double a ) { return a % b ; } } ; }
public synchronize void set max impl ( univariate statistic max impl ) { this . max impl = max impl ; }
public jaxb hbm one to many collection element type get one to many ( ) { return one to many ; }
public double t ( double [ ] sample1 , double [ ] sample2 ) throw illegal argument exception { check sample data ( sample1 ) ; check sample data ( sample2 ) ; return t ( stat utils . mean ( sample1 ) , stat utils . mean ( sample2 ) , stat utils . variance ( sample1 ) , stat utils . variance ( sample2 ) , sample1 . length , sample2 . length ) ; }
public double homoscedastic t ( double [ ] sample1 , double [ ] sample2 ) throw illegal argument exception { check sample data ( sample1 ) ; check sample data ( sample2 ) ; return homoscedastic t ( stat utils . mean ( sample1 ) , stat utils . mean ( sample2 ) , stat utils . variance ( sample1 ) , stat utils . variance ( sample2 ) , sample1 . length , sample2 . length ) ; }
public string get sample ( int line , int column , janitor janitor ) { string sample = null ; string text = source . get line ( line , janitor ) ; if ( text ! = null ) { if ( column > 0 ) { string marker = utility . repeat string ( `` `` , column - 1 ) + `` ^ `` ; if ( column > 40 ) { int start = column - 30 - 1 ; int end = ( column + 10 > text . length ( ) ? text . length ( ) : column + 10 - 1 ) ; sample = `` `` + text . substring ( start , end ) + utility . eol ( ) + `` `` + marker . substring ( start ) ; } else { sample = `` `` + text + utility . eol ( ) + `` `` + marker ; } } else { sample = text ; } } return sample ; }
public double t ( double [ ] sample1 , double [ ] sample2 ) throw illegal argument exception { check sample data ( sample1 ) ; check sample data ( sample2 ) ; return t ( stat utils . mean ( sample1 ) , stat utils . mean ( sample2 ) , stat utils . variance ( sample1 ) , stat utils . variance ( sample2 ) , sample1 . length , sample2 . length ) ; }
public double get scale ( ) { return scale ; }
public double get x ( ) { return x ; }
public double get a double ( ) { if ( element . size ( ) == 1 ) { return element . get ( 0 ) . get a double ( ) ; } throw new illegal state exception ( ) ; }
public static < t > consumer < t > discard consumer ( ) { return discard consumer . instance ; }
public object get result ( ) { return result ; }
public string get host ( ) { return host ; }
public io . vertx . axle . core . datagram . datagram socket create datagram socket ( ) { io . vertx . axle . core . datagram . datagram socket ret = io . vertx . axle . core . datagram . datagram socket . new instance ( delegate . create datagram socket ( ) ) ; return ret ; }
protect server socket create server socket ( final int socket port ) throw i o exception { return new server socket ( socket port ) ; }
public input stream get input stream ( ) { return input stream ; }
public int get reply ( ) throw i o exception { __get reply ( ) ; return _reply code ; }
public void set pathname ( string pathname ) { this . pathname = pathname ; this . pathname old = pathname + `` . old `` ; this . pathname new = pathname + `` . new `` ; }
public boolean noop ( ) throw i o exception { if ( get state ( ) == transaction_state ) return ( send command ( p o p3 command . noop ) == p o p3 reply . ok ) ; return false ; }
public identity verification method get verification method ( ) { return method ; }
public void set type ( string type ) { f type= type ; }
public boolean send site command ( string argument ) throw i o exception { return f t p reply . be positive completion ( site ( argument ) ) ; }
public void set site ( site site ) { this . site = site ; } // -- void set site ( site )
public void set date format ( string date format ) { super . set internal date format ( new simple date format ( date format ) ) ; }
public long get record type ( ) { return _type ; }
public string get name ( ) { return _name ; }
public collection < string > get group ( ) { return group ; }
public void set file ( p d file specification f ) { action . set item ( c o s name . f , f ) ; }
protect void update configuration ( final configuration new config ) { this . private config = new private config ( new config , this ) ; }
public string get newsgroup ( ) { return newsgroup ; }
public void set g ( int value ) { this . g = value ; }
public void set post only ( boolean post only ) { this . post only = post only ; }
public int get reply ( ) throw i o exception { __get reply ( ) ; return _reply code ; }
public int get reply ( ) throw i o exception { __get reply ( ) ; return _reply code ; }
public reader retrieve article info ( int article number ) throw i o exception { return __retrieve article info ( integer . to string ( article number ) ) ; }
public reader retrieve article body ( ) throw i o exception { return retrieve article body ( null ) ; }
public string get newsgroup ( ) { return newsgroup ; }
public string to string ( ) { return to string ( `` `` ) ; }
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public void set override time stamp ( final long stamp ) { assert . be true ( stamp == -1 || stamp > = 0 ) ; f override time stamp= stamp ; }
public string to string ( ) { return to string ( ntp time ) ; }
public long ntp value ( ) { return ntp time ; }
public double get time ( ) { return time ; }
public string to string ( ) { return to string ( `` `` ) ; }
public int noop ( ) throw i o exception { return send command ( f t p command . noop ) ; }
public string [ ] get command ( ) { return command ; }
public string [ ] get command ( ) { return command ; }
public boolean complete pending command ( ) throw i o exception { return f t p reply . be positive completion ( get reply ( ) ) ; }
public path get path ( ) { return path ; }
public void set server socket factory ( server socket factory factory ) { if ( factory == null ) _server socket factory_ = __default_server_socket_factory ; else _server socket factory_ = factory ; }
public final boolean local ( ) { return local ; }
public string get data string ( ) { if ( data file ! = null || data byte == null ) { return `` `` ; } return new string ( data byte . to byte array ( ) , standard charsets . utf_8 ) ; }
public synchronize boolean be s s l ( ) { return use s s l ; }
public int get receive buffer size ( ) { return receive buffer size ; }
protect server socket factory get server socket factory ( ) throw exception { return server socket factory . get default ( ) ; }
public list < string > support protocol ( ) { return support protocol ; }
public final boolean be enable ( stream write feature f ) { return ( _generator feature & f . map feature ( ) . get mask ( ) ) ! = 0 ; }
public void set restart offset ( long offset ) { if ( offset > = 0 ) { __restart offset = offset ; } }
public int get offset ( ) { return offset ; }
public int get buffer size ( ) { return buffer size ; }
protect string get mailbox smtp address ( ) { return this . mailbox smtp address ; }
public line string get line ( ) { return line ; }
public line string get line ( ) { return line ; }
public int get min idle ( ) { final int max idle save = get max idle ( ) ; if ( this . min idle > max idle save ) { return max idle save ; } return min idle ; }
public void set log abandon ( final boolean log abandon ) { this . log abandon = log abandon ; }
public boolean get log abandon ( ) { return this . log abandon ; }
public void set max wait ( long time ) { max wait millis = time ; }
public void set jmx name ( final string jmx name ) { this . jmx name = jmx name ; }
public void set abandon config ( final abandon config abandon config ) { if ( abandon config == null ) { this . abandon config = null ; } else { this . abandon config = new abandon config ( ) ; this . abandon config . set log abandon ( abandon config . get log abandon ( ) ) ; this . abandon config . set log writer ( abandon config . get log writer ( ) ) ; this . abandon config . set remove abandon on borrow ( abandon config . get remove abandon on borrow ( ) ) ; this . abandon config . set remove abandon on maintenance ( abandon config . get remove abandon on maintenance ( ) ) ; this . abandon config . set remove abandon timeout ( abandon config . get remove abandon timeout duration ( ) ) ; this . abandon config . set use usage tracking ( abandon config . get use usage tracking ( ) ) ; this . abandon config . set require full stack trace ( abandon config . get require full stack trace ( ) ) ; } }
public int get min idle ( ) { return this . min idle ; }
public boolean get remove abandon on borrow ( ) { return abandon config == null ? false : abandon config . get remove abandon on borrow ( ) ; }
public int remain capacity ( ) { lock . lock ( ) ; try { return capacity - count ; } finally { lock . unlock ( ) ; } }
public boolean have take waiter ( ) { lock . lock ( ) ; try { return lock . have waiter ( not empty ) ; } finally { lock . unlock ( ) ; } }
public boolean have take waiter ( ) { lock . lock ( ) ; try { return lock . have waiter ( not empty ) ; } finally { lock . unlock ( ) ; } }
public synchronize object pool < ? extend connection > get connection pool ( final string name ) throw s q l exception { final object pool < ? extend connection > pool = pool . get ( name ) ; if ( null == pool ) { throw new s q l exception ( `` pool not register : `` + name ) ; } return pool ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public void set char at ( int index , char ch ) { if ( index < 0 || index > use ) { throw new index out of bound exception ( `` `` +index ) ; } array [ index ] = ch ; }
public static pretty print indent with tab ( ) { return new pretty print ( new char [ ] { '\t ' } ) ; }
public boolean be false ( ) { return value == false ; }
public boolean can annotation target type ( ) { return false ; }
protect void resume trace ( ) { if ( trace logger . be loggable ( level . fine ) ) { trace input . set trace ( true ) ; trace output . set trace ( true ) ; } }
public void set connection ( string connection ) { this . connection = connection ; } // -- void set connection ( string )
public void add ( resource collection rc ) { resource . add ( rc ) ; }
public void set open ( boolean be open ) { pre value change ( open_property ) ; this . be open = be open ; post value change ( open_property ) ; }
public void clear ( ) { clear ( size ) ; }
public barrier new barrier ( ) { return new barrier ( ) ; }
public list < acl > get a c l ( string path , stat stat ) throw no node exception { return data tree . get a c l ( path , stat ) ; }
public static builder new builder ( ) { return new builder ( ) ; }
public state get state ( ) { return state . get ( ) . get state ( ) ; }
public static consume mutex lock create ( scope scope , operand < ? > mutex lock ) { operation builder op builder = scope . graph ( ) . op builder ( `` consume mutex lock `` , scope . make op name ( `` consume mutex lock `` ) ) ; op builder . add input ( mutex lock . a output ( ) ) ; return new consume mutex lock ( op builder . build ( ) ) ; }
public path get path ( ) { return path ; }
public boolean be queue ( ) { return queue ; }
public final void add ( byte . . . element ) { add ( element , 0 , element . length ) ; }
public double get ( time unit unit ) { return get ( 0 , unit ) ; }
public t get previous ( t current ) { return current . get previous ( ) ; }
public int get upper bound byte ( ) { return this . upper bound byte ; }
public void set ( final long value ) { this . value = value ; }
public void set ( int value ) { this . value = value ; }
public void set copy x m l ( boolean copy x m l ) { this . copy x m l = copy x m l ; }
public final void set rule ( int rule ) { this . rule = rule ; }
public boolean contains ( object value ) { if ( value == null ) { throw new null pointer exception ( ) ; } entry tab [ ] = table ; for ( int i = tab . length ; i -- > 0 ; ) { for ( entry e = tab [ i ] ; e ! = null ; e = e . next ) { if ( e . value . equal ( value ) ) { return true ; } } } return false ; }
public collection < v > value ( ) { return this . map . value ( ) ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public static map synchronize map ( map map ) { return collection . synchronize map ( map ) ; }
protect map create map ( ) { return collection . synchronize map ( new hash map ( ) ) ; }
public static string any string ( ) { return report matcher ( any . any ) . return string ( ) ; }
public static double geq ( double value ) { return report matcher ( new great or equal < double > ( value ) ) . return zero ( ) ; }
public static int lt ( int value ) { report matcher ( new less than ( value ) ) ; return 0 ; }
public static int lt ( int value ) { report matcher ( new less than ( value ) ) ; return 0 ; }
public static int lt ( int value ) { report matcher ( new less than ( value ) ) ; return 0 ; }
public static byte lt ( byte value ) { report matcher ( new less than ( value ) ) ; return 0 ; }
public static < t > matcher < t > be a ( class < ? > type ) { return be ( be instance of . < t > instance of ( type ) ) ; }
public static int or ( int first , int second ) { last control . report or ( 2 ) ; return first ; }
public static float or ( float first , float second ) { last control . report or ( 2 ) ; return 0 ; }
public byte [ ] get byte ( ) { return byte ; }
public static boolean eq ( boolean value ) { return report matcher ( new equal ( value ) ) . return false ( ) ; }
public string get regex ( ) { return regex ; }
public static void verify zero interaction ( object . . . mock ) { mockito_core . verify no more interaction ( mock ) ; }
public boolean can annotation target type ( ) { return false ; }
public annotation get annotation ( string type ) { annotation [ ] annotation = get annotation ( ) ; for ( int i = 0 ; i < annotation . length ; i++ ) { if ( annotation [ i ] . get type name ( ) . equal ( type ) ) return annotation [ i ] ; } return null ; }
public void set declaration ( body declaration declaration ) { f declaration= declaration ; }
public int get offset ( ) { return offset ; }
public string get include ( ) { return include ; }
public int get shard request index ( ) { return shard request index ; }
public void set level ( int level ) { this . level = level ; }
public version version ( ) { return version ; }
public setting setting ( ) { return setting ; }
public static string get jvm metric name ( ) { return jvm metric name ; }
public static debuggable thread pool executor create cache threadpool with max size ( string thread pool name ) { return new debuggable thread pool executor ( 0 , integer . max_value , 60l , time unit . second , new synchronous queue < runnable > ( ) , new name thread factory ( thread pool name ) ) ; }
public final long completion ( ) { return completion ; }
public void set description ( string description ) { this . description = description ; }
public void set type ( int type ) { this . type = type ; }
public string [ ] get command ( ) { return command ; }
public close index request builder set index option ( index option index option ) { request . index option ( index option ) ; return this ; }
public string [ ] index ( ) { return index ; }
public void set snapshot ( repository policy snapshot ) { this . snapshots = snapshot ; } // -- void set snapshot ( repository policy )
public boolean be match ( readable partial partial ) { if ( partial == null ) { throw new illegal argument exception ( `` the partial must not be null `` ) ; } for ( int i = 0 ; i < i type . length ; i++ ) { int value = partial . get ( i type [ i ] ) ; if ( value ! = i value [ i ] ) { return false ; } } return true ; }
public boolean ignore unavailable ( ) { return ignore unavailable ; }
public snapshot status request ignore unavailable ( boolean ignore unavailable ) { this . ignore unavailable = ignore unavailable ; return this ; }
public void set incremental authorization type ( final list < client type > incremental authz type ) { this . incremental authz type = incremental authz type ; }
public shard rout get shard routing ( ) { return this . shard routing ; }
public open index request builder set index option ( index option index option ) { request . index option ( index option ) ; return this ; }
public class < ? > provide type ( ) { return provide type ; }
public setting get setting ( ) { return this . setting ; }
public map get setting ( ) { return setting ; }
public update setting request setting ( string source , x content type x content type ) { this . setting = setting . builder ( ) . load from source ( source , x content type ) . build ( ) ; return this ; }
public string [ ] index ( ) { return index ; }
public boolean be force ( ) { return force ; }
public void set index ( int index ) { this . index = index ; }
public close index request builder set index option ( index option index option ) { request . index option ( index option ) ; return this ; }
public void set user detail service ( user detail service user detail service ) { this . user detail service = user detail service ; }
public void add max index size condition ( byte size value size ) { max size condition max size condition = new max size condition ( size ) ; if ( this . condition . contains key ( max size condition . name ) ) { throw new illegal argument exception ( max size condition + `` condition be already set `` ) ; } this . condition . put ( max size condition . name , max size condition ) ; }
public void add max index doc condition ( long num doc ) { max doc condition max docs condition = new max doc condition ( num doc ) ; if ( this . condition . contains key ( max doc condition . name ) ) { throw new illegal argument exception ( max doc condition . name + `` condition be already set `` ) ; } this . condition . put ( max doc condition . name , max docs condition ) ; }
public create index request setting ( map < string , ? > source ) { this . setting = setting . builder ( ) . load from map ( source ) . build ( ) ; return this ; }
public search shard target get shard ( ) { return shard ; }
public list < shard rout > all shard ( string index ) { list < shard rout > shard = new array list < > ( ) ; index rout table index rout table = index ( index ) ; if ( index rout table == null ) { throw new index not find exception ( index ) ; } for ( index shard rout table index shard rout table : index rout table ) { for ( shard rout shard routing : index shard rout table ) { shard . add ( shard routing ) ; } } return shard ; }
public string get name ( ) { return ( this . name ) ; }
public query get query ( ) { return query ; }
public backoff strategy get backoff strategy ( ) { return backoff strategy ; }
public request < ? > get request ( ) { return request ; }
public boolean all primary shard active ( ) { return primary shard active ( ) == shard ( ) . size ( ) ; }
public double get time ( ) { return time ; }
public static bulk request bulk request ( ) { return new bulk request ( ) ; }
public string get index ( ) { return index ; }
public field set set field ( field field ) { return set field ( new field description . for loaded field ( field ) ) ; }
public cancellable refresh async ( refresh request refresh request , request option option , action listener < refresh response > listener ) { return rest high level client . perform request async and parse entity ( refresh request , indices request converter : : refresh , option , refresh response : : from x content , listener , empty set ( ) ) ; }
public long get version ( ) { return this . version ; }
public source get source ( ) { return source ; }
public string get alias ( ) { return alias ; }
public void set verbose ( boolean verbose ) { this . verbose = verbose ; }
public update request fetch source ( boolean fetch source ) { fetch source context context = this . fetch source context == null ? fetch source context . fetch_source : this . fetch source context ; this . fetch source context = new fetch source context ( fetch source , context . include ( ) , context . excludes ( ) ) ; return this ; }
protect builder create builder ( ) { final builder builder = get builder ( ) ; return builder ! = null ? builder : new builder ( ) ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public void set timeout ( time value timeout ) { this . timeout = timeout ; }
public get mapping request local ( boolean local ) { this . local = local ; return this ; }
public int get phase ( ) { return this . phase ; }
public string id ( ) { return id ; }
public void set id ( string id ) { this . id = id ; }
public void set realtime ( boolean realtime ) { this . realtime = realtime ; }
public put repository request type ( string type ) { this . type = type ; return this ; }
public update request fetch source ( fetch source context context ) { this . fetch source context = context ; return this ; }
public update request fetch source ( boolean fetch source ) { fetch source context context = this . fetch source context == null ? fetch source context . fetch_source : this . fetch source context ; this . fetch source context = new fetch source context ( fetch source , context . include ( ) , context . excludes ( ) ) ; return this ; }
public string get doc ( ) { return doc ; }
public request < ? > get request ( ) { return request ; }
public void print stack trace ( print writer s ) { super . print stack trace ( s ) ; }
public plain action future < bulk response > with backoff ( bi consumer < bulk request , action listener < bulk response > > consumer , bulk request bulk request ) { plain action future < bulk response > future = plain action future . new future ( ) ; with backoff ( consumer , bulk request , future ) ; return future ; }
public int get shard request index ( ) { return shard request index ; }
public cancellable update alias async ( index aliases request index aliases request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( index aliases request , indices request converter : : update alias , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public boolean force ( ) { return force ; }
public boolean be boolean ( ) { return false ; }
public final byte ref term ( ) { return term ; }
public string [ ] get index ( ) { return index ; }
public string get name ( ) { return name ; }
public string get expression ( ) { return expression ; }
public static index aliases request index alias request ( ) { return new index aliases request ( ) ; }
public string [ ] get concrete all open index ( ) { return all open index ; }
public string [ ] get concrete all index ( ) { return all index ; }
public string [ ] get concrete all open index ( ) { return all open index ; }
public search shard target get shard ( ) { return shard ; }
public node get node ( ) { return node ; }
public remote repository get repository ( ) { return repository ; }
public node get node ( ) { return node ; }
protect static list < node allocation result > build decision for all node ( shard rout shard , rout allocation allocation ) { list < node allocation result > result = new array list < > ( ) ; for ( rout node node : allocation . rout node ( ) ) { decision decision = allocation . deciders ( ) . can allocate ( shard , node , allocation ) ; result . add ( new node allocation result ( node . node ( ) , null , decision ) ) ; } return result ; }
public search shard target get shard ( ) { return shard ; }
public boolean get mark a read ( ) { return this . mark a read ; }
public search shard target get shard ( ) { return shard ; }
public int primary shard active ( ) { int counter = 0 ; for ( index shard rout table shard rout table : this ) { if ( shard rout table . primary shard ( ) . active ( ) ) { counter++ ; } } return counter ; }
public list < shard rout > all shard ( string index ) { list < shard rout > shard = new array list < > ( ) ; index rout table index rout table = index ( index ) ; if ( index rout table == null ) { throw new index not find exception ( index ) ; } for ( index shard rout table index shard rout table : index rout table ) { for ( shard rout shard routing : index shard rout table ) { shard . add ( shard routing ) ; } } return shard ; }
public list < shard rout > all shard ( string index ) { list < shard rout > shard = new array list < > ( ) ; index rout table index rout table = index ( index ) ; if ( index rout table == null ) { throw new index not find exception ( index ) ; } for ( index shard rout table index shard rout table : index rout table ) { for ( shard rout shard routing : index shard rout table ) { shard . add ( shard routing ) ; } } return shard ; }
public int primary shard active ( ) { int counter = 0 ; for ( index shard rout table shard rout table : this ) { if ( shard rout table . primary shard ( ) . active ( ) ) { counter++ ; } } return counter ; }
public int get shard id ( ) { return shard id ; }
public string get reason ( ) { return reason ; }
public synchronize cluster state [ ] pending cluster state ( ) { array list < cluster state > state = new array list < > ( ) ; for ( cluster state context context : pending state ) { state . add ( context . state ) ; } return state . to array ( new cluster state [ state . size ( ) ] ) ; }
public void set task executor ( async task executor task executor ) { this . task executor = task executor ; }
public v put ( k key , v value ) { return put ( key , value , false ) ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public static string uncompress string ( byte [ ] input ) throw i o exception { try { return uncompress string ( input , `` utf-8 `` ) ; } catch ( unsupported encode exception e ) { throw new illegal state exception ( `` utf-8 decoder be not find `` ) ; } }
public object get ( string field name ) { return get ( schema ( ) . get field ( field name ) ) ; }
public geo distance sort builder point ( double lat , double lon ) { point . add ( new geo point ( lat , lon ) ) ; return this ; }
public void remove all parameter ( ) { this . parameter . clear ( ) ; }
public void increment ( ) { value++ ; }
protect void populate channel ( final channel channel , final element e channel ) { final string title = channel . get title ( ) ; if ( title ! = null ) { e channel . add content ( generate simple element ( `` title `` , title ) ) ; } final string link = channel . get link ( ) ; if ( link ! = null ) { e channel . add content ( generate simple element ( `` link `` , link ) ) ; } final string description = channel . get description ( ) ; if ( description ! = null ) { e channel . add content ( generate simple element ( `` description `` , description ) ) ; } }
public path get path ( ) { return path ; }
public version get version ( ) { return version ; }
public final void write v int ( int i ) throw i o exception { while ( ( i & ~0x7 f ) ! = 0 ) { write byte ( ( byte ) ( ( i & 0x7f ) | 0x80 ) ) ; i > > > = 7 ; } write byte ( ( byte ) i ) ; }
public final void write v int ( int i ) throw i o exception { while ( ( i & ~0x7 f ) ! = 0 ) { write byte ( ( byte ) ( ( i & 0x7f ) | 0x80 ) ) ; i > > > = 7 ; } write byte ( ( byte ) i ) ; }
public static < e extend enum < e > > boolean be valid enum ( class < e > enum class , string enum name ) { if ( enum name == null ) { return false ; } try { enum . value of ( enum class , enum name ) ; return true ; } catch ( illegal argument exception ex ) { return false ; } }
public boolean be cluster ( ) { return event bus option . be cluster ( ) ; }
public int hash code ( ) { return to string ( ) . hash code ( ) ; }
public boolean might match non nest doc ( query query , string nested path ) { if ( query instanceof constant score query ) { return might match non nest doc ( ( ( constant score query ) query ) . get query ( ) , nested path ) ; } else if ( query instanceof boost query ) { return might match non nest doc ( ( ( boost query ) query ) . get query ( ) , nested path ) ; } else if ( query instanceof match all docs query ) { return true ; } else if ( query instanceof match no docs query ) { return false ; } else if ( query instanceof term query ) { return might match non nest doc ( ( ( term query ) query ) . get term ( ) . field ( ) , nested path ) ; } else if ( query instanceof term in set query ) { prefix cod term term = ( ( term in set query ) query ) . get term data ( ) ; if ( term . size ( ) > 0 ) { prefix cod term . term iterator it = term . iterator ( ) ; it . next ( ) ; return might match non nest doc ( it . field ( ) , nested path ) ; } else { return false ; } } else if ( query instanceof point range query ) { return might match non nest doc ( ( ( point range query ) query ) . get field ( ) , nested path ) ; } else if ( query instanceof index or doc value query ) { return might match non nest doc ( ( ( index or doc value query ) query ) . get index query ( ) , nested path ) ; } else if ( query instanceof boolean query ) { final boolean query bq = ( boolean query ) query ; final boolean have require clause = bq . clause ( ) . stream ( ) . any match ( boolean clause : : be require ) ; if ( have require clause ) { return bq . clause ( ) . stream ( ) . filter ( boolean clause : : be require ) . map ( boolean clause : : get query ) . all match ( q - > might match non nest doc ( q , nested path ) ) ; } else { return bq . clause ( ) . stream ( ) . filter ( c - > c . get occur ( ) == occur . should ) . map ( boolean clause : : get query ) . any match ( q - > might match non nest doc ( q , nested path ) ) ; } } else { return true ; } }
public builder < t > set direct address max oversizing factor ( float factor ) { direct address max oversizing factor = factor ; return this ; }
public analyzer get analyzer ( ) { return analyzer ; }
public string get doc ( ) { return doc ; }
public string get short description ( ) { string builder sb = new string builder ( ) ; sb . append ( `` session= [ `` ) . append ( this . session id ) . append ( `` ] ; `` ) ; sb . append ( `` user= [ `` ) . append ( this . user name ) . append ( `` ] ; `` ) ; return sb . to string ( ) ; }
public string get address ( ) { return this . address ; } // -- string get address ( )
public inet address get address ( ) { return address ; }
public inet address get address ( ) { return address ; }
public string get path ( ) { return path ; }
public final w get writer setting ( ) { validate writer setting ( ) ; return writer setting ; }
public setting setting ( ) { return setting ; }
public string get content ( ) { if ( char == null ) { return null ; } return new string ( char ) ; }
public setting get setting ( ) { return this . setting ; }
public void end test ( test test ) { f model . add run test ( test ) ; fire test change ( test , false ) ; }
public date time field month of year ( ) { return unsupported date time field . get instance ( date time field type . month of year ( ) , month ( ) ) ; }
public double to meter ( double distance ) { return convert ( distance , this , distance unit . meter ) ; }
public geo distance query builder distance ( string distance ) { return distance ( distance , distance unit . default ) ; }
public void previous page ( ) { if ( ! be first page ( ) ) { this . page -- ; } }
synchronize public final slot register slot ( int slot idx , extend block id block id ) throw invalid request exception { if ( slot idx < 0 ) { throw new invalid request exception ( this + `` : invalid negative slot `` + `` index `` + slot idx ) ; } if ( slot idx > = slot . length ) { throw new invalid request exception ( this + `` : invalid slot `` + `` index `` + slot idx ) ; } if ( allocated slot . get ( slot idx ) ) { throw new invalid request exception ( this + `` : slot `` + slot idx + `` be already in use . `` ) ; } slot slot = new slot ( calculate slot address ( slot idx ) , block id ) ; if ( ! slot . be valid ( ) ) { throw new invalid request exception ( this + `` : slot `` + slot idx + `` be not mark a valid . `` ) ; } slot [ slot idx ] = slot ; allocate slot . set ( slot idx , true ) ; if ( log . be trace enable ( ) ) { log . trace ( this + `` : register slot `` + slot idx + `` : allocate slots= `` + allocated slot + string utils . get stack trace ( thread . current thread ( ) ) ) ; } return slot ; }
public double get double l e ( int index ) { return double . long bit to double ( get long l e ( index ) ) ; }
public static boolean be not empty ( int [ ] array ) { return ( array ! = null & & array . length ! = 0 ) ; }
public schedule executor service get schedule executor ( ) throw illegal state exception { assert . state ( this . schedule executor ! = null , `` thread pool task scheduler not initialize `` ) ; return this . schedule executor ; }
public exception get exception ( ) { return e ; }
public int get client queue size ( ) { return client queue size ; }
public store field context store field ( ) { return store field context ; }
public equal builder set test transient ( final boolean test transient ) { this . test transient = test transient ; return this ; }
public object get local context ( ) { return local context ; }
public io . vertx . reactivex . circuitbreaker . circuit breaker half open handler ( handler < void > handler ) { delegate . half open handler ( handler ) ; return this ; }
public list < node > get node ( ) { return node ; }
public void set timeout ( time value timeout ) { this . timeout = timeout ; }
public list get node set ( ) { return this . node set ; }
public cluster state state ( ) { assert assert not call from cluster state applier ( `` the applied cluster state be not yet available `` ) ; cluster state cluster state = this . state . get ( ) ; assert cluster state ! = null : `` initial cluster state not set yet `` ; return cluster state ; }
public collection < metadata > get metadata ( ) { return metadata ; }
public throwable get root cause ( ) { return get cause ( ) ; }
public x content builder to x content ( x content builder builder , params builder params ) throw i o exception { builder . start object ( ) ; string content type = option == null ? null : option . get ( content_type_option ) ; if ( type == script type . inline ) { if ( content type ! = null & & builder . content type ( ) . medium type ( ) . equal ( content type ) ) { try ( input stream stream = new byte array ( id or code ) . stream input ( ) ) { builder . raw field ( source_parse_field . get preferred name ( ) , stream ) ; } } else { builder . field ( source_parse_field . get preferred name ( ) , id or code ) ; } } else { builder . field ( `` id `` , id or code ) ; } if ( lang ! = null ) { builder . field ( lang_parse_field . get preferred name ( ) , lang ) ; } if ( option ! = null & & option . be empty ( ) == false ) { builder . field ( options_parse_field . get preferred name ( ) , option ) ; } if ( params . be empty ( ) == false ) { builder . field ( params_parse_field . get preferred name ( ) , params ) ; } builder . end object ( ) ; return builder ; }
public string get file path ( ) { return file path ; }
public boolean accept ( final file file ) { if ( file . be directory ( ) ) { final file [ ] file = file . list file ( ) ; return i o utils . length ( file ) == 0 ; } return file . length ( ) == 0 ; }
public void set file ( file file ) { this . file = file ; }
public path get path ( ) { return path ; }
public list < node allocation result > sort node decision ( list < node allocation result > node decision ) { return collection . unmodifiable list ( node decision . stream ( ) . sort ( ) . collect ( collector . to list ( ) ) ) ; }
public location get location ( ) { return this . location ; }
public index replace ( index metadata index ) { return without ( index . name ) . with ( index ) ; }
public setting get setting ( ) { return this . setting ; }
public analyzer get analyzer ( ) { return analyzer ; }
public analysis limit get analysis limit ( ) { return analysis limit ; }
public long get pending num doc ( ) { return pending num doc . get ( ) ; }
public void set commit name ( string [ ] commit name ) { this . commit name = commit name ; }
public long get timestamp ( ) { return timestamp ; }
public index setting get index setting ( ) { return index setting ; }
public void set max in memory size ( int byte count ) { this . line decoder . set max in memory size ( byte count ) ; }
public void update numeric doc value ( term term , string field , long value ) throw i o exception { ensure open ( ) ; if ( ! global field number map . contains ( field , doc value type . numeric ) ) { throw new illegal argument exception ( `` can only update exist numeric-docvalues field ! `` ) ; } try { if ( doc writer . update numeric doc value ( term , field , value ) ) { process event ( true , false ) ; } } catch ( out of memory error oom ) { handle o o m ( oom , `` update numeric doc value `` ) ; } }
public int get threshold ( ) { return threshold ; }
public int get collapse line count ( ) { return collapse ? get line count ( ) : child collapse line count ; }
public boolean be ( string property , object value ) { throw new unsupported operation exception ( ) ; }
public mapping get mapping ( ) { return mapping ; }
public void set exception mapping ( property mapping ) { this . exception mapping = mapping ; }
public string get id ( ) { return id ; }
public void set maximum depth ( int depth ) { this . max depth = depth ; }
public list < filter > get filter ( ) { return array . a list ( filter ) ; }
public string minimum should match ( ) { return this . minimum should match ; }
public static boolean max length ( string value , int max , int line end length ) { int adjust amount = adjust for line end ( value , line end length ) ; return ( ( value . length ( ) + adjust amount ) < = max ) ; }
public field capability request field ( string . . . field ) { if ( field == null || field . length == 0 ) { throw new illegal argument exception ( `` specify field ca n't be null or empty `` ) ; } set < string > field set = new hash set < > ( arrays . a list ( field ) ) ; this . field = field set . to array ( new string [ 0 ] ) ; return this ; }
public boolean be function ( ) { return this . function ; }
public geo distance geo distance ( ) { return this . geo distance ; }
public geo distance geo distance ( ) { return this . geo distance ; }
public geo distance query builder distance ( string distance ) { return distance ( distance , distance unit . default ) ; }
public method get method ( ) { return this . method ; }
public bool query builder minimum should match ( string minimum should match ) { this . minimum should match = minimum should match ; return this ; }
public int get fuzzy prefix length ( ) { return fuzzy prefix length ; }
public query string query builder analyzer ( string analyzer ) { this . analyzer = analyzer ; return this ; }
public void add text ( string text ) { this . text = text ; }
public combine field query builder field ( string field ) { if ( string . be empty ( field ) ) { throw new illegal argument exception ( `` supply field be null or empty . `` ) ; } this . field and boost . put ( field , abstract query builder . default_boost ) ; return this ; }
protect query new phrase query ( string text , int slop ) { boolean query . builder bq = new boolean query . builder ( ) ; for ( map . entry < string , float > entry : weight . entry set ( ) ) { query q = create phrase query ( entry . get key ( ) , text , slop ) ; if ( q ! = null ) { float boost = entry . get value ( ) ; if ( boost ! = 1f ) { q = new boost query ( q , boost ) ; } bq . add ( q , boolean clause . occur . should ) ; } } return simplify ( bq . build ( ) ) ; }
public void set compliance ( string input ) { string ignore = cmd . add option ( null , compliance_inputs , input ) ; if ( null ! = ignore ) { ignore ( ignore ) ; } }
public void set boolean property ( string property name , boolean bool ) { string value = null ; if ( bool ! = null ) { value = bool . boolean value ( ) ? `` true `` : `` false `` ; } set text property ( property name , value ) ; }
public geo distance query builder distance ( string distance ) { return distance ( distance , distance unit . default ) ; }
public void set query string ( string query string ) { this . query string = query string ; }
public query builder query ( ) { return query ; }
public query builder query ( ) { return query ; }
public string get script ( ) { return script ; }
public void set bound box ( bound box b box ) { bound box = b box ; }
public match query builder analyzer ( string analyzer ) { this . analyzer = analyzer ; return this ; }
public int get max determinized state ( ) { return max determinized state ; }
public similarity get similarity ( searcher searcher ) { return searcher . get similarity ( ) ; }
public string get script ( ) { return script ; }
public final boolean be cacheable ( ) { return true ; }
public search shard target get shard ( ) { return shard ; }
public static index shard store request index shard store request ( string . . . index ) { return new index shard store request ( index ) ; }
public index setting get index setting ( ) { return index setting ; }
public string quote field suffix ( ) { return setting . quote field suffix ( ) ; }
public simple query string builder quote field suffix ( string suffix ) { setting . quote field suffix ( suffix ) ; return this ; }
public void set target ( string target to add ) { if ( target to add . equal ( `` `` ) ) { throw new build exception ( `` target attribute must not be empty `` ) ; } target . add ( target to add ) ; target attribute set = true ; }
public final string get reason cancel ( ) { return reason ; }
public void set index ( int index ) { this . index = index ; }
public pipeline configuration get pipeline configuration ( ) { return pipeline config ; }
public query get query ( ) { return query ; }
public void write to ( final stream output out ) throw i o exception { retention lease . write to ( out ) ; }
public source get source ( ) { return source ; }
public void write ( data output out ) throw i o exception { out . write ( code ) ; }
public int get index along segment ( int segment index , int int index ) { compute int line index ( ) ; return int line index [ segment index ] [ int index ] ; }
protect void checkpoint ( ) { checkpoint = internal buffer ( ) . reader index ( ) ; }
public long size in byte ( ) { return cache . size in byte ( ) ; }
public string get descriptor ( ) { return descriptor ; }
public search shard target get shard ( ) { return shard ; }
public void set recovery listener ( boolean recovery listener ) { this . recovery listener = recovery listener ; }
public string get file name ( ) { return file name ; }
public version get version ( ) { return this . version ; }
public final string get template ( ) { return template ; }
public cluster state state ( ) { assert assert not call from cluster state applier ( `` the applied cluster state be not yet available `` ) ; cluster state cluster state = this . state . get ( ) ; assert cluster state ! = null : `` initial cluster state not set yet `` ; return cluster state ; }
public collection type construct raw collection type ( class < ? extend collection > collection class ) { return construct collection type ( collection class , unknown type ( ) ) ; }
public void set classname ( string classname ) { this . classname = classname ; }
public string get version ( ) { return version ; }
public static blob generate proxy ( byte [ ] bytes ) { return ( blob ) proxy . new proxy instance ( get proxy class loader ( ) , proxy_interfaces , new blob proxy ( byte ) ) ; }
public handler [ ] get and set handler ( final handler [ ] handler ) throw security exception { final handler [ ] safe handler = handler . clone ( ) ; for ( handler handler : safe handler ) { if ( handler == null ) { throw new illegal argument exception ( `` a handler be null `` ) ; } } return logger node . set handler ( safe handler ) ; }
public http request [ ] retrieve record request ( http request http request ) { string record request = retrieve record request ( http request , format . json ) ; if ( string utils . be not empty ( recorded request ) & & ! record request . equal ( `` [ ] `` ) ) { return http request serializer . deserialize array ( record request ) ; } else { return new http request [ 0 ] ; } }
public void set max score ( float max score ) { this . max score = max score ; }
protect object resolve specify lookup key ( object lookup key ) { return lookup key ; }
protect builder create builder ( ) { final builder builder = get builder ( ) ; return builder ! = null ? builder : new builder ( ) ; }
public string get name ( ) { return name ; }
public void set d pipeline ( string pipeline name ) { this . get destination ( ) . set pipeline ( pipeline name ) ; }
public final pipeline aggregator create ( ) { pipeline aggregator aggregator = create internal ( this . metadata ) ; return aggregator ; }
public string get script ( ) { return script ; }
public object get ( char sequence key ) { final int bucket = normal completion . get bucket ( key ) ; return bucket == -1 ? null : long . value of ( bucket ) ; }
public long validate ( string value ) { return ( long ) parse ( value , ( string ) null , ( locale ) null ) ; }
public boolean keyed ( ) { return key ; }
public int get offset ( ) { return this . offset ; }
public int get range ( ) { return i range ; }
public string get doc ( ) { return doc ; }
public long count ( ) { return count ; }
public void set mode ( final string mode ) { this . mode = string . to lower case ( mode ) ; if ( mode == null || ! mode . contains ( mode ) ) { throw new illegal argument exception ( `` invalid mode [ `` + mode + `` ] `` ) ; } }
public aggregator [ ] create sub aggregator ( aggregator parent , cardinality upper bound cardinality ) throw i o exception { aggregator [ ] aggregator = new aggregator [ count aggregator ( ) ] ; for ( int i = 0 ; i < factory . length ; ++i ) { aggregator [ i ] = context . profile if enable ( factory [ i ] . create ( parent , cardinality ) ) ; } return aggregator ; }
public boolean be true ( ) { return value == true ; }
public boolean be reduce ( ) { return reduce ; }
public static boolean be key desc ( bucket order order ) { return be order ( order , key_desc ) ; }
public static boolean be count desc ( bucket order order ) { return be order ( order , count_desc ) ; }
public int noop ( ) throw i o exception { return send command ( f t p command . noop ) ; }
public string key ( ) { return key ; }
public boolean keyed ( ) { return key ; }
public boolean use compression ( ) { return compression ; }
public int size ( ) { return size ; }
public store get store ( ) { return store ; }
public explain data frame analytics response explain data frame analytics ( explain data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : explain data frame analytics , option , explain data frame analytics response : : from x content , collection . empty set ( ) ) ; }
public aggregator [ ] create sub aggregator ( aggregator parent , cardinality upper bound cardinality ) throw i o exception { aggregator [ ] aggregator = new aggregator [ count aggregator ( ) ] ; for ( int i = 0 ; i < factory . length ; ++i ) { aggregator [ i ] = context . profile if enable ( factory [ i ] . create ( parent , cardinality ) ) ; } return aggregator ; }
public int get window ( ) { return window ; }
public void set tree model ( int model ) { tree model = model ; }
public int get int value ( ) { return 0 ; }
public int window ( ) { return window ; }
public int window ( ) { return window ; }
public static double gamma ( double alpha , double beta , double x ) { if ( x < 0 . 0 ) { return 0 . 0 ; } return gamma . incomplete gamma ( alpha , beta * x ) ; }
public int [ ] get value ( ) { int [ ] result = new int [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get value ( i ) ; } return result ; }
public collection < pipeline aggregation builder > get pipeline aggregation ( ) { return factory builder . get pipeline aggregator factory ( ) ; }
public search source builder shallow copy ( ) { return shallow copy ( query builder , post query builder , aggregation , slice builder , sort , rescore builder , highlight builder ) ; }
public search source builder rewrite ( query rewrite context context ) throw i o exception { assert ( this . equal ( shallow copy ( query builder , post query builder , aggregation , slice builder , sort , rescore builder , highlight builder ) ) ) ; query builder query builder = null ; if ( this . query builder ! = null ) { query builder = this . query builder . rewrite ( context ) ; } query builder post query builder = null ; if ( this . post query builder ! = null ) { post query builder = this . post query builder . rewrite ( context ) ; } aggregator factory . builder aggregation = null ; if ( this . aggregation ! = null ) { aggregation = this . aggregation . rewrite ( context ) ; } list < sort builder < ? > > sort = rewriteable . rewrite ( this . sort , context ) ; list < rescorer builder > rescore builder = rewriteable . rewrite ( this . rescore builder , context ) ; highlight builder highlight builder = this . highlight builder ; if ( highlight builder ! = null ) { highlight builder = this . highlight builder . rewrite ( context ) ; } boolean rewritten = query builder ! = this . query builder || post query builder ! = this . post query builder || aggregation ! = this . aggregation || rescore builder ! = this . rescore builder || sort ! = this . sort || this . highlight builder ! = highlight builder ; if ( rewrite ) { return shallow copy ( query builder , post query builder , aggregation , this . slice builder , sort , rescore builder , highlight builder ) ; } return this ; }
public long long value ( ) { return value ; }
public int get shard request index ( ) { return shard request index ; }
public update request fetch source ( boolean fetch source ) { fetch source context context = this . fetch source context == null ? fetch source context . fetch_source : this . fetch source context ; this . fetch source context = new fetch source context ( fetch source , context . include ( ) , context . excludes ( ) ) ; return this ; }
public version version ( ) { return version ; }
public object get fetch value ( ) { return fetch value ; }
public void set allow no match ( boolean allow no match ) { this . allow no match = allow no match ; }
public < t > t get context object ( class < t > type ) { return ( t ) reload context . get ( type ) ; }
public json value get value ( string path ) { return this . value . get ( this . path to property ( path ) ) ; }
public void start rewrite time ( ) { ( ( internal query profile tree ) profile tree ) . start rewrite time ( ) ; }
public void start rewrite time ( ) { assert rewrite scratch == 0 ; rewrite scratch = system . nano time ( ) ; }
public static verification collector collector ( ) { return new verification collector impl ( ) ; }
protect void validate profile ( string profile ) { if ( ! string utils . have text ( profile ) ) { throw new illegal argument exception ( `` invalid profile [ `` + profile + `` ] : must contain text `` ) ; } if ( profile . char at ( 0 ) == ' ! ' ) { throw new illegal argument exception ( `` invalid profile [ `` + profile + `` ] : must not begin with ! operator `` ) ; } }
public int get window size ( ) { return window size ; }
public long version ( ) { return version ; }
public int get shard id ( ) { return shard id ; }
public request < ? > get request ( ) { return request ; }
public json pointer append ( final int index ) { return append ( integer . to string ( index ) ) ; }
public static distance predicate create distance predicate ( double lat , double lon , double radius meter ) { final rectangle bound box = rectangle . from point distance ( lat , lon , radius meter ) ; final double axis lat = rectangle . axis lat ( lat , radius meter ) ; final double distance sort key = geo utils . distance query sort key ( radius meter ) ; final function < rectangle , relation > box to relation = box - > geo utils . relate ( box . min lat , box . max lat , box . min lon , box . max lon , lat , lon , distance sort key , axis lat ) ; final grid sub box = create sub box ( bound box . min lat , bound box . max lat , bound box . min lon , bound box . max lon , box to relation ) ; return new distance predicate ( sub box . lat shift , sub box . lon shift , sub box . lat base , sub box . lon base , sub box . max lat delta , sub box . max lon delta , sub box . relation , lat , lon , distance sort key ) ; }
public list < query builder > filter ( ) { return this . filter clause ; }
public string get regex ( ) { return regex ; }
public void set fuzzy min sim ( float fuzzy min sim ) { query config handler config = get query config handler ( ) ; fuzzy config fuzzy config = config . get ( configuration key . fuzzy_config ) ; if ( fuzzy config == null ) { fuzzy config = new fuzzy config ( ) ; config . set ( configuration key . fuzzy_config , fuzzy config ) ; } fuzzy config . set min similarity ( fuzzy min sim ) ; }
public string get prefix ( ) { return prefix ; }
public int size ( ) { return size ; }
public void set tree model ( int model ) { tree model = model ; }
public string get query ( ) { return this . query ; }
public final byte ref term ( ) { return term ; }
public text edit [ ] get text edits ( ) { return f text edit group . get text edits ( ) ; }
public restore snapshot response mount snapshot ( final mount snapshot request request , final request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , searchable snapshot request converter : : mount snapshot , option , restore snapshot response : : from x content , collection . empty set ( ) ) ; }
public json parser create parser ( char [ ] content ) throw i o exception { return create parser ( content , 0 , content . length ) ; }
public string get reason cancel ( ) { return status . get reason cancel ( ) ; }
public string get description ( ) { return description ; }
public task type get task type ( ) { return task id . get task type ( ) ; }
public string get status ( ) { return this . status ; } // -- string get status ( )
public status get status ( ) { return null ; }
public static string get cluster name ( ) { return database descriptor . get cluster name ( ) ; }
public static < k , v > immutable map parameter < k , v > of ( k k0 , v v0 , k k1 , v v1 , k k2 , v v2 ) { map < k , v > map = new hash map < k , v > ( ) ; put and warn duplicate key ( map , k0 , v0 ) ; put and warn duplicate key ( map , k1 , v1 ) ; put and warn duplicate key ( map , k2 , v2 ) ; return new immutable map parameter < k , v > ( map ) ; }
public static < a > a create container ( class < a > type ) { string class path = system . get property ( `` java . class . path `` ) ; string [ ] path = class path . split ( file . path separator ) ; return create container ( type , path ) ; }
public int get limit ( ) { synchronize ( buffer ) { return limit ; } }
public method get method ( ) { return method ; }
public double get double ( object key ) { try { return double . value of ( ( string ) get ( key ) ) ; } catch ( exception e ) { return null ; } }
public void fail ( string failure message ) { assertion error error = failure . instance ( ) . failure ( failure message ) ; proxy . collect error ( error ) ; }
public request < ? > get request ( ) { return request ; }
public acknowledge response put pipeline ( put pipeline request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , ingest request converter : : put pipeline , option , acknowledge response : : from x content , empty set ( ) ) ; }
public acknowledge response delete license ( delete license request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , license request converter : : delete license , option , acknowledge response : : from x content , empty set ( ) ) ; }
public void set total count ( int total count ) { this . total count = total count ; }
public data buffer get payload ( ) { return this . payload ; }
public boolean realtime ( ) { return this . realtime ; }
public final void add term freq vector ( term freq vector vector ) throw i o exception { if ( ! be document open ( ) ) throw new illegal state exception ( `` can not add term vector when document be not open `` ) ; if ( be field open ( ) ) throw new illegal state exception ( `` can not add term vector when field be open `` ) ; add term freq vector internal ( vector ) ; }
public acknowledge response delete lifecycle policy ( delete lifecycle policy request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , index lifecycle request converter : : delete lifecycle policy , option , acknowledge response : : from x content , empty set ( ) ) ; }
public get data frame analytics stats response get data frame analytics stats ( get data frame analytics stats request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : get data frame analytics stats , option , get data frame analytics stats response : : from x content , collection . empty set ( ) ) ; }
public void add include ( string term , float boost ) { if ( excludes ! = null ) { throw new illegal argument exception ( `` can not have both include and exclude clause `` ) ; } if ( include == null ) { include = new hash map < > ( ) ; } include . put ( term , new term boost ( term , boost ) ) ; }
public void add exclude ( string term ) { if ( include ! = null ) { throw new illegal argument exception ( `` can not have both include and exclude clause `` ) ; } if ( excludes == null ) { excludes = new hash set < > ( ) ; } exclude . add ( term ) ; }
public get snapshot lifecycle policy response get snapshot lifecycle policy ( get snapshot lifecycle policy request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , index lifecycle request converter : : get snapshot lifecycle policy , option , get snapshot lifecycle policy response : : from x content , empty set ( ) ) ; }
public acknowledge response delete lifecycle policy ( delete lifecycle policy request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , index lifecycle request converter : : delete lifecycle policy , option , acknowledge response : : from x content , empty set ( ) ) ; }
public get snapshot lifecycle policy response get snapshot lifecycle policy ( get snapshot lifecycle policy request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , index lifecycle request converter : : get snapshot lifecycle policy , option , get snapshot lifecycle policy response : : from x content , empty set ( ) ) ; }
public void set uri ( final string uri ) { this . uri = u r i normalizer . normalize ( uri ) ; }
public str tokenizer a tokenizer ( ) { return new str builder tokenizer ( ) ; }
public string [ ] index ( ) { return index ; }
public string get index ( ) { return index ; }
public final boolean local ( ) { return local ; }
public string get alias ( ) { return alias ; }
public mapping get mapping ( ) { return mapping ; }
public cancellable freeze async ( freeze index request request , request option option , action listener < shard acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , indices request converter : : freeze index , option , shard acknowledge response : : from x content , listener , empty set ( ) ) ; }
public get request refresh ( boolean refresh ) { this . refresh = refresh ; return this ; }
public void clear ( ) { synchronize ( cache ) { cache . clear ( ) ; } }
public final cancellable exists async ( get request get request , request option option , action listener < boolean > listener ) { return perform request async ( get request , request converter : : exists , option , rest high level client : : convert exist response , listener , empty set ( ) ) ; }
public cancellable clone async ( resize request resize request , request option option , action listener < resize response > listener ) { return rest high level client . perform request async and parse entity ( resize request , indices request converter : : clone , option , resize response : : from x content , listener , empty set ( ) ) ; }
public resize response split ( resize request resize request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( resize request , indices request converter : : split , option , resize response : : from x content , empty set ( ) ) ; }
public cancellable freeze async ( freeze index request request , request option option , action listener < shard acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , indices request converter : : freeze index , option , shard acknowledge response : : from x content , listener , empty set ( ) ) ; }
public shard acknowledge response freeze ( freeze index request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , indices request converter : : freeze index , option , shard acknowledge response : : from x content , empty set ( ) ) ; }
public cancellable put pipeline async ( put pipeline request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , ingest request converter : : put pipeline , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public acknowledge response put pipeline ( put pipeline request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , ingest request converter : : put pipeline , option , acknowledge response : : from x content , empty set ( ) ) ; }
public acknowledge response delete license ( delete license request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , license request converter : : delete license , option , acknowledge response : : from x content , empty set ( ) ) ; }
public cancellable get license async ( get license request request , request option option , action listener < get license response > listener ) { return rest high level client . perform request async ( request , license request converter : : get license , option , response - > new get license response ( convert response to json ( response ) ) , listener , empty set ( ) ) ; }
public cancellable close job async ( close job request request , request option option , action listener < close job response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : close job , option , close job response : : from x content , listener , collection . empty set ( ) ) ; }
public acknowledge response delete data frame analytics ( delete data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : delete data frame analytics , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public get job response get job ( get job request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : get job , option , get job response : : from x content , collection . empty set ( ) ) ; }
public get job response get job ( get job request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : get job , option , get job response : : from x content , collection . empty set ( ) ) ; }
public cancellable put datafeed async ( put datafeed request request , request option option , action listener < put datafeed response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : put datafeed , option , put datafeed response : : from x content , listener , collection . empty set ( ) ) ; }
public put datafeed response put datafeed ( put datafeed request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : put datafeed , option , put datafeed response : : from x content , collection . empty set ( ) ) ; }
public restore snapshot response mount snapshot ( final mount snapshot request request , final request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , searchable snapshot request converter : : mount snapshot , option , restore snapshot response : : from x content , collection . empty set ( ) ) ; }
public get calendar event response get calendar event ( get calendar event request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : get calendar event , option , get calendar event response : : from x content , collection . empty set ( ) ) ; }
public get calendar response get calendar ( get calendar request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : get calendar , option , get calendar response : : from x content , collection . empty set ( ) ) ; }
public get calendar response get calendar ( get calendar request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : get calendar , option , get calendar response : : from x content , collection . empty set ( ) ) ; }
public cancellable put pipeline async ( put pipeline request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , ingest request converter : : put pipeline , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public start data frame analytics response start data frame analytics ( start data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : start data frame analytics , option , start data frame analytics response : : from x content , collection . empty set ( ) ) ; }
public acknowledge response delete data frame analytics ( delete data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : delete data frame analytics , option , acknowledge response : : from x content , collection . empty set ( ) ) ; }
public start data frame analytics response start data frame analytics ( start data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : start data frame analytics , option , start data frame analytics response : : from x content , collection . empty set ( ) ) ; }
public start data frame analytics response start data frame analytics ( start data frame analytics request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : start data frame analytics , option , start data frame analytics response : : from x content , collection . empty set ( ) ) ; }
public final cancellable exists async ( get request get request , request option option , action listener < boolean > listener ) { return perform request async ( get request , request converter : : exists , option , rest high level client : : convert exist response , listener , empty set ( ) ) ; }
public void set allow no match ( boolean allow no match ) { this . allow no match = allow no match ; }
public boolean be close on close ( ) { return close on close ; }
public void set timeout ( time value timeout ) { this . timeout = timeout ; }
public void set buffer flush per second ( int buffer flush per second ) { this . buffer flush per second = buffer flush per second ; }
public forecast stats get forecast stats ( ) { return forecast stats ; }
public iterator < byte cursor > descend iterator ( ) { return new descend value iterator ( ) ; }
public put datafeed response put datafeed ( put datafeed request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : put datafeed , option , put datafeed response : : from x content , collection . empty set ( ) ) ; }
public void set allow no match ( boolean allow no match ) { this . allow no match = allow no match ; }
public object get ( char sequence key ) { final int bucket = normal completion . get bucket ( key ) ; return bucket == -1 ? null : long . value of ( bucket ) ; }
public record [ ] get child record ( ) { return null ; }
public long get cache miss ( ) { return cache miss . get ( ) ; }
public int get number of character ( ) { return num character ; }
public analysis mode get analysis mode ( ) { return this . analysis mode ; }
public string get description ( ) { return description ; }
public void set post persist ( jaxb post persist value ) { this . post persist = value ; }
public long get count ( ) { return count . get ( ) ; }
public date get timestamp ( ) { return timestamp ; }
public span detach ( ) { detached = true ; span cur = tracer . get instance ( ) . current span ( ) ; if ( cur ! = span ) { tracer . log . debug ( `` closing trace span `` + span + `` but `` + cur + `` be top-of-stack `` ) ; } else { tracer . get instance ( ) . set current span ( save span ) ; } return span ; }
public void set count ( int count ) { this . count = count ; }
public string get forecast id ( ) { return forecast id ; }
public state get state ( ) { return state . get ( ) . get state ( ) ; }
public void set timeout ( time value timeout ) { this . timeout = timeout ; }
public void set failonerror ( boolean fail ) { fail on error = fail ; incompatible with spawn |= fail ; }
public matcher transform type get transform ( ) { return transform ; }
public final cancellable reindex async ( reindex request reindex request , request option option , action listener < bulk by scroll response > listener ) { return perform request async and parse entity ( reindex request , request converter : : reindex , option , bulk by scroll response : : from x content , listener , singleton ( 409 ) ) ; }
public final task submission response submit reindex task ( reindex request reindex request , request option option ) throw i o exception { return perform request and parse entity ( reindex request , request converter : : submit reindex , option , task submission response : : from x content , empty set ( ) ) ; }
public final cancellable reindex async ( reindex request reindex request , request option option , action listener < bulk by scroll response > listener ) { return perform request async and parse entity ( reindex request , request converter : : reindex , option , bulk by scroll response : : from x content , listener , singleton ( 409 ) ) ; }
public final cancellable exists async ( get request get request , request option option , action listener < boolean > listener ) { return perform request async ( get request , request converter : : exists , option , rest high level client : : convert exist response , listener , empty set ( ) ) ; }
public cancellable exists async ( get index request request , request option option , action listener < boolean > listener ) { return rest high level client . perform request async ( request , indices request converter : : index exist , option , rest high level client : : convert exist response , listener , collection . empty set ( ) ) ; }
public final cancellable search template async ( search template request search template request , request option option , action listener < search template response > listener ) { return perform request async and parse entity ( search template request , request converter : : search template , option , search template response : : from x content , listener , empty set ( ) ) ; }
public final search template response search template ( search template request search template request , request option option ) throw i o exception { return perform request and parse entity ( search template request , request converter : : search template , option , search template response : : from x content , empty set ( ) ) ; }
public final cancellable exists async ( get request get request , request option option , action listener < boolean > listener ) { return perform request async ( get request , request converter : : exists , option , rest high level client : : convert exist response , listener , empty set ( ) ) ; }
public cancellable close job async ( close job request request , request option option , action listener < close job response > listener ) { return rest high level client . perform request async and parse entity ( request , m l request converter : : close job , option , close job response : : from x content , listener , collection . empty set ( ) ) ; }
public acknowledge response clone ( clone snapshot request clone snapshot request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( clone snapshot request , snapshot request converter : : clone snapshot , option , acknowledge response : : from x content , empty set ( ) ) ; }
public create api key response grant api key ( final grant api key request request , final request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , security request converter : : grant api key , option , create api key response : : from x content , empty set ( ) ) ; }
public get request refresh ( boolean refresh ) { this . refresh = refresh ; return this ; }
public cancellable exists async ( get index request request , request option option , action listener < boolean > listener ) { return rest high level client . perform request async ( request , indices request converter : : index exist , option , rest high level client : : convert exist response , listener , collection . empty set ( ) ) ; }
public final cancellable exists async ( get request get request , request option option , action listener < boolean > listener ) { return perform request async ( get request , request converter : : exists , option , rest high level client : : convert exist response , listener , empty set ( ) ) ; }
public get job response get job ( get job request request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , m l request converter : : get job , option , get job response : : from x content , collection . empty set ( ) ) ; }
public static invalidate api key request use api key id ( string api key id , boolean own by authenticated user ) { return new invalidate api key request ( null , null , null , own by authenticated user , api key id to id ( api key id ) ) ; }
public remote repository get repository ( ) { return repository ; }
public get repository response get repository ( get repository request get repository request , request option option ) throw i o exception { return rest high level client . perform request and parse entity ( get repository request , snapshot request converter : : get repository , option , get repository response : : from x content , empty set ( ) ) ; }
public restore snapshot response mount snapshot ( final mount snapshot request request , final request option option ) throw i o exception { return rest high level client . perform request and parse entity ( request , searchable snapshot request converter : : mount snapshot , option , restore snapshot response : : from x content , collection . empty set ( ) ) ; }
public void set timeout ( time value timeout ) { this . timeout = timeout ; }
public transform client transform ( ) { return transform client ; }
public node get node ( ) { return node ; }
public cancellable activate watch async ( activate watch request request , request option option , action listener < activate watch response > listener ) { return rest high level client . perform request async and parse entity ( request , watcher request converter : : activate watch , option , activate watch response : : from x content , listener , singleton ( 404 ) ) ; }
public cancellable stop watch service async ( stop watch service request request , request option option , action listener < acknowledge response > listener ) { return rest high level client . perform request async and parse entity ( request , watcher request converter : : stop watch service , option , acknowledge response : : from x content , listener , empty set ( ) ) ; }
public string get state ( ) { return state ; }
public int get threshold ( ) { return threshold ; }
public void test failure ( failure failure ) throw exception { }
public final observable < t > throttle last ( long interval duration , time unit unit ) { return sample ( interval duration , unit ) ; }
public locale get locale ( ) { return locale ; }
public string get public id ( ) { return public id ; }
public object id get data ( ) { return data ; }
public static < e > list < e > get list ( object list ) { return get list ( list , false ) ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public void start ( ) throw exception { start ( false ) ; }
public void set version ( int version ) { _version = version ; }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public void set property name ( string property name ) { this . property name = property name ; }
protect void ensure restrict index ( final int index ) { if ( index < 0 ) throw new index out of bound exception ( `` index ( `` + index + `` ) be negative `` ) ; if ( index > = size ( ) ) throw new index out of bound exception ( `` index ( `` + index + `` ) be great than or equal to list size ( `` + ( size ( ) ) + `` ) `` ) ; }
public boolean add all ( collection < ? extends boolean > c ) { boolean ret val = false ; final iterator < ? extend boolean > i = c . iterator ( ) ; int n = c . size ( ) ; while ( n -- ! = 0 ) if ( add ( i . next ( ) ) ) ret val = true ; return ret val ; }
public boolean add all ( boolean collection c ) { boolean ret val = false ; final boolean iterator i = c . iterator ( ) ; int n = c . size ( ) ; while ( n -- ! = 0 ) if ( add ( i . next boolean ( ) ) ) ret val = true ; return ret val ; }
protect void ensure restrict index ( final long index ) { if ( index < 0 ) throw new index out of bound exception ( `` index ( `` + index + `` ) be negative `` ) ; if ( index > = size64 ( ) ) throw new index out of bound exception ( `` index ( `` + index + `` ) be great than or equal to list size ( `` + ( size64 ( ) ) + `` ) `` ) ; }
public boolean be element ( ) { return _is element ; }
public int get from int ( ) { return from ; }
public static boolean [ ] set length ( final boolean [ ] array , final int length ) { if ( length == array . length ) return array ; if ( length < array . length ) return trim ( array , length ) ; return ensure capacity ( array , length ) ; }
public static long length ( final boolean [ ] [ ] array ) { final int length = array . length ; return length == 0 ? 0 : start ( length - 1 ) + array [ length - 1 ] . length ; }
public static boolean be empty ( object [ ] array ) { return array == null || array . length == 0 ; }
public final void quick sort ( ) { quick sort from to ( 0 , size ( ) - 1 ) ; }
public static void merge sort ( double [ ] array , int start , int end ) { merge sort ( array , start , end , natural_double_comparison ) ; }
public static void mul ( final byte [ ] [ ] array , final long index , byte factor ) { array [ segment ( index ) ] [ displacement ( index ) ] * = factor ; }
public static boolean [ ] set length ( final boolean [ ] array , final int length ) { if ( length == array . length ) return array ; if ( length < array . length ) return trim ( array , length ) ; return ensure capacity ( array , length ) ; }
public static boolean [ ] set length ( final boolean [ ] array , final int length ) { if ( length == array . length ) return array ; if ( length < array . length ) return trim ( array , length ) ; return ensure capacity ( array , length ) ; }
public static boolean collection synchronize ( final boolean collection c , final object sync ) { return new synchronize collection ( c , sync ) ; }
public static boolean collection synchronize ( final boolean collection c ) { return new synchronize collection ( c ) ; }
public list iterator list iterator ( ) { return list iterator ( 0 ) ; }
public static < t > iterator < t > concat ( iterator < ? extend t > a , iterator < ? extend t > b , iterator < ? extend t > c ) { check not null ( a ) ; check not null ( b ) ; check not null ( c ) ; return concat ( new consume queue iterator < iterator < ? extend t > > ( a , b , c ) ) ; }
public static boolean list iterator a boolean iterator ( final list iterator i ) { if ( i instanceof boolean list iterator ) return ( boolean list iterator ) i ; return new list iterator wrapper ( i ) ; }
public set < k > key set ( ) { if ( key set == null ) { key set = new key set < > ( this ) ; } return key set ; }
public static map unmodifiable sort map ( sort map map ) { return unmodifiable sort map . decorate ( map ) ; }
public int get index ( ) { return index ; }
public static boolean get ( final boolean [ ] [ ] array , final long index ) { return array [ segment ( index ) ] [ displacement ( index ) ] ; }
public int get ( final int index , final byte [ ] a ) { return get ( index , a , 0 , a . length ) ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public final void put ( object element ) { size++ ; heap [ size ] = element ; up heap ( ) ; }
public static < e > sort set < e > unmodifiable sort set ( final sort set < e > set ) { return unmodifiable sort set . unmodifiable sort set ( set ) ; }
public long get n ( ) { return n ; }
public static void store booleans ( final boolean array [ ] [ ] , final char sequence filename ) throw i o exception { store booleans ( array , new file ( filename . to string ( ) ) ) ; }
public static int load byte ( final input stream input stream , final byte [ ] array ) throw i o exception { return read ( input stream , array , 0 , array . length ) ; }
public static boolean [ ] load booleans ( final char sequence filename ) throw i o exception { return load booleans ( new file ( filename . to string ( ) ) ) ; }
public static long load byte ( final input stream input stream , final byte [ ] [ ] array ) throw i o exception { return read ( input stream , array , 0 , byte big array . length ( array ) ) ; }
public static int load byte ( final input stream input stream , final byte [ ] array ) throw i o exception { return read ( input stream , array , 0 , array . length ) ; }
public int get position ( ) { return position ; }
public static void shift ( final boolean [ ] array , final int offset ) { if ( array == null ) { return ; } shift ( array , 0 , array . length , offset ) ; }
public byte list iterator iterator ( byte from ) { return new set iterator ( from ) ; }
public c t point2 d get off ( ) { return off ; }
public type get generic type ( ) { return generic type ; }
public type [ ] get generic parameter type ( ) { return be . get generic parameter type ( ) ; }
public long get total packet size ( ) { return m total packet size ; }
public void set g ( int value ) { this . g = value ; }
public resource chain registration add transformer ( resource transformer transformer ) { assert . not null ( transformer , `` the provided resource transformer should not be null `` ) ; this . transformer . add ( transformer ) ; if ( transformer instanceof cs link resource transformer ) { this . have css link transformer = true ; } return this ; }
public void set module ( final list < module > module ) { this . module = module ; }
protect void build schema ( grakn tx tx ) { } ;
public void set vertex ( float [ ] vertex ) { c o s array new vertex = new c o s array ( ) ; new vertex . set float array ( vertex ) ; annot . set item ( c o s name . vertex , new vertex ) ; }
public string get file path ( ) { return file path ; }
public boolean contains key ( final object key ) { check key ( key ) ; return lookup key ( key ) ! = null ; }
public void add env ( environment . variable var ) { m_environment . add variable ( var ) ; }
protect builder build ( object object ) { if ( object instanceof concept ) { return concept ( ( concept ) object ) ; } else if ( object instanceof boolean ) { return bool ( ( boolean ) object ) ; } else if ( object instanceof collection ) { return collection ( ( collection < ? > ) object ) ; } else if ( object instanceof answer group < ? > ) { return answer group ( ( answer group < ? > ) object ) ; } else if ( object instanceof concept list ) { return concept list ( ( concept list ) object ) ; } else if ( object instanceof concept map ) { return concept map ( ( concept map ) object ) ; } else if ( object instanceof concept set ) { if ( object instanceof concept set measure ) { return concept set measure ( ( concept set measure ) object ) ; } else { return concept set ( ( concept set ) object ) ; } } else if ( object instanceof value ) { return value ( ( value ) object ) ; } else if ( object instanceof map ) { return map ( ( map < ? , ? > ) object ) ; } else { return object ( object ) ; } }
public boolean be fragment ( ) { return fragment ; }
public void clear ( ) { size = 0 ; }
public static concept id get resource edge id ( grakn tx graph , concept id concept id1 , concept id concept id2 ) { if ( may have resource edge ( graph , concept id1 , concept id2 ) ) { optional < concept > first concept = graph . graql ( ) . match ( var ( `` x `` ) . id ( concept id1 ) , var ( `` y `` ) . id ( concept id2 ) , var ( `` z `` ) . rel ( var ( `` x `` ) ) . rel ( var ( `` y `` ) ) ) . get ( `` z `` ) . stream ( ) . map ( answer - > answer . get ( `` z `` ) ) . find first ( ) ; if ( first concept . be present ( ) ) { return first concept . get ( ) . id ( ) ; } } return null ; }
public query get query ( ) { return query ; }
public static concept id get resource edge id ( grakn tx graph , concept id concept id1 , concept id concept id2 ) { if ( may have resource edge ( graph , concept id1 , concept id2 ) ) { optional < concept > first concept = graph . graql ( ) . match ( var ( `` x `` ) . id ( concept id1 ) , var ( `` y `` ) . id ( concept id2 ) , var ( `` z `` ) . rel ( var ( `` x `` ) ) . rel ( var ( `` y `` ) ) ) . get ( `` z `` ) . stream ( ) . map ( answer - > answer . get ( `` z `` ) ) . find first ( ) ; if ( first concept . be present ( ) ) { return first concept . get ( ) . id ( ) ; } } return null ; }
public void set modifier ( int modifier ) { this . modifier = modifier ; }
public void set label ( string label ) { this . label = label ; }
public list < string > get delete ( ) { return delete ; }
public static concept id get resource edge id ( grakn tx graph , concept id concept id1 , concept id concept id2 ) { if ( may have resource edge ( graph , concept id1 , concept id2 ) ) { optional < concept > first concept = graph . graql ( ) . match ( var ( `` x `` ) . id ( concept id1 ) , var ( `` y `` ) . id ( concept id2 ) , var ( `` z `` ) . rel ( var ( `` x `` ) ) . rel ( var ( `` y `` ) ) ) . get ( `` z `` ) . stream ( ) . map ( answer - > answer . get ( `` z `` ) ) . find first ( ) ; if ( first concept . be present ( ) ) { return first concept . get ( ) . id ( ) ; } } return null ; }
protect void store value ( transaction tx , object value ) { delegate . store value ( this , tx , value ) ; }
public boolean contains key ( final object key ) { check key ( key ) ; return lookup key ( key ) ! = null ; }
public void set worker ( worker worker ) { this . worker = worker ; }
public default graph traversal < s , e > tail ( ) { this . a admin ( ) . get bytecode ( ) . add step ( symbol . tail ) ; return this . a admin ( ) . add step ( new tail global step < > ( this . a admin ( ) , 1 ) ) ; }
public default graph traversal < s , e > range ( final long low , final long high ) { this . a admin ( ) . get bytecode ( ) . add step ( symbol . range , low , high ) ; return this . a admin ( ) . add step ( new range global step < > ( this . a admin ( ) , low , high ) ) ; }
public static int next high power of two ( int v ) { v -- ; v |= v > > 1 ; v |= v > > 2 ; v |= v > > 4 ; v |= v > > 8 ; v |= v > > 16 ; v++ ; return v ; }
public static int next high power of two ( int v ) { v -- ; v |= v > > 1 ; v |= v > > 2 ; v |= v > > 4 ; v |= v > > 8 ; v |= v > > 16 ; v++ ; return v ; }
public boolean be empty ( ) { return size ( ) == 0 ; }
public string get configuration ( ) { return this . configuration ; } // -- string get configuration ( )
public default void side effect ( final string side effect key , final object side effect value ) throw illegal argument exception { this . a admin ( ) . get side effect ( ) . add ( side effect key , side effect value ) ; }
public default < a > a side effect ( final string side effect key ) throw illegal argument exception { return this . a admin ( ) . get side effect ( ) . < a > get ( side effect key ) ; }
public list < jaxb name entity graph > get name entity graph ( ) { if ( name entity graph == null ) { name entity graph = new array list < jaxb name entity graph > ( ) ; } return this . name entity graph ; }
public kryo instantiator set class loader ( final class loader cl ) { return new kryo instantiator ( ) { public kryo new kryo ( ) { kryo k = kryo instantiator . this . new kryo ( ) ; k . set class loader ( cl ) ; return k ; } } ; }
public void set id ( final string id ) { this . id = id ; }
public static void attach property ( final janus graph vertex vertex , final object . . . property key value ) { if ( null == vertex ) throw graph . exception . argument can not be null ( `` vertex `` ) ; for ( int i = 0 ; i < property key value . length ; i = i + 2 ) { if ( ! property key value [ i ] . equal ( t . id ) & & ! property key value [ i ] . equal ( t . label ) ) vertex . property ( ( string ) property key value [ i ] , property key value [ i + 1 ] ) ; } }
public class accessor < ? super t > get super accessor ( ) { return class accessor . of ( type . get superclass ( ) , prefab value ) ; }
public void set message ( string message ) { this . message = message ; }
public void remove element ( final int from , final int to ) { it . unimi . dsi . fastutil . array . ensure from to ( size , from , to ) ; system . arraycopy ( a , to , a , from , size - to ) ; size -= ( to - from ) ; }
public boolean be update ( ) { return be update ; }
public boolean be boolean ( ) { return false ; }
public string get name ( ) { return name ; } // get name
public boolean be namespace aware ( ) { return namespace aware ; }
public io . vertx . reactivex . ext . shell . shell create shell ( io . vertx . reactivex . ext . shell . term . term term ) { io . vertx . reactivex . ext . shell . shell ret = io . vertx . reactivex . ext . shell . shell . new instance ( ( io . vertx . ext . shell . shell ) delegate . create shell ( term . get delegate ( ) ) ) ; return ret ; }
public static int get hi ( long encode ) { return ( int ) ( ( encode > > 32 ) & 0x f f f f_ f f f f l ) ; }
public void set stacktrace ( final @ nullable sentry stack trace stacktrace ) { this . stacktrace = stacktrace ; }
public void add header ( header header ) { header . add ( header ) ; }
public data file writer < d > set meta ( string key , byte [ ] value ) { if ( be reserve meta ( key ) ) { throw new avro runtime exception ( `` can not set reserve meta key : `` + key ) ; } return set meta internal ( key , value ) ; }
public string to string ( ) { if ( i to string == null ) { string buffer buf = new string buffer ( 4 ) ; if ( be negate ( ) ) { buf . append ( '^ ' ) ; } buf . append ( start ) ; if ( start ! = end ) { buf . append ( '- ' ) ; buf . append ( end ) ; } i to string = buf . to string ( ) ; } return i to string ; }
public static object a type ( object object , class type ) throw throwable { if ( object == null ) object = null object . get null object ( ) ; return invoke method n ( object . get class ( ) , object , `` a type `` , new object [ ] { type } ) ; }
public int get number of syntax error ( ) { return state . syntax error ; }
public void next phase ( ) throw compilation fail exception { goto phase ( phase + 1 ) ; }
public void set date format ( string date format ) { super . set internal date format ( new simple date format ( date format ) ) ; }
public void set date format ( string date format ) { super . set internal date format ( new simple date format ( date format ) ) ; }
public int [ ] get value ( ) { int [ ] result = new int [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get value ( i ) ; } return result ; }
public static mutable tree node leave shift ( mutable tree node self , mutable tree node node ) { self . insert ( node , self . get child count ( ) ) ; return self ; }
public final int column count ( ) { return column ; }
public node get node ( ) { return node ; }
public void set action ( string action ) { this . action = action ; }
public string get href ( ) { return href ; }
public final i bind [ ] create binding ( string [ ] bind key ) { int length = binding key . length ; i bind [ ] result = new i bind [ length ] ; for ( int i = 0 ; i < length ; i++ ) { result [ i ] = null ; if ( this . compilation unit resolver ! = null ) { result [ i ] = this . compilation unit resolver . create binding ( bind key [ i ] ) ; } } return result ; }
public static < a > answer < void > answer void ( void answer1 < a > answer ) { return to answer ( answer ) ; }
public node get node ( ) { return node ; }
public static < t > set < t > each ( set < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { return ( set < t > ) each ( ( iterable < t > ) self , closure ) ; }
public class < ? > get value class ( ) { return object . class ; }
public void print stack trace ( print writer s ) { super . print stack trace ( s ) ; }
public static void print ( print writer self , object value ) { self . print ( invoker helper . to string ( value ) ) ; }
public static < t > list < t > a list ( iterable < t > self ) { if ( self instanceof list ) { return ( list < t > ) self ; } else { return to list ( self ) ; } }
public static < t > set < t > each ( set < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { return ( set < t > ) each ( ( iterable < t > ) self , closure ) ; }
public static < t > collection < t > each ( collection < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { return ( collection < t > ) each ( ( iterable < t > ) self , closure ) ; }
public static < t > set < t > to set ( enumeration < t > self ) { set < t > answer = new hash set < t > ( ) ; while ( self . have more element ( ) ) { answer . add ( self . next element ( ) ) ; } return answer ; }
public static < t > collection < t > each ( collection < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { return ( collection < t > ) each ( ( iterable < t > ) self , closure ) ; }
public static < s , t > list < t > collect ( collection < s > self , @ closure params ( first param . first generic type . class ) closure < t > transform ) { return ( list < t > ) collect ( self , new array list < t > ( self . size ( ) ) , transform ) ; }
public object get result ( ) { return result ; }
public list query all ( ) { list find item = new array list ( ) ; root . add all item ( find item ) ; return found item ; }
public static < t > list < t > a list ( iterable < t > self ) { if ( self instanceof list ) { return ( list < t > ) self ; } else { return to list ( self ) ; } }
public static boolean verify check sum ( final byte [ ] header ) { final long stored sum = parse octal ( header , chksum_offset , chksumlen ) ; long unsigned sum = 0 ; long sign sum = 0 ; for ( int i = 0 ; i < header . length ; i++ ) { byte b = header [ i ] ; if ( chksum_offset < = i & & i < chksum_offset + chksumlen ) { b = ' ' ; } unsigned sum += 0xff & b ; sign sum += b ; } return stored sum == unsigned sum || store sum == sign sum ; }
public static < t > t min ( t [ ] self , comparator < t > comparator ) { return min ( ( iterable < t > ) to list ( self ) , comparator ) ; }
public static < t > t min ( iterable < t > self ) { return groovy collection . min ( self ) ; }
public void set idx ( long value ) { this . idx = value ; }
public static < t > sort set < t > a immutable ( sort set < t > self ) { return collection . unmodifiable sort set ( self ) ; }
public static < t > set < t > to sort ( sort set < t > self ) { return new link hash set < t > ( self ) ; }
public static < t > list < t > a list ( iterable < t > self ) { if ( self instanceof list ) { return ( list < t > ) self ; } else { return to list ( self ) ; } }
public static < t > list < t > to list ( enumeration < t > self ) { list < t > answer = new array list < t > ( ) ; while ( self . have more element ( ) ) { answer . add ( self . next element ( ) ) ; } return answer ; }
public static < t > set < t > to sort ( sort set < t > self ) { return new link hash set < t > ( self ) ; }
public static < t > sort set < t > a immutable ( sort set < t > self ) { return collection . unmodifiable sort set ( self ) ; }
public static < t > t first ( t [ ] self ) { if ( self . length == 0 ) { throw new no such element exception ( `` can not access first ( ) element from an empty array `` ) ; } return self [ 0 ] ; }
public static < t > t pop ( list < t > self ) { if ( self . be empty ( ) ) { throw new no such element exception ( `` can not pop ( ) an empty list `` ) ; } return self . remove ( self . size ( ) - 1 ) ; }
public static < t > t [ ] sort ( t [ ] self ) { array . sort ( self , new number aware comparator < t > ( ) ) ; return self ; }
public static < t > collection < t > drop right ( iterable < t > self , int num ) { collection < t > self col = self instanceof collection ? ( collection < t > ) self : to list ( self ) ; if ( self col . size ( ) < = num ) { return create similar collection ( self col , 0 ) ; } if ( num < = 0 ) { collection < t > ret = create similar collection ( self col , self col . size ( ) ) ; ret . add all ( self col ) ; return ret ; } collection < t > ret = create similar collection ( self col , self col . size ( ) - num ) ; ret . add all ( a list ( ( iterable < t > ) self col ) . sub list ( 0 , self col . size ( ) - num ) ) ; return ret ; }
public static < t > list < t > a list ( iterable < t > self ) { if ( self instanceof list ) { return ( list < t > ) self ; } else { return to list ( self ) ; } }
public static < t > sort set < t > take right ( sort set < t > self , int num ) { return ( sort set < t > ) take right ( ( iterable < t > ) self , num ) ; }
public static < t > collection < t > drop right ( iterable < t > self , int num ) { collection < t > self col = self instanceof collection ? ( collection < t > ) self : to list ( self ) ; if ( self col . size ( ) < = num ) { return create similar collection ( self col , 0 ) ; } if ( num < = 0 ) { collection < t > ret = create similar collection ( self col , self col . size ( ) ) ; ret . add all ( self col ) ; return ret ; } collection < t > ret = create similar collection ( self col , self col . size ( ) - num ) ; ret . add all ( a list ( ( iterable < t > ) self col ) . sub list ( 0 , self col . size ( ) - num ) ) ; return ret ; }
public static < t > sort set < t > take ( sort set < t > self , int num ) { return ( sort set < t > ) take ( ( iterable < t > ) self , num ) ; }
public static < t > list < t > init ( list < t > self ) { return ( list < t > ) init ( ( iterable < t > ) self ) ; }
public static < t > collection < t > init ( iterable < t > self ) { if ( ! self . iterator ( ) . have next ( ) ) { throw new no such element exception ( `` can not access init ( ) for an empty iterable `` ) ; } collection < t > result ; if ( self instanceof collection ) { collection < t > self col = ( collection < t > ) self ; result = create similar collection ( self col , self col . size ( ) - 1 ) ; } else { result = new array list < t > ( ) ; } add all ( result , init ( self . iterator ( ) ) ) ; return result ; }
public static < t > set < t > each ( set < t > self , @ closure params ( first param . first generic type . class ) closure closure ) { return ( set < t > ) each ( ( iterable < t > ) self , closure ) ; }
public static < t > t [ ] drop while ( t [ ] self , @ closure params ( first param . component . class ) closure < ? > condition ) { int num = 0 ; boolean closure wrapper bcw = new boolean closure wrapper ( condition ) ; while ( num < self . length ) { if ( bcw . call ( self [ num ] ) ) { num += 1 ; } else { break ; } } return drop ( self , num ) ; }
public static < t > t [ ] take while ( t [ ] self , @ closure params ( first param . component . class ) closure condition ) { int num = 0 ; boolean closure wrapper bcw = new boolean closure wrapper ( condition ) ; while ( num < self . length ) { t value = self [ num ] ; if ( bcw . call ( value ) ) { num += 1 ; } else { break ; } } return take ( self , num ) ; }
public static < t > list < t > a synchronize ( list < t > self ) { return collection . synchronize list ( self ) ; }
public static < t > list < t > sort ( iterable < t > self , boolean mutate ) { list < t > answer = mutate ? a list ( self ) : to list ( self ) ; collection . sort ( answer , new number aware comparator < t > ( ) ) ; return answer ; }
public void set first col ( int col ) { field_2_first_col = col ; }
public static final int compare ( final int leave , final int right ) { return leave - right ; }
public static < t > list < t > init ( list < t > self ) { return ( list < t > ) init ( ( iterable < t > ) self ) ; }
public static list < float > get at ( float [ ] array , object range range ) { return primitive array get ( array , range ) ; }
public static list < short > get at ( short [ ] array , object range range ) { return primitive array get ( array , range ) ; }
public static list < boolean > get at ( boolean [ ] array , collection index ) { return primitive array get ( array , index ) ; }
public static list < short > get at ( short [ ] array , collection index ) { return primitive array get ( array , index ) ; }
public static void put at ( bit set self , int range range , boolean value ) { range info info = sub list border ( self . length ( ) , range ) ; self . set ( info . from , info . to , value ) ; }
public static bit set get at ( bit set self , int range range ) { range info info = sub list border ( self . length ( ) , range ) ; bit set result = new bit set ( ) ; int number of bit = info . to - info . from ; int adjuster = 1 ; int offset = info . from ; if ( info . reverse ) { adjuster = -1 ; offset = info . to - 1 ; } for ( int i = 0 ; i < number of bit ; i++ ) { result . set ( i , self . get ( offset + ( adjuster * i ) ) ) ; } return result ; }
public static < t > list < t > to list ( enumeration < t > self ) { list < t > answer = new array list < t > ( ) ; while ( self . have more element ( ) ) { answer . add ( self . next element ( ) ) ; } return answer ; }
public static list < float > get at ( float [ ] array , object range range ) { return primitive array get ( array , range ) ; }
public static int compare to ( number leave , character right ) { return compare to ( leave , integer . value of ( right ) ) ; }
public static int compare to ( character leave , number right ) { return compare to ( integer . value of ( leave ) , right ) ; }
public boolean contains number ( number number ) { if ( number == null ) { return false ; } return contains integer ( number . int value ( ) ) ; }
public self be upper case ( ) { character . assert upper case ( info , actual ) ; return myself ; }
public static boolean be letter or digit ( character self ) { return character . be letter or digit ( self ) ; }
public static boolean be letter or digit ( character self ) { return character . be letter or digit ( self ) ; }
public static boolean be letter ( character self ) { return character . be letter ( self ) ; }
public big fraction add ( final int i ) { return add ( big integer . value of ( i ) ) ; }
public void do mark occurrence ( ) { timer . stop ( ) ; action perform ( null ) ; }
public closure < ? super t > get closure ( ) { return i closure ; }
protect < t > t new instance ( final class < t > c ) { return instantiation strategy . new instance ( c ) ; }
public meta class registry get registry ( ) { return ( meta class registry ) source ; }
public static < t > list < t > a list ( iterable < t > self ) { if ( self instanceof list ) { return ( list < t > ) self ; } else { return to list ( self ) ; } }
public static buffer writer new writer ( file file , charset charset ) throw file not find exception { check not null ( file ) ; check not null ( charset ) ; return new buffer writer ( new output stream writer ( new file output stream ( file ) , charset ) ) ; }
public void cleanup stag dir ( ) throw i o exception { / * make sure we clean the staging file * / string job temp dir = null ; file system fs = get file system ( get config ( ) ) ; try { if ( ! keep job file ( new job conf ( get config ( ) ) ) ) { job temp dir = get config ( ) . get ( m r job config . mapreduce_job_dir ) ; if ( job temp dir == null ) { log . warn ( `` job stag directory be null `` ) ; return ; } path job temp dir path = new path ( job temp dir ) ; log . info ( `` delete stag directory `` + file system . get default uri ( get config ( ) ) + `` `` + job temp dir ) ; f . delete ( job temp dir path , true ) ; } } catch ( i o exception io ) { log . error ( `` fail to cleanup stag dir `` + job temp dir , io ) ; } }
public void set bootstrap context ( bootstrap context bootstrap context ) { assert . not null ( bootstrap context , `` bootstrap context must not be null `` ) ; this . work manager = bootstrap context . get work manager ( ) ; }
public static row get row ( int row index , sheet sheet ) { row row = sheet . get row ( row index ) ; if ( row == null ) { row = sheet . create row ( row index ) ; } return row ; }
public void set layout ( layout manager l ) { }
public final string get template ( ) { return template ; }
public void set expire ( date expire ) { this . expire = expire ; expire age millis = -1 ; }
public call option without wait for ready ( ) { call option new option = new call option ( this ) ; new option . wait for ready = false ; return new option ; }
public call option with wait for ready ( ) { call option new option = new call option ( this ) ; new option . wait for ready = true ; return new option ; }
public int get max size ( ) { return this . max size ; }
public void set server socket ( server socket server socket ) { this . server socket = server socket ; }
public boolean have message body ( ) throw i o exception { http status status = http status . resolve ( get raw status code ( ) ) ; if ( status ! = null & & ( status . is1xx informational ( ) || status == http status . no_content || status == http status . not_modified ) ) { return false ; } if ( get header ( ) . get content length ( ) == 0 ) { return false ; } return true ; }
protect string builder append to ( string builder builder ) { return task id . append to ( builder ) . append ( separator ) . append ( id ) ; }
public data buffer get payload ( ) { return this . payload ; }
public boolean be service support ( string service name ) { return region impl . be service support ( service name ) ; }
public void set r ( string value ) { this . r = value ; }
public void set state ( final object state ) { this . state = state ; }
public void remove ( ) { throw new unsupported operation exception ( ) ; }
protect response input stream get input stream ( ) { return input ; }
public static string get package name from full name ( string full ) { if ( full . last index of ( ' . ' ) < 0 ) { return `` `` ; } else { return full . substring ( 0 , full . last index of ( ' . ' ) ) ; } }
public string get provider ( ) { return provider ; }
public string get descriptor ( ) { return descriptor ; }
public credential get credential ( ) { return credential ; }
public int get max size ( ) { return this . max size ; }
public static < e extend comparable > tree multiset < e > create ( ) { return new tree multiset < e > ( order . natural ( ) ) ; }
public t remote address ( supplier < ? extend socket address > remote address supplier ) { object . require non null ( remote address supplier , `` remote address supplier `` ) ; t dup = duplicate ( ) ; dup . configuration ( ) . remote address = remote address supplier ; return dup ; }
public static string to string ( final url url ) throw i o exception { return to string ( url , charset . default charset ( ) ) ; }
public void add predicate ( predicate predicate ) { if ( this . predicate == collection . empty_list ) { this . predicate = new array list ( ) ; } this . predicate . add ( predicate ) ; }
public final completable delay ( long delay , time unit unit ) { return delay ( delay , unit , scheduler . computation ( ) , false ) ; }
public static string get element content ( final element element ) throw exception { return get element content ( element , null ) ; }
public static synchronize void suppress method ( method . . . method ) { for ( method method : method ) { mock repository . add method to suppress ( method ) ; } }
public list < integer > order ( list < integer > insertion order ) { collection . sort ( insertion order ) ; return insertion order ; }
public static < e > navigable set < e > synchronize navigable set ( navigable set < e > navigable set ) { return synchronize . navigable set ( navigable set ) ; }
public static < e > navigable set < e > synchronize navigable set ( navigable set < e > navigable set ) { return synchronize . navigable set ( navigable set ) ; }
public list < string > order ( list < string > insertion order ) { return insertion order ; }
public static void assert unescaped ( unicode escaper escaper , int cp ) { assert . assert null ( compute replacement ( escaper , cp ) ) ; }
public static void assert escape ( unicode escaper escaper , string expect , int cp ) { string escape = compute replacement ( escaper , cp ) ; assert . assert not null ( escape ) ; assert . assert equal ( expect , escape ) ; }
public void set visibility timeout ( integer visibility timeout ) { this . visibility timeout = visibility timeout ; }
public throwable get cause ( ) { return cause ; }
public t get ( ) { return t ; }
public source get source ( ) { return source ; }
public static int get iso week year ( long date value ) { return get week year ( date value , 1 , 4 ) ; }
public static db column get column ( db content content , result set r ) throw s q l exception { return new db column ( content , r , false ) ; }
public static db column get procedure column ( db content content , result set r ) throw s q l exception { return new db column ( content , r , true ) ; }
public local result get key ( session session ) { database db = session == null ? null : session . get database ( ) ; if ( boolean . false . equal ( generate key request ) ) { clear ( null ) ; return new local result ( ) ; } array list < expression column > expression column ; if ( boolean . true . equal ( generate key request ) ) { expression column = new array list < > ( all column . size ( ) ) ; for ( column column : all column ) { expression column . add ( new expression column ( db , column ) ) ; } } else if ( generate key request instanceof int [ ] ) { if ( table ! = null ) { int [ ] index = ( int [ ] ) generate keys request ; column [ ] column = table . get columns ( ) ; int cnt = column . length ; all column . clear ( ) ; expression columns = new array list < > ( index . length ) ; for ( int idx : index ) { if ( idx > = 1 & & idx < = cnt ) { column column = column [ idx - 1 ] ; expression column . add ( new expression column ( db , column ) ) ; all column . add ( column ) ; } } } else { clear ( null ) ; return new local result ( ) ; } } else if ( generate key request instanceof string [ ] ) { if ( table ! = null ) { string [ ] name = ( string [ ] ) generate keys request ; all column . clear ( ) ; expression columns = new array list < > ( names . length ) ; for ( string name : name ) { column column ; search : if ( table . do column exist ( name ) ) { column = table . get column ( name ) ; } else { name = string utils . to upper english ( name ) ; if ( table . do column exist ( name ) ) { column = table . get column ( name ) ; } else { for ( column c : table . get columns ( ) ) { if ( c . get name ( ) . equal ignore case ( name ) ) { column = c ; break search ; } } continue ; } } expression column . add ( new expression column ( db , column ) ) ; all column . add ( column ) ; } } else { clear ( null ) ; return new local result ( ) ; } } else { clear ( null ) ; return new local result ( ) ; } int column count = expression column . size ( ) ; if ( column count == 0 ) { clear ( null ) ; return new local result ( ) ; } local result result = new local result ( session , expression column . to array ( new expression [ 0 ] ) , column count ) ; for ( map < column , value > map : data ) { value [ ] row = new value [ column count ] ; for ( map . entry < column , value > entry : map . entry set ( ) ) { int idx = all column . index of ( entry . get key ( ) ) ; if ( idx > = 0 ) { row [ idx ] = entry . get value ( ) ; } } for ( int i = 0 ; i < column count ; i++ ) { if ( row [ i ] == null ) { row [ i ] = value null . instance ; } } result . add row ( row ) ; } clear ( null ) ; return result ; }
public void set column name ( string column name ) { this . column name = column name ; }
public string get keywords ( ) { return info . get string ( c o s name . keywords ) ; }
public string get content type ( ) { string a [ ] = get mime header ( `` content- type `` ) ; if ( a ! = null & & a . length > 0 ) { return a [ 0 ] ; } else { return null ; } }
public static boolean be array ( object obj ) { return ( obj ! = null & & obj . get class ( ) . be array ( ) ) ; }
protect void set byte count ( final long count ) { this . write = count ; }
public int get type ( ) { return block ; }
public store get store ( ) { return store ; }
public boolean have ( string name ) { return index by name . contains key ( name ) ; }
public file store get file store ( ) { return file store ; }
public boolean get rollback on return ( ) { return rollback on return ; }
public store get store ( ) { return store ; }
public void set cache ( boolean cache ) { this . cache = cache ; }
public string dump ( ) { return dump ( 0 , ( int ) size ( ) ) ; }
public void increase bound ( object bound , object add ) { spatial key b = ( spatial key ) bound ; spatial key a = ( spatial key ) add ; for ( int i = 0 ; i < dimension ; i++ ) { b . set min ( i , math . min ( b . min ( i ) , a . min ( i ) ) ) ; b . set max ( i , math . max ( b . max ( i ) , a . max ( i ) ) ) ; } }
public byte [ ] read byte ( ) throw buffer exception { int len = read u int32 a int ( ) ; if ( len < 0 || len > 32768 ) throw new buffer exception ( `` bad item length : `` + len ) ; byte [ ] b = new byte [ len ] ; read raw byte ( b ) ; return b ; }
public int count ( ) { return count ; }
public void add synonym ( table synonym synonym ) { synonyms = add ( synonyms , synonym ) ; }
public void set value ( object value ) { this . value = value ; }
public void set batch size ( int batch size ) { this . batch size = batch size ; }
public table synonym get synonym ( string name ) { return synonym . get ( name ) ; }
public final int column count ( ) { return column ; }
public void set calendar ( calendar calendar ) { this . calendar = calendar ; }
public int get year ( ) { return date time utils . year from date value ( date value ) ; }
public string a string ( string name ) { string builder buff = new string builder ( ) ; if ( name ! = null ) { data utils . append map ( buff , `` name `` , name ) ; } if ( create version ! = 0 ) { data utils . append map ( buff , `` create version `` , create version ) ; } string type = get type ( ) ; if ( type ! = null ) { data utils . append map ( buff , `` type `` , type ) ; } return buff . to string ( ) ; }
public boolean be be date ( ) { return be date . be set ( field_9_options ) ; }
public synchronize void set convert value ( @ nullable object value ) { this . convert = true ; this . convert value = value ; }
public string get compiler ( ) { string compiler impl = get compiler version ( ) ; if ( fork ) { if ( be jdk compiler ( compiler impl ) ) { compiler impl = `` ext javac `` ; } else { log ( `` since compiler setting be n't classic or modern , `` + `` ignoring fork setting . `` , project . msg_warn ) ; } } return compiler impl ; }
public static date time zone for offset hour minute ( int hour offset , int minute offset ) throw illegal argument exception { if ( hour offset == 0 & & minute offset == 0 ) { return date time zone . utc ; } if ( hour offset < -23 || hour offset > 23 ) { throw new illegal argument exception ( `` hour out of range : `` + hour offset ) ; } if ( minute offset < -59 || minute offset > 59 ) { throw new illegal argument exception ( `` minute out of range : `` + minute offset ) ; } if ( hour offset > 0 & & minute offset < 0 ) { throw new illegal argument exception ( `` positive hour must not have negative minute : `` + minute offset ) ; } int offset = 0 ; try { int hour in minute = hour offset * 60 ; if ( hour in minute < 0 ) { minute offset = hour in minute - math . ab ( minute offset ) ; } else { minute offset = hour in minute + minute offset ; } offset = field utils . safe multiply ( minute offset , date time constant . millis_per_minute ) ; } catch ( arithmetic exception ex ) { throw new illegal argument exception ( `` offset be too large `` ) ; } return for offset millis ( offset ) ; }
public string get table ( ) { return table ; }
public void add group ( string group ) { if ( be wild card a c l value ( group ) ) { throw new illegal argument exception ( `` group `` + group + `` can not be add `` ) ; } if ( ! be all allow ( ) ) { list < string > group list = new link list < string > ( ) ; group list . add ( group ) ; group map . cache group add ( group list ) ; group . add ( group ) ; } }
public set < string > get remove ( ) { return remove ; }
public double get ( time unit unit ) { return get ( 0 , unit ) ; }
protect void set name source start ( int start ) { this . name start= start ; }
protect void validate index ( int index ) { if ( index < 0 || index > size ) { throw new string index out of bound exception ( index ) ; } }
public void set transfer ( c o s base transfer ) { this . transfer = transfer ; }
public byte [ ] get byte ( ) { return byte ; }
public mutable rate new rate ( string name ) { return new rate ( name , name , false ) ; }
public string get default string value ( ) { return default string value ; }
public void set authenticator ( authenticator authenticator ) { this . authenticator = authenticator ; }
public void set name ( string name ) { this . name = name ; }
public string [ ] get exclude mime type ( ) { set < string > exclude = _mime type . get excluded ( ) ; return exclude . to array ( new string [ exclude . size ( ) ] ) ; }
public date time zone get time zone ( ) { return this . time zone ; }
public int get nanos ( ) { return nanos_ ; }
public static double [ ] get envelope ( byte [ ] ewkb ) { envelope target target = new envelope target ( ) ; e w k b utils . parse e w k b ( ewkb , target ) ; return target . get envelope ( ) ; }
public envelope copy ( ) { return new envelope ( this ) ; }
protect static boolean have non empty element ( geometry [ ] geometry ) { for ( int i = 0 ; i < geometry . length ; i++ ) { if ( ! geometry [ i ] . be empty ( ) ) { return true ; } } return false ; }
public j type type ( ) { return type ; }
public int get type ( ) { return type ; }
public string get public i d ( ) { return public i d ; }
public byte [ ] get byte ( ) { return byte ; }
public byte [ ] get byte ( ) { return byte ; }
public static void main ( string [ ] args ) throw exception { system . out . println ( `` get ugi for current user `` ) ; user group information ugi = get current user ( ) ; ugi . print ( ) ; system . out . println ( `` ugi : `` + ugi ) ; system . out . println ( `` auth method `` + ugi . user . get authentication method ( ) ) ; system . out . println ( `` keytab `` + ugi . be keytab ) ; system . out . println ( `` ============================================================ `` ) ; if ( args . length == 2 ) { system . out . println ( `` get ugi from keytab . . . . `` ) ; login user from keytab ( args [ 0 ] , args [ 1 ] ) ; get current user ( ) . print ( ) ; system . out . println ( `` keytab : `` + ugi ) ; system . out . println ( `` auth method `` + login user . user . get authentication method ( ) ) ; system . out . println ( `` keytab `` + login user . be keytab ) ; } }
public int read sign byte ( ) throw i o exception { int sign byte = read ( ) ; return sign byte < 127 ? sign byte : sign byte - 256 ; }
public long long value ( ) { return value ; }
public < t extend enum < ? > > ct enum < t > get enum ( class < t > cl ) { try { ct type < t > t = super . get ( cl ) ; return ( ct enum < t > ) t ; } catch ( exception e ) { return null ; } }
public double get ( time unit unit ) { return get ( 0 , unit ) ; }
public file get pas file ( ) { return this . pas file ; }
public string get provider ( ) { return provider ; }
public boolean be one time task ( ) { return ( this . period < = 0 ) ; }
public version get version ( ) { return version ; }
public int get buffer size ( ) { return buffer size ; }
public void set exit code ( int exit code ) { this . exit code = exit code ; }
public static void main ( string . . . args ) { new profiler ( ) . run ( args ) ; }
public acl status get acl status ( path path ) throw i o exception { throw new unsupported operation exception ( get class ( ) . get simple name ( ) + `` do n't support get acl status `` ) ; }
public static long length ( final boolean [ ] [ ] array ) { final int length = array . length ; return length == 0 ? 0 : start ( length - 1 ) + array [ length - 1 ] . length ; }
public void set host ( string host ) { this . host = host ; } // -- void set host ( string )
public file get file ( ) { return f file ; }
public float get request per second ( ) { return request per second ; }
public void set quota ( path src , long quota ) throw i o exception { dfs . set quota ( src , quota , hdfs constant . quota_dont_set ) ; }
public long get quota ( ) { return quota ; }
public boolean be queue ( ) { return queue ; }
public void set action ( string action ) { this . action = action ; }
public void set use naming ( boolean use naming ) { this . use name = use name ; }
public file get file ( ) { return f file ; }
public statistic get statistic ( ) { return stats . get statistic ( ) ; }
public configuration get conf ( ) { return conf ; }
public string get canonical service name ( ) { return dfs . get canonical service name ( ) ; }
public final boolean local ( ) { return local ; }
public path get path ( ) { return path ; }
public static void delete ( file system f , string name ) throw i o exception { path dir = new path ( name ) ; path data = new path ( dir , data_file_name ) ; path index = new path ( dir , index_file_name ) ; f . delete ( data , true ) ; f . delete ( index , true ) ; f . delete ( dir , true ) ; }
public file get file ( ) { return f file ; }
public status get status ( ) { return null ; }
public delegate permission get permission ( ) { return this . permission ; }
public void remove default acl ( path path ) throw i o exception { throw new unsupported operation exception ( get class ( ) . get simple name ( ) + `` do n't support remove default acl `` ) ; }
public file get dir ( ) { return this . dir ; }
public input output < t > seek ceil ( bytes ref target ) throw i o exception { this . target = target ; target length = target . length ; super . do seek ceil ( ) ; return set result ( ) ; }
public void write ( byte [ ] b ) throw i o exception { count += b . length ; super . write ( b ) ; }
public object [ ] to array ( ) { object [ ] o = new object [ _size ] ; int i = 0 ; for ( t linkable link = _head ; link ! = null ; link = link . get next ( ) ) { o [ i++ ] = link ; } return o ; }
public void set context ( string context ) { if ( context . start with ( `` / `` ) ) { this . context = context ; } else { this . context = `` / `` + context ; } }
public string get path ( ) { return path ; }
public static list < acl entry > filter acl entry by acl spec ( list < acl entry > exist acl , list < acl entry > in acl spec ) throw acl exception { validated acl spec acl spec = new validate acl spec ( in acl spec ) ; array list < acl entry > acl builder = list . new array list with capacity ( max_entries ) ; enum map < acl entry scope , acl entry > provide mask = map . new enum map ( acl entry scope . class ) ; enum set < acl entry scope > mask dirty = enum set . none of ( acl entry scope . class ) ; enum set < acl entry scope > scope dirty = enum set . none of ( acl entry scope . class ) ; for ( acl entry exist entry : exist acl ) { if ( acl spec . contains key ( exist entry ) ) { scope dirty . add ( exist entry . get scope ( ) ) ; if ( exist entry . get type ( ) == mask ) { mask dirty . add ( exist entry . get scope ( ) ) ; } } else { if ( exist entry . get type ( ) == mask ) { provide mask . put ( exist entry . get scope ( ) , exist entry ) ; } else { acl builder . add ( exist entry ) ; } } } copy default if need ( acl builder ) ; calculate mask ( acl builder , provide mask , mask dirty , scope dirty ) ; return build and validate acl ( acl builder ) ; }
public static list < acl entry > filter acl entry by acl spec ( list < acl entry > exist acl , list < acl entry > in acl spec ) throw acl exception { validated acl spec acl spec = new validate acl spec ( in acl spec ) ; array list < acl entry > acl builder = list . new array list with capacity ( max_entries ) ; enum map < acl entry scope , acl entry > provide mask = map . new enum map ( acl entry scope . class ) ; enum set < acl entry scope > mask dirty = enum set . none of ( acl entry scope . class ) ; enum set < acl entry scope > scope dirty = enum set . none of ( acl entry scope . class ) ; for ( acl entry exist entry : exist acl ) { if ( acl spec . contains key ( exist entry ) ) { scope dirty . add ( exist entry . get scope ( ) ) ; if ( exist entry . get type ( ) == mask ) { mask dirty . add ( exist entry . get scope ( ) ) ; } } else { if ( exist entry . get type ( ) == mask ) { provide mask . put ( exist entry . get scope ( ) , exist entry ) ; } else { acl builder . add ( exist entry ) ; } } } copy default if need ( acl builder ) ; calculate mask ( acl builder , provide mask , mask dirty , scope dirty ) ; return build and validate acl ( acl builder ) ; }
public string get file permission ( ) { return this . file permission ; } // -- string get file permission ( )
public void set permission ( path p , fs permission permission ) throw i o exception { }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public spark launcher add app args ( string . . . args ) { for ( string arg : args ) { check not null ( arg , `` arg `` ) ; builder . app args . add ( arg ) ; } return this ; }
protect string format args ( object [ ] args ) { string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < args . length ; i++ ) { sb . append ( format obj ( args [ i ] ) ) ; if ( i < args . length-1 ) sb . append ( `` , `` ) ; } return sb . to string ( ) ; }
public void set link ( boolean value ) { this . link = value ; }
public void set maximum depth ( int depth ) { this . max depth = depth ; }
public void set connector ( connector [ ] connector ) { if ( connector ! = null ) { for ( connector connector : connector ) { if ( connector . get server ( ) ! = this ) throw new illegal argument exception ( `` connector `` + connector + `` can not be share among server `` + connector . get server ( ) + `` and server `` + this ) ; } } connector [ ] old connector = get connector ( ) ; update bean ( old connector , connector ) ; _connectors . remove all ( array . a list ( old connector ) ) ; if ( connector ! = null ) _connectors . add all ( array . a list ( connector ) ) ; }
public web app parameter get web app ( ) { return web app ; }
public void set server ( server server ) { this . server = server ; }
public static void write to ( input stream in , output stream out ) throw i o exception { int read ; final byte [ ] data = new byte [ buffer_size ] ; while ( ( read = in . read ( data ) ) ! = -1 ) { out . write ( data , 0 , read ) ; } }
public void set ( int value ) { this . value = value ; }
public void set limit ( long limit ) { this . limit = limit ; }
public boolean equal ( object o ) { if ( ! ( o instanceof v long writable ) ) return false ; v long writable other = ( v long writable ) o ; return this . value == other . value ; }
public final boolean be direct ( ) { return be direct ; }
public compressor input stream create compressor input stream ( final string name , final input stream in ) throw compressor exception { return create compressor input stream ( name , in , decompress concatenate ) ; }
public static file system get ( configuration conf ) throw i o exception { return get ( get default uri ( conf ) , conf ) ; }
public string get filename ( ) { return filename ; }
public configuration get conf ( ) { return conf ; }
public static compressor get zlib compressor ( configuration conf ) { return ( be native zlib load ( conf ) ) ? new zlib compressor ( conf ) : new build in zlib deflater ( zlib factory . get compression level ( conf ) . compression level ( ) ) ; }
public void reinit ( configuration conf ) { reset ( ) ; if ( conf == null ) { return ; } end ( stream ) ; level = zlib factory . get compression level ( conf ) ; strategy = zlib factory . get compression strategy ( conf ) ; stream = init ( level . compression level ( ) , strategy . compression strategy ( ) , window bit . window bit ( ) ) ; if ( log . be debug enable ( ) ) { log . debug ( `` reinit compressor with new compression configuration `` ) ; } }
public final class get element type ( ) { return this . element type ; }
public int length ( ) { return key buffer . length ( ) ; }
public void set ( boolean value ) { this . value = value ; }
public static void delete ( file system f , string name ) throw i o exception { path dir = new path ( name ) ; path data = new path ( dir , data_file_name ) ; path index = new path ( dir , index_file_name ) ; f . delete ( data , true ) ; f . delete ( index , true ) ; f . delete ( dir , true ) ; }
public boolean delete ( path f ) throw i o exception { return delete ( f , true ) ; }
public int compare to ( error type that ) { return value - that . value ; }
public string get file path ( ) { return file path ; }
public deployment option set instance ( int instance ) { this . instance = instance ; return this ; }
public void set ( object instance ) { this . declared class = instance . get class ( ) ; this . instance = instance ; }
public boolean equal ( object o ) { if ( ! ( o instanceof byte writable ) ) { return false ; } byte writable other = ( byte writable ) o ; return this . value == other . value ; }
public static < a extend comparable < a > > comparable check builder < a > be ( final a a ) { return new comparable check builder < > ( a ) ; }
public static int to lower ( int c ) { return to low [ c & 0xff ] & 0xff ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public double get time ( ) { return time ; }
public handler ref get handler ( ) { return handler . remove ( 0 ) ; }
public call get call ( ) { return call ; }
protect string get client thread name ( socket socket ) { return string . format ( `` logback socket node ( client : % s ) `` , socket . get remote socket address ( ) ) ; }
public handler [ ] get and set handler ( final handler [ ] handler ) throw security exception { final handler [ ] safe handler = handler . clone ( ) ; for ( handler handler : safe handler ) { if ( handler == null ) { throw new illegal argument exception ( `` a handler be null `` ) ; } } return logger node . set handler ( safe handler ) ; }
public static int get call id ( ) { call call = cur call . get ( ) ; return call ! = null ? call . call id : rpc constant . invalid_call_id ; }
public static boolean register connection manager ( http client connection manager connection manager ) { return register connection manager ( connection manager , default_max_idle_millis ) ; }
public int get max queue size ( ) { return max queue size ; }
public final throwable get throwable ( ) { return throwable ; }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public object get context ( ) { return context ; }
public void writer critical section exit ( long critical value at enter ) { ( critical value at enter < 0 ? odd end epoch updater : even end epoch updater ) . get and increment ( this ) ; }
public void set tag ( tag tag ) { this . tag = tag ; }
public void start ( ) throw exception { start ( false ) ; }
public final void set value ( string value ) { set value ( new string [ ] { value } ) ; }
public string key ( ) { return key ; }
public static option builder with description ( string description ) { instance . description = description ; return instance ; }
public void set counter ( counter counter ) { this . counter = counter ; }
public string name ( ) { return name ; }
public void tick ( ) { final long count = uncounted . sum then reset ( ) ; final double instant rate = count / interval ; if ( initialize ) { rate += ( alpha * ( instant rate - rate ) ) ; } else { rate = instant rate ; initialize = true ; } }
public void set snapshot ( snapshot snapshot ) { this . snapshot = snapshot ; } // -- void set snapshot ( snapshot )
protect void clear change event ( ) { on change list . clear ( ) ; }
static public void reset ( ) { logger factory . reset ( ) ; }
public inet socket address get address ( ) { inet socket address addr = http server . get connector address ( 0 ) ; assert addr . get port ( ) ! = 0 ; return addr ; }
protect string get client thread name ( socket socket ) { return string . format ( `` logback socket node ( client : % s ) `` , socket . get remote socket address ( ) ) ; }
public node get node ( ) { return node ; }
public node get node ( ) { return node ; }
public void set locale ( locale loc ) { this . response . set locale ( loc ) ; }
public boolean be namespace aware ( ) { return namespace aware ; }
public string get node rack name ( ) { this . read lock . lock ( ) ; try { return this . node rack name ; } finally { this . read lock . unlock ( ) ; } }
public location get location ( ) { return this . location ; }
public level get level ( ) { return level ; }
public int get capacity ( ) { return point . length ; }
public void set dir ( string d ) { this . dir = get project ( ) . resolve file ( d ) ; }
public type i d get value type i d ( ) { return this . type i d value ; }
public type i d get key type i d ( ) { return this . type i d key ; }
public void deserialize snapshot ( input archive ia ) throw i o exception { clear ( ) ; serialize utils . deserialize snapshot ( get data tree ( ) , ia , get session with time out ( ) ) ; initialize = true ; }
public collection < string > get group ( ) { return group ; }
public void add group ( string group ) { if ( be wild card a c l value ( group ) ) { throw new illegal argument exception ( `` group `` + group + `` can not be add `` ) ; } if ( ! be all allow ( ) ) { list < string > group list = new link list < string > ( ) ; group list . add ( group ) ; group map . cache group add ( group list ) ; group . add ( group ) ; } }
public string to string ( ) { string builder sb = new string builder ( 256 ) ; sb . append ( `` ( `` ) ; sb . append ( get subject ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get predicate ( ) ) ; sb . append ( `` , `` ) ; sb . append ( get object ( ) ) ; sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
public secret key get secret key ( ) { return ( ( octet sequence key ) get j w k set ( ) . get key ( ) . get ( 0 ) ) . to secret key ( ) ; }
public int read int ( ) throw i o exception { return read int ( this ) ; }
public void add group ( string group ) { if ( be wild card a c l value ( group ) ) { throw new illegal argument exception ( `` group `` + group + `` can not be add `` ) ; } if ( ! be all allow ( ) ) { list < string > group list = new link list < string > ( ) ; group list . add ( group ) ; group map . cache group add ( group list ) ; group . add ( group ) ; } }
public long get n ( ) { return n ; }
public int get port ( ) { return port ; }
public int get id ( ) { return id ; }
public boolean add token ( token < ? extend token identifier > token ) { return ( token ! = null ) ? add token ( token . get service ( ) , token ) : false ; }
public boolean equal ( final object o ) { if ( this == o ) return true ; if ( value == null ) return false ; if ( ! ( o instanceof secret ) ) return false ; secret other secret = ( secret ) o ; return equal s h a256 base ( other secret ) ; }
public boolean be manage ( ) { return f be manage ; }
public void insert ( java token new token ) { assert not null ( new token ) ; get previous token ( ) . if present ( p - > { p . next token = new token ; new token . previous token = p ; } ) ; previous token = new token ; new token . next token = this ; }
public credential get credential ( ) { return credential ; }
public collection < string > get group ( ) { return group ; }
protect string get keytab ( ) { return keytab ; }
public static map synchronize map ( map map ) { return collection . synchronize map ( map ) ; }
public void stop ( ) { start = false ; if ( service ! = null ) { service . stop ( ) ; } }
public void set task executor ( async task executor task executor ) { this . task executor = task executor ; }
public output < float > weight ( ) { return weight ; }
public header configurer < h > default disable ( ) { this . content type option . disable ( ) ; this . xss protection . disable ( ) ; this . cache control . disable ( ) ; this . hsts . disable ( ) ; this . frame option . disable ( ) ; return this ; }
public void set exit code ( int exit code ) { this . exit code = exit code ; }
public string get configuration ( ) { return this . configuration ; } // -- string get configuration ( )
public static local file system get local ( configuration conf ) throw i o exception { return ( local file system ) get ( local file system . name , conf ) ; }
public configuration get configuration ( ) { return conf ; }
public static boolean be native ( int flag ) { return ( flags & acc native ) ! = 0 ; }
public static method [ ] get all method ( class < ? > clazz ) { if ( clazz == null ) { throw new illegal argument exception ( `` you must specify a class in order to get the method . `` ) ; } set < method > method = new link hash set < method > ( ) ; class < ? > this type = clazz ; while ( this type ! = null ) { final class < ? > type = this type ; final method [ ] declare method = access controller . do privilege ( new privilege action < method [ ] > ( ) { public method [ ] run ( ) { return type . get declare method ( ) ; } } ) ; for ( method method : declare method ) { method . set accessible ( true ) ; method . add ( method ) ; } collection . add all ( method , type . get method ( ) ) ; this type = this type . get superclass ( ) ; } return method . to array ( new method [ method . size ( ) ] ) ; }
public boolean be enable shutdown hook ( ) { return enable shutdown hook ; }
public boolean remove shutdown hook ( runnable shutdown hook ) { if ( shutdown in progress . get ( ) ) { throw new illegal state exception ( `` shutdown in progress , can not remove a shutdown hook `` ) ; } return hook . remove ( new hook entry ( shutdown hook , 0 ) ) ; }
public boolean be stop ( ) { return run state . be stop ( ) ; }
protect long sleep for ( ) { return 250 ; }
public string get revision ( ) { return revision ; }
public string get checksum policy ( ) { return checksum policy ; }
public permission create permission ( ) { perm = ( perm == null ) ? new permission ( ) : perm ; return perm ; }
public string get auth type ( ) { return this . auth type ; }
public reader reader value ( ) { return field data instanceof reader ? ( reader ) field data : null ; }
public long get quota ( ) { return quota ; }
public policy get policy ( ) { return policy ; }
public void write byte ( final byte octet ) { if ( remain ( ) < 1 ) { if ( index == block . size ( ) - 1 ) { allocate new block ( ) ; } index++ ; current = block . get ( index ) ; } final block block = current ; block . data [ block . limit ] = octet ; block . limit++ ; }
public configuration get conf ( ) { return conf ; }
public boolean mark support ( ) { return true ; }
public int get component index ( ) { return component index ; }
public static boolean be valid name for component ( string component ) { if ( component . equal ( `` . `` ) || component . equal ( `` . . `` ) || component . index of ( `` : `` ) > = 0 || component . index of ( `` / `` ) > = 0 ) { return false ; } return ! be reserve path component ( component ) ; }
public string get suffix ( ) { return suffix ; }
public long capacity ( ) { return capacity . get ( ) ; }
public void set date format ( string date format ) { super . set internal date format ( new simple date format ( date format ) ) ; }
public void write ( file new file ) throw i o exception { try ( p o i f s file system fs = p o i f s file system . create ( new file ) ) { write ( f ) ; f . write filesystem ( ) ; } }
public f status get status ( ) throw i o exception { return get status ( null ) ; }
public get request refresh ( boolean refresh ) { this . refresh = refresh ; return this ; }
public void set roll upgrade marker ( list < storage directory > dn storage dirs ) throw i o exception { for ( storage directory sd : dn storage dirs ) { file bp root = get bp root ( blockpool i d , sd . get current dir ( ) ) ; file marker file = new file ( bp root , rolling_upgrade_marker_file ) ; if ( ! storage with roll upgrade marker . contains ( bp root . to string ( ) ) ) { if ( ! marker file . exists ( ) & & marker file . create new file ( ) ) { log . info ( `` create `` + marker file ) ; } else { log . info ( marker file + `` already exist . `` ) ; } storages with roll upgrade marker . add ( bp root . to string ( ) ) ; storage without roll upgrade marker . remove ( bp root . to string ( ) ) ; } } }
public long get balancer bandwidth value ( ) { return this . bandwidth ; }
public void set canonical ( boolean canonical ) { this . canonical = canonical ; }
public j block init ( ) { if ( init == null ) init = new j block ( ) ; return init ; }
public void write byte ( final byte octet ) { if ( remain ( ) < 1 ) { if ( index == block . size ( ) - 1 ) { allocate new block ( ) ; } index++ ; current = block . get ( index ) ; } final block block = current ; block . data [ block . limit ] = octet ; block . limit++ ; }
public void reset ( ) { if ( block reuse ! = no_reuse ) { block . for each ( block reuse ) ; } block . clear ( ) ; ram byte use = 0 ; current block = empty ; }
public int remain ( ) { return current . remain ( ) ; }
public int count ( ) { return count ; }
public synchronize void set parent ( part parent ) { this . parent = parent ; }
public void write out ( output stream out ) throw i o exception { out . write ( _header ) ; out . write ( _data ) ; }
public object get negotiate property ( string name ) { return sasl client . get negotiated property ( name ) ; }
public restore snapshot request partial ( boolean partial ) { this . partial = partial ; return this ; }
public int get layout version ( ) { return layout version ; }
public static inet socket address create socket addr ( string target ) { return create socket addr ( target , -1 ) ; }
public string key ( ) { return key ; }
public boolean add token ( token < ? extend token identifier > token ) { return ( token ! = null ) ? add token ( token . get service ( ) , token ) : false ; }
public void write to ( final output stream out ) throw i o exception { for ( final block block : block ) { out . write ( block . data , 0 , block . limit ) ; } }
public void write byte ( final byte octet ) { if ( remain ( ) < 1 ) { if ( index == block . size ( ) - 1 ) { allocate new block ( ) ; } index++ ; current = block . get ( index ) ; } final block block = current ; block . data [ block . limit ] = octet ; block . limit++ ; }
public void close ( ) { if ( replica ! = null ) { if ( anchor ) { replica . remove no checksum anchor ( ) ; } replica . unref ( ) ; } replica = null ; }
public int remain ( ) { return current . remain ( ) ; }
public boolean mark a stale ( ) { return mark a stale ; }
public graph q l directive get schema directive ( string directive name ) { return schema directive . get directive ( directive name ) ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public string to turtle ( ) { string val = this . value ; val = val . replace ( `` \ `` `` , `` \\\ `` `` ) ; val = `` \ `` `` +val+ `` \ `` `` ; if ( data type == null ) { if ( language ! = null ) { val = val+ `` @ `` +language ; } } else { val = val+ `` ^^ < `` + data type . get xml schema u r i string ( ) + `` > `` ; } return val ; }
public void set layout ( layout manager l ) { }
public static checksum checksum ( file file , checksum checksum ) throw i o exception { if ( file . be directory ( ) ) { throw new illegal argument exception ( `` checksum ca n't be compute on directory `` ) ; } input stream in = null ; try { in = new check input stream ( new file input stream ( file ) , checksum ) ; i o utils . copy ( in , new null output stream ( ) ) ; } finally { i o utils . close quietly ( in ) ; } return checksum ; }
public static checksum checksum ( file file , checksum checksum ) throw i o exception { if ( file . be directory ( ) ) { throw new illegal argument exception ( `` checksum ca n't be compute on directory `` ) ; } input stream in = null ; try { in = new check input stream ( new file input stream ( file ) , checksum ) ; i o utils . copy ( in , new null output stream ( ) ) ; } finally { i o utils . close quietly ( in ) ; } return checksum ; }
public void clear roll upgrade marker ( list < storage directory > dn storage dirs ) throw i o exception { for ( storage directory sd : dn storage dirs ) { file bp root = get bp root ( blockpool i d , sd . get current dir ( ) ) ; file marker file = new file ( bp root , rolling_upgrade_marker_file ) ; if ( ! storage without roll upgrade marker . contains ( bp root . to string ( ) ) ) { if ( marker file . exists ( ) ) { log . info ( `` delete `` + marker file ) ; do finalize ( sd . get current dir ( ) ) ; if ( ! marker file . delete ( ) ) { log . warn ( `` fail to delete `` + marker file ) ; } } storage without roll upgrade marker . add ( bp root . to string ( ) ) ; storage with roll upgrade marker . remove ( bp root . to string ( ) ) ; } } }
public void set roll upgrade marker ( list < storage directory > dn storage dirs ) throw i o exception { for ( storage directory sd : dn storage dirs ) { file bp root = get bp root ( blockpool i d , sd . get current dir ( ) ) ; file marker file = new file ( bp root , rolling_upgrade_marker_file ) ; if ( ! storage with roll upgrade marker . contains ( bp root . to string ( ) ) ) { if ( ! marker file . exists ( ) & & marker file . create new file ( ) ) { log . info ( `` create `` + marker file ) ; } else { log . info ( marker file + `` already exist . `` ) ; } storages with roll upgrade marker . add ( bp root . to string ( ) ) ; storage without roll upgrade marker . remove ( bp root . to string ( ) ) ; } } }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public static buffer get slice end ( ) { return slice end ; }
public long get last volume failure date ( ) { return this . last volume failure date ; }
public long start recovery ( index shard index shard , discovery node source node , peer recovery target service . recovery listener listener , time value activity timeout ) { recovery target recovery target = new recovery target ( index shard , source node , listener ) ; start recovery internal ( recovery target , activity timeout ) ; return recovery target . recovery id ( ) ; }
public static list < acl entry > get minimal acl ( fs permission perm ) { return list . new array list ( new acl entry . builder ( ) . set scope ( acl entry scope . access ) . set type ( acl entry type . user ) . set permission ( perm . get user action ( ) ) . build ( ) , new acl entry . builder ( ) . set scope ( acl entry scope . access ) . set type ( acl entry type . group ) . set permission ( perm . get group action ( ) ) . build ( ) , new acl entry . builder ( ) . set scope ( acl entry scope . access ) . set type ( acl entry type . other ) . set permission ( perm . get other action ( ) ) . build ( ) ) ; }
public static list transpose ( list list ) { list result = new array list ( ) ; if ( list . be empty ( ) ) return result ; int min size = integer . max_value ; for ( object list like : list ) { list list = ( list ) default type transformation . cast to type ( list like , list . class ) ; if ( list . size ( ) < min size ) min size = list . size ( ) ; } if ( min size == 0 ) return result ; for ( int i = 0 ; i < min size ; i++ ) { result . add ( new array list ( ) ) ; } for ( object list like : list ) { list list = ( list ) default type transformation . cast to type ( list like , list . class ) ; for ( int i = 0 ; i < min size ; i++ ) { list result list = ( list ) result . get ( i ) ; result list . add ( list . get ( i ) ) ; } } return result ; }
public double [ ] get double array ( long offset , int array size ) { double [ ] buf = new double [ array size ] ; read ( offset , buf , 0 , array size ) ; return buf ; }
public static int try remove reference ( i node inode ) { if ( ! inode . be reference ( ) ) { return -1 ; } return remove reference ( inode . a reference ( ) ) ; }
public final void add to inode map ( i node inode ) { if ( inode instanceof i node with additional field ) { inode map . put ( inode ) ; if ( ! inode . be symlink ( ) ) { final x attr feature xaf = inode . get x attr feature ( ) ; add encryption zone ( ( i node with additional field ) inode , xaf ) ; } } }
protect void build schema ( grakn tx tx ) { } ;
public access get access ( ) { return this . access ; }
protect void set base u r i ( parse u r i base u r i ) { this . base u r i = base u r i ; }
public void set log writer ( final print writer out ) { log writer = out ; }
public synchronize string [ ] get not include file ( ) { slow scan ( ) ; string [ ] file = new string [ file not include . size ( ) ] ; file not include . copy into ( file ) ; return file ; }
public replication type get replication type ( ) { return replication type ; }
public final void add to inode map ( i node inode ) { if ( inode instanceof i node with additional field ) { inode map . put ( inode ) ; if ( ! inode . be symlink ( ) ) { final x attr feature xaf = inode . get x attr feature ( ) ; add encryption zone ( ( i node with additional field ) inode , xaf ) ; } } }
public void set snapshot ( snapshot snapshot ) { this . snapshot = snapshot ; } // -- void set snapshot ( snapshot )
public int get late snapshot id ( ) { precondition . check state ( ! be snapshot ) ; return snapshot id ; }
public f volume spi get volume ( ) { return volume ; }
public long get total ( phase phase ) { long sum = 0 ; for ( step track tracking : phase . get ( phase ) . step . value ( ) ) { if ( track . total ! = long . min_value ) { sum += track . total ; } } return sum ; }
public long get elapsed time ( phase phase , step step ) { return get elapsed time ( get step track ( phase , step ) ) ; }
public type get type ( ) { return type ; }
public void set balancer bandwidth ( long bandwidth ) throw i o exception { dfs . set balancer bandwidth ( bandwidth ) ; }
public void write to ( final output stream out ) throw i o exception { for ( final block block : block ) { out . write ( block . data , 0 , block . limit ) ; } }
public void set image ( final image image ) { this . image = image ; }
public static uuid random ( ) { return uuid . random u u i d ( ) ; }
public f volume spi get volume ( ) { return volume ; }
public string get name ( ) { return replica name ; }
public void disconnect ( ) { if ( ! be connect ( ) ) { return ; } try { connection . close ( ) ; } catch ( j m s exception e ) { jta logger . i18 n logger . warn_failed_to_close_jms_connection ( connection . to string ( ) , e ) ; } finally { connection = null ; session = null ; } }
public object get ( int index , scriptable start ) { if ( external data ! = null ) { if ( index < external data . get array length ( ) ) { return external data . get array element ( index ) ; } return scriptable . not_found ; } slot slot = get slot ( null , index , slot_query ) ; if ( slot == null ) { return scriptable . not_found ; } return slot . get value ( start ) ; }
public object get proxy ( ) { return proxy ; }
public void set image ( final image image ) { this . image = image ; }
public static < e > list < e > get list ( object list ) { return get list ( list , false ) ; }
public double get double l e ( int index ) { return double . long bit to double ( get long l e ( index ) ) ; }
public static double [ ] to primitive ( final double [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return empty_double_array ; } final double [ ] result = new double [ array . length ] ; for ( int i = 0 ; i < array . length ; i++ ) { result [ i ] = array [ i ] . double value ( ) ; } return result ; }
public final void add ( byte . . . element ) { add ( element , 0 , element . length ) ; }
public list < ? extend c o s base > to list ( ) { list < c o s base > ret list = new array list < c o s base > ( size ( ) ) ; for ( int i = 0 ; i < size ( ) ; i++ ) { ret list . add ( get ( i ) ) ; } return ret list ; }
protect void ensure capacity ( final int require capacity ) { if ( require capacity > this . buffer . capacity ( ) ) { expand capacity ( require capacity ) ; } }
public record [ ] get child record ( ) { return null ; }
public v put ( k key , v value ) { return map . put ( key , value ) ; }
public void set counter ( counter counter ) { this . counter = counter ; }
public url get url ( ) { return url ; }
public void disable transport ( string transport name ) { if ( valid transport ! = null ) { valid transport . remove element ( transport name ) ; } }
public static string l get x attr ( string path , string name ) throw i o exception { return l get x attr ( path , name , native . get default string encoding ( ) ) ; }
public path get output index file for write ( long size ) throw i o exception { path attempt index output = new path ( get attempt output dir ( ) , map_output_filename_string + map_output_index_suffix_string ) ; return l dir alloc . get local path for write ( attempt index output . to string ( ) , size , conf ) ; }
public path get output file ( ) throw i o exception { path attempt output = new path ( get attempt output dir ( ) , map_output_filename_string ) ; return l dir alloc . get local path to read ( attempt output . to string ( ) , conf ) ; }
public path get output index file for write ( long size ) throw i o exception { path attempt index output = new path ( get attempt output dir ( ) , map_output_filename_string + map_output_index_suffix_string ) ; return l dir alloc . get local path for write ( attempt index output . to string ( ) , size , conf ) ; }
public void spill ( ) throw i o exception { spill ( long . max_value , this ) ; }
public string get rack ( ) { return rack ; }
public static file create temp dir ( ) throw i o exception { return default groovy static method . create temp dir ( null ) ; }
public void set counter ( counter counter ) { this . counter = counter ; }
public void task counter ( ) { try { require task ( ) ; } catch ( exception e ) { render text ( e . get message ( ) ) ; return ; } if ( app . get task ( ) ! = null ) { set title ( string helper . join ( `` counter for `` , $ ( task_id ) ) ) ; } render ( counter page ( ) ) ; }
public static i o file filter a file filter ( file filter filter ) { return new delegate file filter ( filter ) ; }
public string get prefix ( ) { return prefix ; }
public configuration get conf ( ) { return conf ; }
public boolean be reduce ( ) { return reduce ; }
public status get status ( ) { return null ; }
public string get filename ( ) { string filename = get file unicode ( ) ; if ( filename == null ) { filename = get file do ( ) ; } if ( filename == null ) { filename = get file mac ( ) ; } if ( filename == null ) { filename = get file unix ( ) ; } if ( filename == null ) { filename = get file ( ) ; } return filename ; }
public synchronize void set job conf ( job conf job conf ) { try { super . set job ( org . apache . hadoop . mapreduce . job . get instance ( job conf ) ) ; } catch ( i o exception ioe ) { log . info ( `` exception `` + ioe ) ; } }
public long get finish time ( ) { return finish time ; }
protect static i problem location core [ ] filter ( i problem location core [ ] problem , int [ ] problem id ) { array list < i problem location core > result= new array list < > ( ) ; for ( i problem location core problem : problem ) { if ( contains ( problem id , problem . get problem id ( ) ) & & ! contains ( result , problem ) ) { result . add ( problem ) ; } } return result . to array ( new i problem location core [ result . size ( ) ] ) ; }
public void add credential ( credential credential ) { synchronize ( subject ) { get credential internal ( ) . add all ( credential ) ; } }
public void set jar by class ( class cl ) { string jar = class util . find containing jar ( cl ) ; if ( jar ! = null ) { set jar ( jar ) ; } }
public void set jar ( string jar ) { set ( job context . jar , jar ) ; }
public get mapping request local ( boolean local ) { this . local = local ; return this ; }
public void set pattern ( string pattern ) { f pattern= pattern ; }
public void add mapper ( mapper mapper ) { if ( this . mapper ! = null ) { throw new build exception ( `` can not define more than one mapper `` ) ; } this . mapper = mapper ; }
public string get script ( ) { return script ; }
public task type get task type ( ) { return task id . get task type ( ) ; }
public static void set min input split size ( job job , long size ) { job . get configuration ( ) . set long ( split_minsize , size ) ; }
public static void set min input split size ( job job , long size ) { job . get configuration ( ) . set long ( split_minsize , size ) ; }
public long content length ( ) throw i o exception { return file . size ( this . path ) ; }
public void set option comparator ( comparator comparator ) { if ( comparator == null ) { this . option comparator = new option comparator ( ) ; } else { this . option comparator = comparator ; } }
public iterator iterator ( ) { return new iterator ( ) ; }
public boolean have next ( ) { return have next inet socket address ( ) || have next proxy ( ) || have next postpone ( ) ; }
public void progress ( float progress ) throw i o exception { progress value = progress ; reporter . progress ( ) ; if ( record reader ! = null ) { progress key . set ( progress ) ; record reader . next ( progress key , null value ) ; } }
public configuration get conf ( ) { return conf ; }
public k [ ] get key ( ) { return key . clone ( ) ; }
public configuration get conf ( ) { return conf ; }
public path get commit task path ( task attempt context context ) { return get commit task path ( get app attempt id ( context ) , context ) ; }
public void update progress ( progress info new progress ) { assert peer . equal ( new progress . peer ) ; map < string , progress info > current file = new progress . direction == progress info . direction . in ? receive file : sending file ; current file . put ( new progress . file name , new progress ) ; }
public int read ( ) throw i o exception { throw new i o exception ( ) ; }
protect boolean keep result set ( ) { return false ; }
public int run ( string [ ] args ) throw exception { int exit code = 0 ; try { exit code = init ( args ) ; if ( exit code ! = 0 ) { return exit code ; } if ( command . validate ( ) ) { command . execute ( ) ; } else { exit code = 1 ; } } catch ( exception e ) { e . print stack trace ( err ) ; return 1 ; } return exit code ; }
public path get path ( ) { return path ; }
public configuration get conf ( ) { return conf ; }
public string get phase ( ) { return phase ; }
public throwable get cause ( ) { return cause ; }
public void recover task ( task attempt context task context ) throw i o exception { }
public long get finish time ( ) { return finish time ; }
public long get finish time ( ) { return finish time ; }
public path counter get path counter ( ) { return path counter ; }
public string get id ( ) { return id ; }
public job state get state ( ) { return state ; }
public string get task status ( ) { return task status . to string ( ) ; }
public void set total count ( int total count ) { this . total count = total count ; }
public web test client . response spec value ( string name , consumer < string > consumer ) { string value = get cookie ( name ) . get value ( ) ; this . exchange result . assert with diagnostics ( ( ) - > consumer . accept ( value ) ) ; return this . response spec ; }
public task . status get status ( ) { return status ; }
public string get event ( ) { return event ; }
protect boolean be resource ( ) { return true ; }
public long get length ( ) { return length ; }
public input split [ ] get split ( job conf job , int num split ) throw i o exception { set format ( job ) ; job . set long ( `` mapred . min . split . size `` , long . max_value ) ; return root . get split ( job , num split ) ; }
public void recover task ( task attempt context task context ) throw i o exception { }
public string key ( ) { return key ; }
public url get url ( ) { return url ; }
public string get id ( ) { return id ; }
public string get identifier ( ) { return identifier ; }
public void set max request attempt ( int attempt ) { this . max request attempt = attempt ; }
public string get map id ( ) { return map id ; }
public task id get parent task id ( ) { return parent task ; }
public string to string ( ) { return new string buffer ( ) . append ( `` [ entity ref : `` ) . append ( `` & `` ) . append ( name ) . append ( `` ; `` ) . append ( `` ] `` ) . to string ( ) ; }
public state get state ( ) { return state . get ( ) . get state ( ) ; }
protect void set finish time ( long finish time ) { super . set finish time ( finish time ) ; }
public void set group id ( string group id ) { this . group id = group id ; } // -- void set group id ( string )
public process get process implementation ( ) { if ( process implementation == null & & process implementation class name ! = null ) { synchronize ( this ) { if ( process implementation == null & & process implementation class name ! = null ) { process implementation = classloading utility . load and instantiate class ( process . class , process implementation class name , null ) ; } } } return process implementation ; }
public void set id ( string id ) { this . id = id ; } // -- void set id ( string )
public string get entity ( ) { return entity ; }
public string get domain ( ) { return domain ; }
public void set recovery path ( path recovery path ) { this . recovery path = recovery path ; }
public container get container ( ) { return container ; }
protect path get recovery path ( ) { return recovery path ; }
public long calculate check every millis ( ) { return check every * check every multiplier ; }
public container get container ( ) { return container ; }
public jersey client get client ( ) { return state . get client ( ) ; }
public static int copy dir ( file from dir , file to dir , final string from suffix , string to suffix ) throw i o exception { return copy dir ( from dir , to dir , from suffix , to suffix , ( file filter ) null ) ; }
public static void main ( string [ ] args ) throw i o exception { parse args ( args ) . upgrade ( ) ; }
public static builder builder ( ) { return new builder ( ) ; }
public boolean get convert html code page to u t f8 ( ) { return this . convert html code page to u t f8 ; }
public void set low left y ( float low left y value ) { this . low leave y = low leave y value ; }
public static builder builder ( long high trackable latency millis ) { return new builder ( high trackable latency millis ) ; }
public long get max value ( ) { return ( max value == 0 ) ? 0 : high equivalent value ( max value ) ; }
public static boolean max length ( string value , int max ) { return ( value . length ( ) < = max ) ; }
public long get count at value ( final long value ) throw array index out of bound exception { final int index = math . min ( math . max ( 0 , count array index ( value ) ) , ( count array length - 1 ) ) ; return get count at index ( index ) ; }
public long get count at value ( final long value ) throw array index out of bound exception { final int index = math . min ( math . max ( 0 , count array index ( value ) ) , ( count array length - 1 ) ) ; return get count at index ( index ) ; }
public long get count between value ( final long low value , final long high value ) throw array index out of bound exception { final int low index = math . max ( 0 , count array index ( low value ) ) ; final int high index = math . min ( count array index ( high value ) , ( count array length - 1 ) ) ; long count = 0 ; for ( int i = low index ; i < = high index ; i++ ) { count += get count at index ( i ) ; } return count ; }
public synchronize histogram get interval histogram ( ) { histogram interval histogram = new histogram ( low trackable latency , high trackable latency , number of significant value digit ) ; get interval histogram into ( interval histogram ) ; return interval histogram ; }
public void writer critical section exit ( long critical value at enter ) { ( critical value at enter < 0 ? odd end epoch updater : even end epoch updater ) . get and increment ( this ) ; }
public void increment ( final int index ) throw array index out of bound exception { long critical value at enter = record phaser . writer critical section enter ( ) ; try { active array . increment ( index ) ; } finally { record phaser . writer critical section exit ( critical value at enter ) ; } }
public str tokenizer set quote matcher ( str matcher quote ) { if ( quote ! = null ) { this . quote matcher = quote ; } return this ; }
public junction add ( criterion criterion ) { condition . add ( criterion ) ; return this ; }
public void set proxy ( web proxy proxy ) { this . proxy = proxy ; }
public void add subselect ( entity key key , subselect fetch subquery ) { if ( subselects by entity key == null ) { subselects by entity key = new hash map < > ( 12 ) ; } subselects by entity key . put ( key , subquery ) ; }
public database get database ( ) { return database ; }
public void set transaction completion process ( transaction completion process process , boolean be transaction coordinator share ) { this . be transaction coordinator share = be transaction coordinator share ; this . before transaction process = process . before transaction completion process ; this . after transaction process = process . after transaction completion process ; }
public void set be dirty ( boolean value ) { this . be dirty = value ; }
public version get version ( ) { return version ; }
public string get fetch from ( ) { return this . fetch from ; }
public int get generation ( ) { return generation ; }
public void set table ( string value ) { this . table = value ; }
public void set embed ( string value ) { this . embed = value ; }
public equal builder set test transient ( final boolean test transient ) { this . test transient = test transient ; return this ; }
public void set type ( jaxb cfg event type enum value ) { this . type = value ; }
public void set cascade all ( jaxb empty type value ) { this . cascade all = value ; }
public jaxb empty type get cascade all ( ) { return cascade all ; }
public jaxb empty type get cascade all ( ) { return cascade all ; }
public header configurer < h > default disable ( ) { this . content type option . disable ( ) ; this . xss protection . disable ( ) ; this . cache control . disable ( ) ; this . hsts . disable ( ) ; this . frame option . disable ( ) ; return this ; }
public void set type ( int type ) { this . type = type ; }
public synchronize void set convert value ( @ nullable object value ) { this . convert = true ; this . convert value = value ; }
public json generator get generator ( ) { return null ; }
public time value get background persist interval ( ) { return background persist interval ; }
public boolean be update ( ) { return be update ; }
public string get entity ( ) { return entity ; }
public field set set field ( field field ) { return set field ( new field description . for loaded field ( field ) ) ; }
public constraint find constraint ( session session , string name ) { constraint constraint = constraint . get ( name ) ; if ( constraint == null ) { constraint = session . find local temp table constraint ( name ) ; } return constraint ; }
public string get id ( ) { return id ; }
public synchronize void set include ( string include ) { check attribute allow ( ) ; default pattern . set include ( include ) ; ds = null ; }
public void set exception mapping ( property mapping ) { this . exception mapping = mapping ; }
public boolean have constructor argument value ( ) { return ! this . constructor argument value . be empty ( ) ; }
public byte [ ] get ( ) { return info ; }
public url get url ( ) { return url ; }
public static void format_to varchar ( query engine query engine ) { query engine . get sqm function registry ( ) . name descriptor builder ( `` format `` , `` to_varchar `` ) . set invariant type ( query engine . get type configuration ( ) . get basic type registry ( ) . resolve ( standard basic type . string ) ) . set exact argument count ( 2 ) . set argument list signature ( `` ( datetime a pattern ) `` ) . register ( ) ; }
public static void stddev ( query engine query engine ) { query engine . get sqm function registry ( ) . name aggregate descriptor builder ( `` stddev `` ) . set invariant type ( query engine . get type configuration ( ) . get basic type registry ( ) . resolve ( standard basic type . double ) ) . set exact argument count ( 1 ) . register ( ) ; }
public string get sql ( ) { return this . sql ; }
public long capacity ( ) { return capacity . get ( ) ; }
public pattern get pattern ( ) { return pattern ; }
public string name ( ) { return name ; }
public static boolean need parenthesis for right operand ( expression right operand , infix expression infix expression , i type bind leave operand type ) { return need parenthesis ( right operand , infix expression , infix expression . right_operand_property , leave operand type ) ; }
public void set parameter ( string parameter ) { assert . have text ( parameter , `` parameter name can not be empty or null `` ) ; this . parameter = parameter ; }
public int root ( ) { return root ; }
public string to string ( ) { return to string ( get class ( ) ) + `` [ use default= `` + use default + `` ] `` ; }
public string get domain ( ) { return domain ; }
protect void add conversion ( conversion conversion , field map mapping ) { if ( conversion == null ) { return ; } if ( mapping . be map to index ( ) ) { this . convert index ( conversion ) . add ( map . get index ( ) ) ; } else { this . convert field ( conversion ) . add ( map . get field name ( ) ) ; } }
public boolean add all ( final collection < ? extend attribute > collection ) { return add all ( size ( ) , collection ) ; }
public boolean add token ( token < ? extend token identifier > token ) { return ( token ! = null ) ? add token ( token . get service ( ) , token ) : false ; }
public constraint find constraint ( session session , string name ) { constraint constraint = constraint . get ( name ) ; if ( constraint == null ) { constraint = session . find local temp table constraint ( name ) ; } return constraint ; }
public static boolean be digit ( character self ) { return character . be digit ( self ) ; }
public void set type ( class < ? > type ) { this . type = type ; }
public void set null value ( string empty value ) { this . null value = empty value ; }
public @ not null thread get thread ( ) { return thread ; }
public void requite ( final t bag entry ) { bag entry . set state ( state_not_in_use ) ; final list < object > thread local list = thread list . get ( ) ; if ( thread local list ! = null ) { thread local list . add ( weak thread local ? new weak reference < > ( bag entry ) : bag entry ) ; } synchronizer . signal ( ) ; }
public schema get schema ( ) { return schema ; }
public void set schema ( string schema ) { this . schema = schema ; }
public int last buffer index of ( byte e1 ) { final int buf len = buffer . length ; final int last = one left ( head , buf len ) ; for ( int i = one left ( tail , buf len ) ; i ! = last ; i = one left ( i , buf len ) ) { if ( ( ( buffer [ i ] ) == ( e1 ) ) ) return i ; } return -1 ; }
public int buffer index of ( byte e1 ) { final int last = tail ; final int buf len = buffer . length ; for ( int i = head ; i ! = last ; i = one right ( i , buf len ) ) { if ( ( ( buffer [ i ] ) == ( e1 ) ) ) { return i ; } } return -1 ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public iterator < byte cursor > iterator ( ) { return new value iterator ( ) ; }
public final void add ( byte . . . element ) { add ( element , 0 , element . length ) ; }
public void add ( json element element ) { if ( element == null ) { element = json null . instance ; } element . add ( element ) ; }
public void release ( ) { }
public boolean equal ( final object other ) { if ( other == this ) { return true ; } if ( other instanceof multi key ) { final multi key < ? > other multi = ( multi key < ? > ) other ; return array . equal ( key , other multi . key ) ; } return false ; }
public k get key ( final int index ) { return key [ index ] ; }
public void push ( float e1 , float e2 ) { ensure buffer space ( 2 ) ; buffer [ element count++ ] = e1 ; buffer [ element count++ ] = e2 ; }
public void push ( float e1 , float e2 ) { ensure buffer space ( 2 ) ; buffer [ element count++ ] = e1 ; buffer [ element count++ ] = e2 ; }
public void push ( double e1 ) { ensure buffer space ( 1 ) ; buffer [ element count++ ] = e1 ; }
public boolean be fragment ( ) { return fragment ; }
public normalization get normalization ( ) { return normalization ; }
public xml violation policy get content space policy ( ) { return content space policy ; }
public xml violation policy get content non xml char policy ( ) { return content non xml char policy ; }
public line string get line ( ) { return line ; }
public string get id ( ) { return id ; }
public boolean have task ( ) { return start time > 0 ; }
public normalization get normalization ( ) { return normalization ; }
public string get uri ( ) { return uri ; }
public runnable get runnable ( ) { return this . runnable ; }
public long get bucket span ( ) { return bucket span ; }
protect void generate data ( ) { int size = 0 ; for ( int i=0 ; i < record . length ; i++ ) { size += record [ i ] . get record size ( ) ; } byte data [ ] = i o utils . safely allocate ( size , max_record_length ) ; size = 0 ; for ( int i=0 ; i < record . length ; i++ ) { int this size = record [ i ] . serialize ( size , data ) ; size += this size ; } set data ( data ) ; }
protect void set internal date ( final string date ) { this . date = date ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public void set session cache enable ( boolean enable session cache ) { _session cache enable = enable session caching ; }
public final boolean be cache ( ) { return cache ; }
public string get u r l ( ) { return service . get u r l ( ) ; }
public long get cache miss count ( ) { return cache miss count ; }
public void set request header ( header header ) { header [ ] header = get request header group ( ) . get header ( header . get name ( ) ) ; for ( int i = 0 ; i < header . length ; i++ ) { get request header group ( ) . remove header ( header [ i ] ) ; } get request header group ( ) . add header ( header ) ; }
public boolean be response reject ( ) { return get command result ( ) . be response reject ( ) ; }
public boolean be response thread pool reject ( ) { return get command result ( ) . be response thread pool reject ( ) ; }
public int get number fallback emission ( ) { return get command result ( ) . get event count ( ) . get count ( hystrix event type . fallback_emit ) ; }
public list < hystrix event type > get execution event ( ) { return get command result ( ) . get ordered list ( ) ; }
public @ nullable response < ? > response ( ) { return response ; }
public void set execution ( java . util . list execution ) { this . execution = execution ; } // -- void set execution ( java . util . list )
public void add application ( sequential sequence ) { log override ( `` application `` , application ) ; application = sequence ; }
public void set subject ( string subject ) { this . subject = subject ; }
public float get remain percent ( ) { return d f s util . get percent remain ( remain , capacity ) ; }
public void write to ( final output stream out ) throw i o exception { for ( final block block : block ) { out . write ( block . data , 0 , block . limit ) ; } }
public void write byte ( final byte octet ) { if ( remain ( ) < 1 ) { if ( index == block . size ( ) - 1 ) { allocate new block ( ) ; } index++ ; current = block . get ( index ) ; } final block block = current ; block . data [ block . limit ] = octet ; block . limit++ ; }
public t get ( ) { return t ; }
public final boolean be stream copy optimize ( ) { return my stream copy optimize ; }
public void copy ( ) { set ( current ( ) . copy ( ) ) ; }
public boolean be stream copy optimize ( ) { return my stream copy optimize ; }
public json object to json ( ) { json object json = super . to json ( ) ; http client option converter . to json ( this , json ) ; return json ; }
public charset charset ( ) { return charset ! = null ? charset . for name ( charset ) : null ; }
public static boolean be valid origin ( http request request , collection < string > allow origin ) { assert . not null ( request , `` request must not be null `` ) ; assert . not null ( allow origin , `` allow origin must not be null `` ) ; string origin = request . get header ( ) . get origin ( ) ; if ( origin == null || allow origin . contains ( `` * `` ) ) { return true ; } else if ( collection utils . be empty ( allow origin ) ) { return be same origin ( request ) ; } else { return allow origin . contains ( origin ) ; } }
public setting setting ( ) { return setting ; }
public void put all ( map map ) { if ( map instanceof multi map ) { for ( iterator it = map . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; collection coll = ( collection ) entry . get value ( ) ; put all ( entry . get key ( ) , coll ) ; } } else { for ( iterator it = map . entry set ( ) . iterator ( ) ; it . have next ( ) ; ) { map . entry entry = ( map . entry ) it . next ( ) ; put ( entry . get key ( ) , entry . get value ( ) ) ; } } }
public final o get o s ( ) { return o ; }
public artifact get artifact ( ) { return artifact ; }
public collection get orphan ( string entity name , persistent collection collection ) throw hibernate exception { if ( snapshot == null ) { throw new assertion failure ( `` no collection snapshot for orphan delete `` ) ; } return collection . get orphan ( snapshot , entity name ) ; }
public boolean be root ( ) { return be root ; }
public static void validate mockito usage ( ) { mockito_core . validate mockito usage ( ) ; }
public string get revision ( ) { return revision ; }
public void set u r i resolver ( u r i resolver resolver ) { uri resolver = resolver ; }
public void set ignore method ( string . . . ignored method name ) { this . ignore method = new hash set < string > ( arrays . a list ( ignore method names ) ) ; }
public void set module ( final list < module > module ) { this . module = module ; }
public string get u r l ( ) { return service . get u r l ( ) ; }
public axis engine get engine ( ) { return ( engine ) ; }
public string get identifier ( ) { return identifier ; }
public output stream create output stream ( ) throw i o exception { return create output stream ( null ) ; }
public int root ( ) { return root ; }
public void set cache ( boolean cache ) { this . cache = cache ; }
public line string get line ( ) { return line ; }
public logger get logger ( ) { return logger ; }
protect void append ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i++ ) { append ( str . char at ( i ) ) ; } }
public boolean get boolean value ( ) { return false ; }
public boolean be boolean ( ) { return false ; }
public int get size ( ) { return 0 ; }
public boolean have ( string field name ) { return have ( schema ( ) . get field ( field name ) ) ; }
public string get include ( ) { return include ; }
public source get source ( ) { return source ; }
static public byte [ ] encode ( byte [ ] binary data ) { if ( binary data == null ) return null ; int length data = binary data . length ; int length encode = length data * 2 ; byte [ ] encode data = new byte [ length encode ] ; for ( int i = 0 ; i < length data ; i++ ) { encode data [ i * 2 ] = look up hex alphabet [ ( binary data [ i ] > > 4 ) & 0xf ] ; encode data [ i * 2+1 ] = look up hex alphabet [ binary data [ i ] & 0xf ] ; } return encoded data ; }
public type resolver builder < ? > find property content type resolver ( mapper config < ? > config , annotated member be , java type container type ) { return null ; }
public type resolver builder < ? > find property type resolver ( mapper config < ? > config , annotated member be , java type base type ) { return null ; }
public static string date to iso8601 string ( date date ) { simple date format df = new simple date format ( `` yyyy- m m-dd ' t ' h h : mm : s z `` , locale . english ) ; return df . format ( date ) ; }
public @ not null i serializer get serializer ( ) { return serializer ; }
public @ not null i serializer get serializer ( ) { return serializer ; }
public node get node ( ) { return node ; }
public void set cache ( boolean cache ) { this . cache = cache ; }
public mime type get mime type ( ) { return mime type ; }
public boolean start before disjoint ( interval other ) { return this . a < other . a & & this . b < other . a ; }
public void set vertex ( float [ ] vertex ) { c o s array new vertex = new c o s array ( ) ; new vertex . set float array ( vertex ) ; annot . set item ( c o s name . vertex , new vertex ) ; }
public final boolean await ( long time , time unit unit ) throw interrupted exception { boolean d = do . get count ( ) == 0 || ( do . await ( time , unit ) ) ; timeout = ! d ; return d ; }
public boolean be manage ( ) { return f be manage ; }
public term slice merge ( term slice other slice ) { if ( have bind ( bound . start ) ) { assert ! other slice . have bind ( bound . start ) ; return new term slice ( bound ( bound . start ) , be inclusive ( bound . start ) , other slice . bound ( bound . end ) , other slice . be inclusive ( bound . end ) ) ; } assert ! other slice . have bind ( bound . end ) ; return new term slice ( other slice . bound ( bound . start ) , other slice . be inclusive ( bound . start ) , bound ( bound . end ) , be inclusive ( bound . end ) ) ; }
public string get identifier ( ) { return identifier ; }
public deletion time deletion time ( ) { return deletion ; }
public long count ( ) { return count ; }
public set < string > get remove ( ) { return remove ; }
public static void legal property key value array ( final object . . . property key value ) throw illegal argument exception { if ( property key value . length % 2 ! = 0 ) throw element . exception . provide key value must be a multiple of two ( ) ; for ( int i = 0 ; i < property key value . length ; i = i + 2 ) { if ( ! ( property key value [ i ] instanceof string ) & & ! ( property key value [ i ] instanceof t ) ) throw element . exception . provide key value must have a legal key on even index ( ) ; if ( null == property key value [ i + 1 ] ) { throw property . exception . property value can not be null ( ) ; } } }
public string get value ( ) { return text ; }
public static byte [ ] encode data with length ( final base64 u r l data ) { byte [ ] bytes = data ! = null ? data . decode ( ) : null ; return encode data with length ( byte ) ; }
public node get node ( ) { return node ; }
public string get alias ( ) { return alias ; }
public poly style add to poly style simple extension ( final object poly style simple extension ) { this . get poly style simple extension ( ) . add ( poly style simple extension ) ; return this ; }
public object [ ] to array ( ) { object [ ] o = new object [ _size ] ; int i = 0 ; for ( t linkable link = _head ; link ! = null ; link = link . get next ( ) ) { o [ i++ ] = link ; } return o ; }
public schema get schema ( ) { return schema ; }
public void set endpoint feature ( web service feature . . . endpoint feature ) { this . endpoint feature = endpoint feature ; }
public static class get wrapper type ( class primitive type ) { if ( primitive type . be primitive ( ) ) { return primitives_to_wrappers . get ( primitive type ) ; } return primitive type ; }
public model add to model simple extension ( final object model simple extension ) { this . get model simple extension ( ) . add ( model simple extension ) ; return this ; }
protect boolean be eligible for marshal ( string model key , object value ) { assert . state ( this . marshaller ! = null , `` no marshaller set `` ) ; class < ? > class to check = value . get class ( ) ; if ( value instanceof j a x b element ) { class to check = ( ( j a x b element < ? > ) value ) . get declared type ( ) ; } return this . marshaller . support ( class to check ) ; }
public icon get large icon ( string name ) { return get icon impl ( path + large icon sub dir + `` / `` + name + `` . `` + extension ) ; }
public void set simple array data extension ( final list < object > simple array data extension ) { this . simple array data extension = simple array data extension ; }
public poly style add to poly style object extension ( final abstract object poly style object extension ) { this . get poly style object extension ( ) . add ( poly style object extension ) ; return this ; }
public poly style add to poly style simple extension ( final object poly style simple extension ) { this . get poly style simple extension ( ) . add ( poly style simple extension ) ; return this ; }
public static class get wrapper type ( class primitive type ) { if ( primitive type . be primitive ( ) ) { return primitives_to_wrappers . get ( primitive type ) ; } return primitive type ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public void set post only ( boolean post only ) { this . post only = post only ; }
public static string get segment ( string path , int segment ) { int start = path . index of ( i path . separator ) == 0 ? 1 : 0 ; int end = path . index of ( i path . separator , start ) ; if ( end == path . length ( ) - 1 ) end = -1 ; for ( int i = 0 ; i < segment ; i++ ) { if ( end == -1 ) return null ; start = end + 1 ; end = path . index of ( i path . separator , start ) ; } if ( end == -1 ) end = path . length ( ) ; return path . substring ( start , end ) ; }
public double get x ( ) { return x ; }
public final e first ( ) { final int bit = this . bit ; if ( bit == 0 ) throw new no such element exception ( ) ; return item of ( number of trail zero ( low one bit ( bit ) ) ) ; }
public boolean contains number ( number number ) { if ( number == null ) { return false ; } return contains long ( number . long value ( ) ) ; }
public boolean get ( final int i ) { if ( ( i < 0 ) || ( i > = this . size in bit ) ) return false ; int word check = 0 ; final iterating r l w j = get iterate r l w ( ) ; final int wordi = i / word_in_bits ; while ( word check < = wordi ) { word check += j . get running length ( ) ; if ( wordi < word check ) { return j . get running bit ( ) ; } if ( wordi < word check + j . get number of literal word ( ) ) { final long w = j . get literal word at ( wordi - word check ) ; return ( w & ( 1l < < i ) ) ! = 0 ; } word check += j . get number of literal word ( ) ; j . next ( ) ; } return false ; }
public word list get word list ( ) { return word list ; }
public word list get word list ( ) { return word list ; }
public long size in byte ( ) { return cache . size in byte ( ) ; }
public void set iterator ( final iterator < ? extend e > iterator ) { this . iterator = iterator ; }
public static void or with container ( final bitmap storage32 container , final e w a h compressed bitmap32 . . . bitmap ) { if ( bitmap . length < 2 ) throw new illegal argument exception ( `` you should provide at least two bitmap , provide `` + bitmap . length ) ; fast aggregation32 . or to container ( container , bitmap ) ; }
public boolean equal ( object other ) { return ( this == other || ( other instanceof bean component definition & & super . equal ( other ) ) ) ; }
public static e w a h compress bitmap xor ( final e w a h compressed bitmap . . . bitmap ) { if ( bitmap . length == 1 ) return bitmap [ 0 ] ; int large size = calculate initial size ( bitmap ) ; int size = ( int ) ( large size * 1 . 5 ) ; final e w a h compress bitmap container = new e w a h compress bitmap ( size ) ; xor with container ( container , bitmap ) ; return container ; }
public void set compress ( boolean compress ) { do compress = compress ; }
public int get array dimension ( ) { return this . array dimension ; }
public boolean be interface ( ) { return this . be interface ; }
public static boolean check if parameter type be same ( boolean be var args , class < ? > [ ] expect parameter type , class < ? > [ ] actual parameter type ) { if ( expect parameter type == null || actual parameter type == null ) { throw new illegal argument exception ( `` parameter type can not be null `` ) ; } else if ( expect parameter type . length ! = actual parameter type . length ) { return false ; } else { for ( int i = 0 ; i < expect parameter type . length ; i++ ) { final class < ? > actual parameter type = get type ( actual parameter type [ i ] ) ; if ( be var args & & i == expect parameter type . length - 1 & & actual parameter type . get component type ( ) . be assignable from ( expect parameter type [ i ] ) ) { return true ; } else if ( ! actual parameter type . be assignable from ( expect parameter type [ i ] ) ) { return false ; } } } return true ; }
public int get array dimension ( ) { return this . array dimension ; }
public void set class name ( string class name ) { reader class name = class name ; }
public final method info method ( ) { return method ; }
public static boolean be static ( int mod ) { return ( mod & static ) ! = 0 ; }
public static boolean be static ( int mod ) { return ( mod & static ) ! = 0 ; }
public static boolean be static ( int mod ) { return ( mod & static ) ! = 0 ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public boolean set position ( int po ) { position = po ; return pos > = 1 & & po < = get max position ( ) ; }
public int get evaluation ( ) { return evaluation . get count ( ) ; }
public void set e l context ( e l context context ) { this . context = context ; }
public void set context ( string context ) { if ( context . start with ( `` / `` ) ) { this . context = context ; } else { this . context = `` / `` + context ; } }
public object get value ( e l context context , object base , object property ) { if ( context == null ) { throw new null pointer exception ( ) ; } if ( base == null & & property instanceof string ) { if ( bean name resolver . be name resolve ( ( string ) property ) ) { context . set property resolve ( base , property ) ; return bean name resolver . get bean ( ( string ) property ) ; } } return null ; }
public arg create arg ( boolean insert at start ) { arg argument = new argument ( ) ; if ( insert at start ) { argument . add ( 0 , argument ) ; } else { argument . add ( argument ) ; } return argument ; }
public argument write argument ( argument c ) { item . add ( c ) ; return this ; }
public void set argument ( object [ ] argument ) { this . argument = argument ; }
public final byte [ ] get byte array ( ) { return this . byte array ; }
public int count ( ) { return count ; }
public input stream get input stream ( ) { return input stream ; }
public void set there have be an explicit result document ( ) { there have be an explicit result document = true ; }
public void trace xml ( trace flag trace type , byte array output stream stream ) { if ( this . be trace enable for ( trace type ) ) { string trace type str = trace type . to string ( ) ; string log message = ews utility . format log message with xml content ( trace type str , stream ) ; this . trace listener . trace ( trace type str , log message ) ; } }
public void set read ( string value ) { this . read = value ; }
public string to string ( ) { return to string buffer ( ) . to string ( ) ; }
public string get name ( ) { return name ; }
public void set right ( r right ) { this . right = right ; }
public s o a p envelope get envelope ( ) { return message ; }
protect void set expunge ( boolean expunge ) { this . expunge = expunge ; }
public long get u i d ( ) { return zip util . big to long ( uid ) ; }
public right get right ( ) { return right ; }
public string get protocol ( ) { return protocol ; }
public void set folder ( iterable < folder > folder ) { this . set object ( ( collection < folder > ) folder ) ; }
public oof reply get internal reply ( ) { return internal reply ; }
public void load ( ) throw configuration exception { if ( source u r l ! = null ) { load ( source u r l ) ; } else { load ( get file name ( ) ) ; } }
public void set header ( string header ) { this . header = header ; }
public string get protocol ( ) { return protocol ; }
public void set s ( string s ) { cmd . add flag ( `` -s `` , s ) ; }
public iterator get namespaces ( ) { return m namespaces . iterator ( ) ; }
public final type literal < t > get type literal ( ) { return type literal ; }
public long get search total ( ) { return search total ; }
public boolean match ( string seq ) { return queue . region match ( true , po , seq , 0 , seq . length ( ) ) ; }
public int get type ( ) { return type ; }
public synchronize message [ ] expunge ( ) throw message exception { return expunge ( null ) ; }
public command info get command ( string mime type , string cmd name , data source d ) { return get command ( mime type , cmd name ) ; }
public int get option ( ) { return option ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public static long long encode ( string hash a string ) { int [ ] parse = parse hash ( hash a string ) ; return long encode ( ( long ) parse [ 0 ] , ( long ) parse [ 1 ] , ( long ) parse [ 2 ] ) ; }
protect void update ( byte [ ] b ) { update ( b , 0 , b . length ) ; }
protect message format create message format ( string msg , locale locale ) { return new message format ( ( msg ! = null ? msg : `` `` ) , locale ) ; }
public record [ ] get child record ( ) { return null ; }
public static final string get ( final string property , final string def ) { try { return system . get property ( property , def ) ; } catch ( security exception se ) { return def ; } }
public void set option comparator ( comparator comparator ) { if ( comparator == null ) { this . option comparator = new option comparator ( ) ; } else { this . option comparator = comparator ; } }
public property create property ( ) { final property prop = new property ( ) ; property list . add element ( prop ) ; return prop ; }
public void set name ( string name ) { if ( name == null ) throw new illegal argument exception ( ) ; this . name = name ; }
public void set host ( string host ) { this . host = host ; } // -- void set host ( string )
public string get protocol ( ) { return protocol ; }
public type get type ( ) { return type ; }
public string get address ( ) { return this . address ; } // -- string get address ( )
public void set message ( string message ) { this . message = message ; }
public ref first exact ref ( string . . . ref ) throw i o exception { for ( string name : ref ) { ref ref = exact ref ( name ) ; if ( ref ! = null ) { return ref ; } } return null ; }
public int po ( ) { return po ; }
protected list < item > internal create ( folder id destination folder id , message disposition message disposition ) throw exception { ( ( item id ) this . get property bag ( ) . get object from property definition ( response object schema . reference item id ) ) . assign ( this . reference item . get id ( ) ) ; return this . get service ( ) . internal create response object ( this , destination folder id , message disposition ) ; }
public line string get line ( ) { return line ; }
public string get address ( ) { return this . address ; } // -- string get address ( )
public string get description ( ) { return this . description ; } // -- string get description ( )
public void set description ( string description ) { this . description = description ; }
protect void possibly save ( ) { if ( auto save & & file name ! = null ) { try { save ( ) ; } catch ( configuration exception e ) { throw new configuration runtime exception ( `` fail to auto-save `` , e ) ; } } }
public void set message ( string message ) { this . message = message ; }
public void omit newsgroup ( string newsgroup ) { add newsgroup ( `` ! `` + newsgroup ) ; }
public synchronize message [ ] expunge ( ) throw message exception { return expunge ( null ) ; }
public node get parent ( ) { return parent ; }
public s s l context builder use protocol ( final string protocol ) { this . protocol = protocol ; return this ; }
public void end test ( test test ) { f model . add run test ( test ) ; fire test change ( test , false ) ; }
public string format message ( final log record record ) { string msg = super . format message ( record ) ; msg = replace class name ( msg , record . get thrown ( ) ) ; msg = replace class name ( msg , record . get parameter ( ) ) ; return msg ; }
public boolean be connect ( ) { boolean ret = delegate . be connect ( ) ; return ret ; }
public boolean be debug ( ) { return debug ; }
public string get property value ( string property name ) { return get property ( ) . get ( property name ) ; }
public string get provider ( ) { return provider ; }
public string get protocol ( ) { return protocol ; }
public store get store ( ) { return store ; }
public file store get file store ( ) { return file store ; }
protect void update configuration ( final configuration new config ) { this . private config = new private config ( new config , this ) ; }
public void set servlet ( servlet servlet ) { instance = servlet ; }
public void print stack trace ( print writer s ) { super . print stack trace ( s ) ; }
public enclose expr set inner ( final expression inner ) { assert not null ( inner ) ; if ( inner == this . inner ) { return this ; } notify property change ( observable property . inner , this . inner , inner ) ; if ( this . inner ! = null ) this . inner . set parent node ( null ) ; this . inner = inner ; set a parent node of ( inner ) ; return this ; }
public j annotation use annotate ( j class clazz ) { if ( annotations==null ) annotation = new array list < j annotation use > ( ) ; j annotation use a = new j annotation use ( clazz ) ; annotation . add ( a ) ; return a ; }
public void set loop ( list < array comprehension loop > loop ) { assert not null ( loop ) ; this . loop . clear ( ) ; for ( array comprehension loop acl : loop ) { add loop ( acl ) ; } }
public void write byte ( final byte octet ) { if ( remain ( ) < 1 ) { if ( index == block . size ( ) - 1 ) { allocate new block ( ) ; } index++ ; current = block . get ( index ) ; } final block block = current ; block . data [ block . limit ] = octet ; block . limit++ ; }
public j var [ ] list params ( ) { return params . to array ( new j var [ params . size ( ) ] ) ; }
public void set package ( string p ) { this . cvs package = p ; }
public < t > class < t > resolve ( ) { return class for name ( fully qualify class name ) ; }
public void set type ( class < ? > type ) { this . type = type ; }
public static void init ( ) { }
public static annotation [ ] get filtering annotation ( final annotation [ ] annotation ) { if ( annotation == null || annotation . length == 0 ) { return filter helper . empty_annotations ; } final list < annotation > filtering annotation = new array list < > ( annotation . length ) ; for ( final annotation annotation : annotation ) { final class < ? extend annotation > annotation type = annotation . annotation type ( ) ; for ( final annotation meta annotation : annotation type . get declared annotation ( ) ) { if ( meta annotation instanceof entity filter ) { filter annotation . add ( annotation ) ; } } } return filter annotation . to array ( new annotation [ filter annotation . size ( ) ] ) ; }
public type get type ( ) { return type ; }
public j type type ( ) { return type ; }
public j type var [ ] type params ( ) { return empty_array ; }
public final boolean be doc comment ( ) { return ( this instanceof javadoc ) ; }
public string get exception class name ( ) { return exception class name ; }
protect boolean filter resource ( resource r ) { return false ; }
public static boolean be whitespace ( int c ) { return c == ' ' || c == '\t ' || c == '\n ' || c == '\f ' || c == '\r ' ; }
public static char low ( int uc ) { return ( char ) ( 0xdc00 | ( ( uc - ucs4_min ) & 0x3ff ) ) ; }
public static char high ( int uc ) { return ( char ) ( 0xd800 | ( ( ( uc - ucs4_min ) > > 10 ) & 0x3ff ) ) ; }
public void set base path ( string base path ) { this . base path = base path ; }
public string get name ( ) { return name ; } // get name
public string get namespace u r i ( ) { return namespace . get u r i ( ) ; }
public handler [ ] get and set handler ( final handler [ ] handler ) throw security exception { final handler [ ] safe handler = handler . clone ( ) ; for ( handler handler : safe handler ) { if ( handler == null ) { throw new illegal argument exception ( `` a handler be null `` ) ; } } return logger node . set handler ( safe handler ) ; }
public namespace get namespace ( ) { return namespace ; }
public static method replace strategy replace ( method method ) { return new method replace strategy impl ( method ) ; }
public string get name ( ) { return name ; } // get name
public compare to builder append ( object [ ] lh , object [ ] rh ) { return append ( lhs , rh , null ) ; }
public string get location ( ) { return location ; }
public set < class < ? extend j o s e object > > get j o s e class ( ) { return class ; }
public conversion service get conversion service ( ) { return this . conversion service ; }
protected list < field > all field ( final class < ? > c ) { list < field > l = field cache . get ( c ) ; if ( l == null ) { l = new link list < field > ( ) ; final field [ ] field = c . get declared field ( ) ; add all ( l , field ) ; class < ? > sc = c ; while ( ( sc = sc . get superclass ( ) ) ! = object . class & & sc ! = null ) { add all ( l , sc . get declared field ( ) ) ; } field cache . put if absent ( c , l ) ; } return l ; }
public final string get name ( ) { return name ; }
public boolean be queue ( ) { return queue ; }
public void set document locator ( locator locator ) { if ( sax log . be debug enable ( ) ) { sax log . debug ( `` set document locator ( `` + locator + `` ) `` ) ; } this . locator = locator ; }
public static complex type get complex type ( final type type ) { if ( type instanceof complex type ) { return ( complex type ) type ; } else if ( ( type instanceof array of ) || ( type instanceof pointer of ) ) { return get complex type ( get contain type ( ( type container ) type ) ) ; } else { throw new illegal argument exception ( `` the give type be not a complex type . `` ) ; } }
public void set schema ( string schema ) { this . schema = schema ; }
public boolean be package ( string [ ] pkg ) { return false ; }
public option get option ( ) { return option ; }
public void set locale ( locale locale ) { this . locale = locale ; }
public void set u r i resolver ( u r i resolver resolver ) { uri resolver = resolver ; }
static public void reset ( ) { logger factory . reset ( ) ; }
protect int get valid count ( ) { int ct = get count ( ) ; if ( ct < 0 ) { throw new build exception ( bad_count ) ; } return ct ; }
public string to string ( ) { return name ; }
public string get target name ( ) { return f target name ; }
protect collection < field access > field of ( class < ? > c ) { collection < field access > field = field of a s t class . get ( c ) ; if ( field ! = null ) return field ; field = new array list < field access > ( ) ; get field ( c , field ) ; field of a s t class . put ( c , field ) ; return field ; }
public location get location ( ) { return this . location ; }
public stack frame constructor call ( int initialize value stack position ) { stack entry entry = stack state . get content ( ) . get ( stack state . get content ( ) . size ( ) - 1 - initialize value stack position ) ; stack state ns = stack state . constructor call ( initialized value stack position , entry ) ; local variable state local = local variable state . constructor call ( entry ) ; return new stack frame ( ns , local , stack frame type . full_frame ) ; }
public stack frame pop4 ( ) { stack state ns = stack state . pop ( 4 ) ; return new stack frame ( ns , local variable state , type no local change ( ns ) ) ; }
protect string format args ( object [ ] args ) { string buffer sb = new string buffer ( ) ; for ( int i = 0 ; i < args . length ; i++ ) { sb . append ( format obj ( args [ i ] ) ) ; if ( i < args . length-1 ) sb . append ( `` , `` ) ; } return sb . to string ( ) ; }
public void usage ( ) { string builder sb = new string builder ( ) ; usage ( sb ) ; system . out . println ( sb . to string ( ) ) ; }
public void usage ( string command name ) { string builder sb = new string builder ( ) ; usage ( command name , sb ) ; system . out . println ( sb . to string ( ) ) ; }
public boolean reference interface ( ) { java class jc = repository . lookup class ( classname ) ; if ( jc == null ) { return false ; } else { return ! jc . be class ( ) ; } }
public string get name ( ) { return name ; } // get name
public static < e > list < e > a list ( iterable < e > i ) { if ( i instanceof collection ) { return new array list < e > ( ( collection < e > ) i ) ; } array list < e > a = new array list < e > ( ) ; for ( e e : i ) { a . add ( e ) ; } return a ; }
public void set specify ( boolean specify ) { this . specify = specify ; }
public boolean be specify ( ) { return specify ; }
public synchronize void set parent ( part parent ) { this . parent = parent ; }
public static string get attribute name ( string attribute , int index ) { return attribute + index ; }
public static < e > collection < e > remove all ( final collection < e > collection , final collection < ? > remove ) { return list utils . remove all ( collection , remove ) ; }
protect void validate index ( int index ) { if ( index < 0 || index > size ) { throw new string index out of bound exception ( index ) ; } }
public static boolean be whitespace ( int c ) { return c == ' ' || c == '\t ' || c == '\n ' || c == '\f ' || c == '\r ' ; }
public void set filter ( tree filter filter ) { this . filter = filter ; }
public void set filter ( tree filter filter ) { this . filter = filter ; }
public void add proc ( instruction sequence child ) { this . instruction . add ( child ) ; }
public void clear ( ) { e d a . clear ( ) ; }
public void set driver name ( string driver name ) { this . driver name = driver name ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public boolean get expand entity ( ) { return expand ; }
public string get property ( final string key , final string def ) { final string value = this . get property ( key ) ; return value == null ? def : value ; }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public x path factory get x path factory ( ) { return this . xpath factory ; }
public async web resource async resource ( string u ) { return async resource ( uri . create ( u ) ) ; }
public web resource resource ( string u ) { return resource ( uri . create ( u ) ) ; }
public jersey client get client ( ) { return state . get client ( ) ; }
public boolean eval feature ( ) { x m l reader reader = get reader ( ) ; if ( value == null ) { value = `` true `` ; } boolean v = project . to boolean ( value ) ; try { reader . set feature ( feature , v ) ; } catch ( s a x not recognize exception e ) { log ( feature + not_recognized + feature , project . msg_verbose ) ; return false ; } catch ( s a x not support exception e ) { log ( feature + not_supported + feature , project . msg_verbose ) ; return false ; } return true ; }
public < t > list < t > load service provider ( class < t > iface ) { list < t > provider = new array list < t > ( ) ; provider . add all ( load dynamic service provider ( iface ) ) ; provider . add all ( load static service provider ( iface ) ) ; return provider ; }
public static < e > list < e > a list ( iterable < e > i ) { if ( i instanceof collection ) { return new array list < e > ( ( collection < e > ) i ) ; } array list < e > a = new array list < e > ( ) ; for ( e e : i ) { a . add ( e ) ; } return a ; }
public string to j s o n string ( ) { return to j s o n string ( this , j s o n value . compression ) ; }
protect final void register request destruction callback ( string name , runnable callback ) { assert . not null ( name , `` name must not be null `` ) ; assert . not null ( callback , `` callback must not be null `` ) ; synchronize ( this . request destruction callback ) { this . request destruction callback . put ( name , callback ) ; } }
public static string error_scanning_class_not_found ( object arg0 ) { return localizer . localize ( localizable e r r o r_ s c a n n i n g_ c l a s s_ n o t_ f o u n d ( arg0 ) ) ; }
public object get context ( ) { return context ; }
public path create path ( ) { if ( path == null ) { path = new path ( get project ( ) ) ; } return path ; }
public list < filter > get filter ( ) { return array . a list ( filter ) ; }
public set < class < ? > > get provider class ( ) { return collection . unmodifiable set ( provider class ) ; }
public string get string value ( string name , string default value ) { string result = property . get ( name ) ; if ( result == null ) { return default value ; } return result ; }
public static rest request request without parameter ( name x content registry x content registry , http request http request , http channel http channel ) { map < string , string > params = collection . empty map ( ) ; return new rest request ( x content registry , params , http request . uri ( ) , http request . get header ( ) , http request , http channel , request id generator . increment and get ( ) ) ; }
public list < arc > a list ( ) { final list < arc > list = new array list < arc > ( ) ; for ( final double [ ] a : this ) { list . add ( new arc ( a [ 0 ] , a [ 1 ] , get tolerance ( ) ) ) ; } return list ; }
public final string get template ( ) { return template ; }
public method get method ( ) { return this . method ; }
public boolean be load ( ) { return load ; }
public void set title ( final string title ) { this . title = title ; }
public string get href ( ) { return href ; }
public resource type get resource type ( ) { return resource type ; }
public boolean be return value require ( ) { return this . return value require ; }
public static type query builder type query ( string type ) { return new type query builder ( type ) ; }
public string get string representation ( ) { return this . string representation ; }
public int get chunk size ( ) { return chunk size ; }
public string get property ( ) { return property ; }
public uri get uri ( ) { return this . uri ; }
public final string get header name ( ) { return this . header name ; }
public string uri ( ) { return uri ; }
public collection type construct raw collection type ( class < ? extend collection > collection class ) { return construct collection type ( collection class , unknown type ( ) ) ; }
public static string logging_global_response_filters ( ) { return localizer . localize ( localizable l o g g i n g_ g l o b a l_ r e s p o n s e_ f i l t e r s ( ) ) ; }
public static string error_closing_finder ( object arg0 ) { return localizer . localize ( localizable e r r o r_ c l o s i n g_ f i n d e r ( arg0 ) ) ; }
public static string error_provider_registered_wrong_runtime ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ p r o v i d e r_ r e g i s t e r e d_ w r o n g_ r u n t i m e ( arg0 , arg1 ) ) ; }
public static string error_scanning_class_not_found ( object arg0 ) { return localizer . localize ( localizable e r r o r_ s c a n n i n g_ c l a s s_ n o t_ f o u n d ( arg0 ) ) ; }
public static string template_param_null ( ) { return localizer . localize ( localizable t e m p l a t e_ p a r a m_ n u l l ( ) ) ; }
public static string error_provider_registered_wrong_runtime ( object arg0 , object arg1 ) { return localizer . localize ( localizable e r r o r_ p r o v i d e r_ r e g i s t e r e d_ w r o n g_ r u n t i m e ( arg0 , arg1 ) ) ; }
public static string client_rx_provider_null ( ) { return localizer . localize ( localizable c l i e n t_ r x_ p r o v i d e r_ n u l l ( ) ) ; }
public static string logging_message_body_readers ( ) { return localizer . localize ( localizable l o g g i n g_ m e s s a g e_ b o d y_ r e a d e r s ( ) ) ; }
public method get method ( ) { return method ; }
public void set filter ( tree filter filter ) { this . filter = filter ; }
public object writer with view ( class < ? > view ) { return _new ( this , _config . with view ( view ) ) ; }
public string get issue token type ( ) { return this . issue token type ; }
public type get type ( ) { return type ; }
public string get regex ( ) { return regex ; }
public http request wrapper build unconditional request ( final http request wrapper request , final http cache entry entry ) { final http request wrapper new request = http request wrapper . wrap ( request . get original ( ) ) ; new request . set header ( request . get all header ( ) ) ; new request . add header ( header constant . cache_control , header constant . cache_control_no_cache ) ; new request . add header ( header constant . pragma , header constant . cache_control_no_cache ) ; new request . remove header ( header constant . if_range ) ; new request . remove header ( header constant . if_match ) ; new request . remove header ( header constant . if_none_match ) ; new request . remove header ( header constant . if_unmodified_since ) ; new request . remove header ( header constant . if_modified_since ) ; return new request ; }
public delegate permission get permission ( ) { return this . permission ; }
public void set background ( color color ) { if ( color == null ) return ; _background = color ; }
public void set email ( final string email ) { this . email = email ; }
public stream distribution [ ] list stream distribution ( int page size ) throw cloud front service exception { list < distribution > distribution = list distribution impl ( true , page size ) ; return distribution . to array ( new stream distribution [ distribution . size ( ) ] ) ; }
public distribution [ ] list distribution ( int page size ) throw cloud front service exception { list < distribution > distribution = list distribution impl ( false , page size ) ; return distribution . to array ( new distribution [ distribution . size ( ) ] ) ; }
public distribution create distribution ( distribution config config ) throw cloud front service exception { return create distribution impl ( config ) ; }
protect distribution create distribution impl ( distribution config config ) throw cloud front service exception { if ( log . be debug enable ( ) ) { log . debug ( `` create `` + ( config . be stream distribution config ( ) ? `` stream `` : `` `` ) + `` distribution for origin : `` + array . a list ( config . get origin ( ) ) ) ; } http post http method = new http post ( endpoint + version + ( config . be stream distribution config ( ) ? `` /streaming-distribution `` : `` /distribution `` ) ) ; try { string distribution config xml = build distribution config xml document ( config ) ; http method . set entity ( new string entity ( distribution config xml , content type . create ( `` text/xml `` , constant . default_encoding ) ) ) ; http response response = perform rest request ( http method , 201 ) ; distribution handler handler = ( new cloud front xml responses sax parser ( this . jets3t property ) ) . parse distribution response ( response . get entity ( ) . get content ( ) ) ; return handler . get distribution ( ) ; } catch ( cloud front service exception e ) { throw e ; } catch ( runtime exception e ) { throw e ; } catch ( exception e ) { throw new cloud front service exception ( e ) ; } }
public static void close quietly ( final http client http client ) { if ( http client ! = null ) { http client . get connection manager ( ) . shutdown ( ) ; } }
public vector get target ( ) { return target vector ; }
public void add owner ( string owner ) { add bag value ( prefix + `` : owner `` , owner ) ; }
public static vector load ( ) throw i o exception { input stream pin = a w s dev pay product . class . get resource a stream ( `` / `` + constant . devpay_products_properties_filename ) ; vector ret = new vector ( ) ; if ( pin ! = null ) { try { ret = load ( pin ) ; } finally { pin . close ( ) ; } } return ret ; }
public data file writer < d > append to ( file file ) throw i o exception { return append to ( new seekable file input ( file ) , new syncable file output stream ( file , true ) ) ; }
public string get event ( ) { return event ; }
public object get ( char sequence key ) { final int bucket = normal completion . get bucket ( key ) ; return bucket == -1 ? null : long . value of ( bucket ) ; }
public void set host ( string host ) { this . host = host ; } // -- void set host ( string )
public void set http client ( http client http client ) { this . http client = http client ; }
public void bridge ( x m l stream reader in , x m l stream writer out ) throw x m l stream exception { bridge ( in , out , null ) ; }
public string get code ( ) { return this . code ; }
public int get connect timeout ( ) { return connect timeout ; }
public cache control cache control ( ) { cache control result = cache control ; return result ! = null ? result : ( cache control = cache control . parse ( header ) ) ; }
public void set min gzip size ( int min gzip size ) { if ( min gzip size < break_even_gzip_size ) log . warn ( `` min gzip size of { } be inefficient for short content , break even be size { } `` , min gzip size , break_even_gzip_size ) ; _min gzip size = math . max ( 0 , min gzip size ) ; }
public int get error content length ( ) { return error content length ; }
public void set method ( string method ) { this . method = method ; }
public request < ? > get request ( ) { return request ; }
public void increment ( ) { value++ ; }
public logger get logger ( ) { return logger ; }
public void add listener ( debug event listener listener ) { listener . add ( listener ) ; }
public algorithm get algorithm ( ) { return algorithm ; }
public void start ( ) { precondition . check state ( state . compare and set ( state . latent , state . start ) , `` can not be start more than once `` ) ; precondition . check state ( ! executor service . be shutdown ( ) , `` already start `` ) ; precondition . check state ( ! have leadership , `` already have leadership `` ) ; client . get connection state listenable ( ) . add listener ( listener ) ; requeue ( ) ; }
public deployment option set instance ( int instance ) { this . instance = instance ; return this ; }
public void set name ( string name ) { this . name = name . to lower case ( locale . u ) ; }
public list < format error > get error ( ) { return error ; }
public final boolean equal ( final set < ? > o ) { return o == this || o . contain all ( this ) & & contain all ( o ) ; }
public type get type ( ) { return type ; }
public boolean be true ( ) { return value == true ; }
public symbol top symbol ( ) { return stack [ pos - 1 ] ; }
public static print stream wrap system err ( ) { return wrap ( system . err ) ; }
public void set max char code ( int max char code ) { if ( max char code < 0 ) { throw new illegal argument exception ( `` max char code `` + max char code + `` be negative . `` ) ; } else if ( max char code > max char ) { throw new illegal argument exception ( `` max char code `` + integer . to hex string ( max char code ) + `` be large than max char `` + integer . to hex string ( max char ) ) ; } max char use = max char code ; }
public int get max char code ( ) { return max char use ; }
public i content type matcher get matcher ( ) { return matcher ; }
public static void append to file ( string output dir , string file name , string sb ) { string out dir path= output dir ! = null ? output dir : `` `` ; file out dir= new file ( out dir path ) ; write file ( out dir , file name , sb , null , true / * append * / ) ; }
public int char set copy ( ) { int char set result = new int char set ( ) ; for ( interval interval : interval ) result . interval . add ( interval . copy ( ) ) ; return result ; }
public int char set copy ( ) { int char set result = new int char set ( ) ; for ( interval interval : interval ) result . interval . add ( interval . copy ( ) ) ; return result ; }
public void set interval ( long interval ) { this . interval = interval ; }
public string get name ( int code ) { string name = code to name . get ( code ) ; if ( name ! = null ) { return name ; } return `` . notdef `` ; }
public string get error message ( ) { return error message ; }
public line string get line ( ) { return line ; }
public void set output ( print stream out ) { }
public static time convert nano to time ( long nanos ) { long millis = nanos / 1000000 ; long s = millis / 1000 ; millis -= s * 1000 ; long m = s / 60 ; s -= m * 60 ; long h = m / 60 ; m -= h * 60 ; long m = get millis ( time zone . get default ( ) , 1970 , 1 , 1 , ( int ) ( h % 24 ) , ( int ) m , ( int ) s , ( int ) millis ) ; return new time ( m ) ; }
public static boolean be empty ( string str ) { return ( str == null || str . length ( ) == 0 ) ; }
public int get end index ( ) { return end index ; }
public json node visit ( jmes path not expression not expression , json node input ) throw invalid type exception { json node result expr = not expression . get expr ( ) . accept ( this , input ) ; if ( result expr ! = boolean node . true ) { return boolean node . true ; } return boolean node . false ; }
public json node visit ( jmes path not expression not expression , json node input ) throw invalid type exception { json node result expr = not expression . get expr ( ) . accept ( this , input ) ; if ( result expr ! = boolean node . true ) { return boolean node . true ; } return boolean node . false ; }
public json node visit ( jmes path value projection value projection , json node input ) throw invalid type exception { json node project result = value projection . get lhs expr ( ) . accept ( this , input ) ; if ( project result . be object ( ) ) { array node project array node = object mapper singleton . get object mapper ( ) . create array node ( ) ; iterator < json node > element = project result . element ( ) ; while ( element . have next ( ) ) { json node project element = value projection . get rhs expr ( ) . accept ( this , element . next ( ) ) ; if ( project element ! = null ) { projected array node . add ( project element ) ; } } return projected array node ; } return null node . get instance ( ) ; }
public boolean match ( json node lhs , json node rh ) { return ! lh . equal ( rh ) ; }
public final boolean match ( json node lhs , json node rh ) { return match ( lh . decimal value ( ) , rh . decimal value ( ) ) ; }
public collection < string > get group ( ) { return group ; }
public static list < method > get declare method include inherit ( class < ? > clazz ) { list < method > method = new array list < method > ( ) ; while ( clazz ! = null ) { for ( method method : clazz . get declare method ( ) ) { method . add ( method ) ; } clazz = clazz . get superclass ( ) ; } return method ; }
public static < t > iterator < t > unique ( iterator < t > self ) { return to list ( ( iterable < t > ) unique ( to list ( self ) ) ) . list iterator ( ) ; }
public final string get id ( ) { return id ; }
public boolean equal ( object ob ) { if ( ob == this ) return true ; if ( ! ( ob instanceof virtual machine descriptor ) ) return false ; virtual machine descriptor other = ( virtual machine descriptor ) ob ; if ( other . provider ( ) ! = this . provider ( ) ) { return false ; } if ( ! other . id ( ) . equal ( this . id ( ) ) ) { return false ; } return true ; }
public boolean equal ( object ob ) { if ( ob == this ) return true ; if ( ! ( ob instanceof virtual machine ) ) return false ; virtual machine other = ( virtual machine ) ob ; if ( other . provider ( ) ! = this . provider ( ) ) { return false ; } if ( ! other . id ( ) . equal ( this . id ( ) ) ) { return false ; } return true ; }
public static < t > t new instance ( class < t > c ) { return ( t ) invoker helper . invoke constructor of ( c , null ) ; }
protected remote invocation create remote invocation ( method invocation method invocation ) { return get remote invocation factory ( ) . create remote invocation ( method invocation ) ; }
public int get size ( ) { return 0 ; }
public string get name ( int value ) { return constant . get name ( value ) ; }
public int get value ( string name ) { return ( int ) constant . get value ( name ) ; }
public string get address ( ) { return this . address ; } // -- string get address ( )
public void to native ( runtime runtime , pointer memory , long offset ) { memory . put native long ( offset , value . long value ( ) ) ; }
public void to native ( runtime runtime , pointer memory , long offset ) { memory . put native long ( offset , value . long value ( ) ) ; }
public void from native ( runtime runtime , pointer memory , long offset ) { this . value = memory . get long long ( offset ) ; }
public void set ( final long value ) { this . value = value ; }
public void expunge stale entry ( ) { reference < ? > reference ; while ( ( reference = poll ( ) ) ! = null ) { cache . remove ( reference ) ; } }
public boolean be direct field access ( ) { return this . direct field access ; }
public string get address ( ) { return this . address ; } // -- string get address ( )
public static string sanitize file name ( path path ) { string p = path . get file name ( ) . to string ( ) ; if ( p . length ( ) > 1 & & p . char at ( p . length ( ) - 1 ) == '/ ' ) { return p . substring ( 0 , p . length ( ) - 1 ) ; } return p ; }
public long get n ( ) { return n ; }
public static string p ( class n ) { return n . get name ( ) . replace ( ' . ' , '/ ' ) ; }
public static class get array base type ( class array class ) throw reflect error { if ( ! array class . be array ( ) ) throw new reflect error ( `` the class be not an array . `` ) ; return array class . get component type ( ) ; }
public long long value ( ) { return value ; }
public p d form x object get alternate icon ( ) { c o s base i = this . get c o s object ( ) . get dictionary object ( c o s name . ix ) ; if ( i instanceof c o s stream ) { return new p d form x object ( ( c o s stream ) i ) ; } return null ; }
public void set label ( string label ) { this . label = label ; }
public static int compare unsigned ( @ unsigned byte x , @ unsigned byte y ) { return integer . compare unsigned ( byte . to unsigned int ( x ) , byte . to unsigned int ( y ) ) ; }
public final void movnti ( mem dst , register src ) { emit x86 ( inst_movnti , dst , src ) ; }
public final void rdtsc ( ) { emit x86 ( inst_rdtsc ) ; }
public final void popfq ( ) { emit x86 ( inst_popfq ) ; }
public final void popfq ( ) { emit x86 ( inst_popfq ) ; }
public final void or_ ( register dst , register src ) { emit x86 ( inst_or , dst , src ) ; }
public final void popfq ( ) { emit x86 ( inst_popfq ) ; }
public final void popfq ( ) { emit x86 ( inst_popfq ) ; }
public final void popfq ( ) { emit x86 ( inst_popfq ) ; }
public final void or_ ( register dst , register src ) { emit x86 ( inst_or , dst , src ) ; }
public final void paddusb ( m m register dst , m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( m m register dst , m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( m m register dst , m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( m m register dst , m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public void at member ( member mem ) throw compile error { at field read ( mem ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void movntpd ( mem dst , x m m register src ) { emit x86 ( inst_movntpd , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( m m register dst , m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void pcmpestrm ( x m m register dst , x m m register src , immediate imm8 ) { emit x86 ( inst_pcmpestrm , dst , src , imm8 ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void paddusb ( x m m register dst , x m m register src ) { emit x86 ( inst_paddusb , dst , src ) ; }
public final void dpps ( x m m register dst , x m m register src , immediate imm8 ) { emit x86 ( inst_dpps , dst , src , imm8 ) ; }
public final void dpps ( x m m register dst , x m m register src , immediate imm8 ) { emit x86 ( inst_dpps , dst , src , imm8 ) ; }
public boolean support check ( ) { return false ; }
public output < string > output ( ) { return output ; }
public call method builder with param type ( class < ? > . . . param type ) { this . param type = param type ; if ( param type ! = null ) { this . param count = param type . length ; } else { param count = 0 ; } return this ; }
public void set mode ( string mode ) { this . mode = mode ; }
public collection < statement > get statement ( ) { return statement ; }
public boolean be return all on updatable record ( ) { return return all on updatable record ; }
public boolean be updatable primary key ( ) { return updatable primary key ; }
public void set map constructor parameter name in kotlin ( boolean value ) { this . map constructor parameter name in kotlin = value ; }
public object [ ] get meta method ( ) { meta class meta class = invoker helper . get meta class ( object under inspection ) ; list meta method = meta class . get meta method ( ) ; object [ ] result = new object [ meta method . size ( ) ] ; int i = 0 ; for ( iterator iter = meta method . iterator ( ) ; iter . have next ( ) ; i++ ) { meta method meta method = ( meta method ) iter . next ( ) ; result [ i ] = method info ( meta method ) ; } return result ; }
public void set parse unsupported syntax ( parse unsupported syntax value ) { this . parse unsupported syntax = value ; }
public parse unsupported syntax get parse unsupported syntax ( ) { return parse unsupported syntax ; }
public int get fetch size ( ) { return fetch size ; }
protect static string quote array ( string [ ] s ) { return string utils . quote java string array ( s ) ; }
public static d s l context use ( connection provider connection provider , s q l dialect dialect , setting setting ) { return new default d s l context ( connection provider , dialect , setting ) ; }
public static d s l context use ( data source datasource , s q l dialect dialect ) { return new default d s l context ( datasource , dialect ) ; }
public void set select ( expression select , configuration config ) throw x path exception { this . select = select ; adopt child expression ( select ) ; }
public static < r extend record > table < r > table ( r record ) { return table ( ( r [ ] ) new record [ ] { record } ) ; }
public object writer with view ( class < ? > view ) { return _new ( this , _config . with view ( view ) ) ; }
public string get table ( ) { return table ; }
public string get revoke u r l ( ) { return this . revoke u r l ; }
public void set user name ( string user name ) { check tar file set attribute allow ( ) ; user name set = true ; this . user name = user name ; }
public void add role name ( string role name ) { if ( role names == null ) { role name = new . array list ( ) ; } role name . add ( role name ) ; }
public static table < record > table ( name name ) { return new table impl < record > ( name ) ; }
public boolean be final ( ) { return this . modifier keyword == modifier keyword . final_keyword ; }
public string get table name ( ) { return table name ; }
public collection < statement > get statement ( ) { return statement ; }
public list < condition > get condition ( ) { return condition ; }
public list < condition > get condition ( ) { return condition ; }
public list < condition > get condition ( ) { return condition ; }
public static select select step < record1 < integer > > select zero ( ) { return dsl ( ) . select zero ( ) ; }
public static < t > field < t > coerce ( object value , data type < t > a ) { return tool . field ( value ) . coerce ( a ) ; }
public static < t > field < t > coerce ( object value , field < t > a ) { return tool . field ( value ) . coerce ( a ) ; }
public static < t > field < t > coerce ( object value , field < t > a ) { return tool . field ( value ) . coerce ( a ) ; }
public static < t > field < t > coalesce ( t value , t . . . value ) { return coalesce0 ( tool . field ( value ) , tool . field ( value ) . to array ( empty_field ) ) ; }
public field set set field ( field field ) { return set field ( new field description . for loaded field ( field ) ) ; }
public static field < offset date time > offset date time ( offset date time value ) { return offset date time ( tool . field ( value ) ) ; }
public static field < offset date time > offset date time ( string value ) { return tool . field ( convert . convert ( value , offset date time . class ) ) ; }
public static field < big decimal > deg ( number value ) { return deg ( tool . field ( value ) ) ; }
public static field < big decimal > tanh ( number value ) { return tanh ( tool . field ( value ) ) ; }
public boolean be function ( ) { return this . function ; }
public list < condition > get condition ( ) { return condition ; }
public static < t > window ignore null step < t > first value ( field < t > field ) { return new org . jooq . impl . function < t > ( `` first_value `` , null safe data type ( field ) , null safe ( field ) ) ; }
protect static < t > data type < t > null safe data type ( field < t > field ) { return ( data type < t > ) ( field == null ? s q l data type . other : field . get data type ( ) ) ; }
public integer get inline threshold ( ) { return inline threshold ; }
public static < t > window ignore null step < t > first value ( field < t > field ) { return new org . jooq . impl . function < t > ( `` first_value `` , null safe data type ( field ) , null safe ( field ) ) ; }
public final j s o n format indent ( int new indent ) { return new j s o n format ( format , newline , global indent , new indent , null , header , record format , wrap single column record , quote nest ) ; }
public string get indent ( ) { return indent ; }
public boolean be final ( ) { return this == final ; }
public void remove element ( final int from , final int to ) { it . unimi . dsi . fastutil . array . ensure from to ( size , from , to ) ; system . arraycopy ( a , to , a , from , size - to ) ; size -= ( to - from ) ; }
public boolean be compile ( ) { return this . compile ; }
public static boolean be kotlin reflect present ( ) { return kotlin reflect present ; }
public static void info ( final string message ) { log ( info , message ) ; }
public static int end with ( string [ ] search string , string text ) { int index= -1 ; for ( int i= 0 ; i < search string . length ; i++ ) { if ( text . end with ( search string [ i ] ) ) { if ( index == -1 || search string [ i ] . length ( ) > search string [ index ] . length ( ) ) index= i ; } } return index ; }
public static boolean be empty ( object [ ] array ) { return array == null || array . length == 0 ; }
public void add hour ( int hour ) { super . add field ( duration field type . hour ( ) , hour ) ; }
public static long convert ( long nano time ) { final long timestamp base [ ] = timestamp_base ; return timestamp base [ 0 ] + time unit . nanosecond . to millis ( nano time - timestamp base [ 1 ] ) ; }
public long long value ( ) { return value ; }
public i content type matcher get matcher ( ) { return matcher ; }
public boolean get be encrypt ( ) { return this . be encrypt ; }
public string to turtle ( ) { string val = this . value ; val = val . replace ( `` \ `` `` , `` \\\ `` `` ) ; val = `` \ `` `` +val+ `` \ `` `` ; if ( data type == null ) { if ( language ! = null ) { val = val+ `` @ `` +language ; } } else { val = val+ `` ^^ < `` + data type . get xml schema u r i string ( ) + `` > `` ; } return val ; }
public static double value source from int field ( string field ) { return from long field ( field ) ; }
public void set table ( string value ) { this . table = value ; }
public string get table ( ) { return table ; }
public void set table ( string value ) { this . table = value ; }
public void set maximum length ( final int max length ) { maximum length = max length ; }
public int get position ( ) { return position ; }
public int get generation ( ) { return generation ; }
public boolean be nullable ( ) { return this . nullable ; }
public string get schema ( ) { return schema ; }
public string get catalog name ( ) { return this . catalog name ; }
public void set empty value ( string empty value ) { this . empty value = empty value ; }
public object get fetch value ( ) { return fetch value ; }
public int get threshold ( ) { return threshold ; }
public boolean be map constructor parameter name ( ) { return map constructor parameter name ; }
public void set foreign key ( string value ) { this . foreign key = value ; }
public output < boolean > precision ( ) { return precision ; }
protect view node create view node ( ) { return new view node ( ) ; }
public static void set keep command file ( job conf conf , boolean keep ) { conf . set boolean ( submitter . preserve_commandfile , keep ) ; }
public boolean be synthetic ( ) { return synthetic ; }
public final j s o n format indent ( int new indent ) { return new j s o n format ( format , newline , global indent , new indent , null , header , record format , wrap single column record , quote nest ) ; }
public final j s o n format global indent ( int new global indent ) { return new j s o n format ( format , newline , new global indent , indent , null , header , record format , wrap single column record , quote nest ) ; }
public static drop table step drop table if exists ( string table ) { return dsl ( ) . drop table if exists ( table ) ; }
public void set order ( int order ) { this . order = order ; }
public static final source of ( file file , string charset name ) { return new source ( null , null , charset name , null , null , null , null , file ) ; }
public static final source of ( file file ) { return new source ( null , null , null , null , null , null , null , file ) ; }
public string get family name ( ) { return family name ; }
public class < t > get type ( ) { return type ; }
public void set enforce init method ( boolean enforce init method ) { this . enforce init method = enforce init method ; }
public void add ( column column ) { if ( boolean . false . equal ( generate key request ) ) { return ; } row . add ( column ) ; }
protect void generate table class footer ( table definition table , java writer out ) { }
protect void generate table class footer ( table definition table , java writer out ) { }
protect void generate dao class footer ( table definition table , java writer out ) { }
public void set include exclude package routine ( boolean value ) { this . include exclude package routine = value ; }
public void set include exclude package routine ( boolean value ) { this . include exclude package routine = value ; }
public string get include ( ) { return include ; }
public string get provider ( ) { return provider ; }
public void set table ( boolean value ) { this . table = value ; }
public query get query ( ) { return query ; }
public void set user ( string user ) { super . set internal user ( user ) ; }
public string get expression ( ) { return expression ; }
public void set join table ( jaxb join table value ) { this . join table = value ; }
public void set generate annotation date ( boolean value ) { this . generate annotation date = value ; }
protect block queue < runnable > create queue ( int queue capacity ) { if ( queue capacity > 0 ) { return new link block queue < runnable > ( queue capacity ) ; } else { return new synchronous queue < runnable > ( ) ; } }
public object [ ] to array ( ) { object [ ] o = new object [ _size ] ; int i = 0 ; for ( t linkable link = _head ; link ! = null ; link = link . get next ( ) ) { o [ i++ ] = link ; } return o ; }
public string get table ( ) { return table ; }
public void set table ( string value ) { this . table = value ; }
public void set pojos to string ( boolean value ) { this . pojos to string = value ; }
public void set pojos ( boolean value ) { this . pojos = value ; }
public void set pojos ( boolean value ) { this . pojos = value ; }
public static annotation [ ] get filtering annotation ( final annotation [ ] annotation ) { if ( annotation == null || annotation . length == 0 ) { return filter helper . empty_annotations ; } final list < annotation > filtering annotation = new array list < > ( annotation . length ) ; for ( final annotation annotation : annotation ) { final class < ? extend annotation > annotation type = annotation . annotation type ( ) ; for ( final annotation meta annotation : annotation type . get declared annotation ( ) ) { if ( meta annotation instanceof entity filter ) { filter annotation . add ( annotation ) ; } } } return filter annotation . to array ( new annotation [ filter annotation . size ( ) ] ) ; }
public boolean be global sequence reference ( ) { return global sequence reference ; }
public boolean be global queue reference ( ) { return global queue reference ; }
public boolean be global sequence reference ( ) { return global sequence reference ; }
public boolean be global sequence reference ( ) { return global sequence reference ; }
public void set comment on queue ( boolean value ) { this . comment on queue = value ; }
public boolean be comment on key ( ) { return comment on key ; }
public void set comment on sequence ( boolean value ) { this . comment on sequence = value ; }
public boolean be comment on link ( ) { return comment on link ; }
public meta method get setter ( ) { return setter ; }
protect final string read fully ( ) throw i o exception { return file utils . read fully ( in , buffer_size ) ; }
public string get catalog name ( ) { return this . catalog name ; }
public void set run strategy ( collection < run strategy > strategy ) { strategy list . clear ( ) ; iterator < run strategy > strat iter = strategy . iterator ( ) ; while ( strat iter . have next ( ) ) strategy list . add ( strat iter . next ( ) ) ; }
public database structure get database structure ( ) { return database structure ; }
public transform client transform ( ) { return transform client ; }
public string get expression ( ) { return expression ; }
public string get expression ( ) { return expression ; }
public void set table ( string value ) { this . table = value ; }
public string get name ( ) { return name ; }
public boolean be include trigger routine ( ) { return include trigger routine ; }
public string get include ( ) { return include ; }
public string get include ( ) { return include ; }
public string get comment ( ) { return comment ; }
public string get expression ( ) { return expression ; }
public void set generate annotation ( boolean value ) { this . generate annotation = value ; }
public string get domain ( ) { return domain ; }
public string get name ( ) { return name ; }
public boolean be table ( ) { return table ; }
public location get location ( ) { return this . location ; }
public constraint find constraint ( session session , string name ) { constraint constraint = constraint . get ( name ) ; if ( constraint == null ) { constraint = session . find local temp table constraint ( name ) ; } return constraint ; }
public void set issuer ( list < byte [ ] > issuer ) { c o s array array = new c o s array ( ) ; for ( byte [ ] issuer : issuer ) { array . add ( new c o s string ( issuer ) ) ; } this . dictionary . set item ( c o s name . issuer , array ) ; }
public void set subject ( string subject ) { this . subject = subject ; }
public jwt consumer builder set require subject ( ) { this . require subject = true ; return this ; }
public final < t > void register bean ( class < t > bean class , bean definition customizer . . . customizers ) { register bean ( null , bean class , null , customizers ) ; }
public set < audience > get expect audience ( ) { return claim set verifier . get expect audience ( ) ; }
public void set header ( string header ) { this . header = header ; }
public throwable get root cause ( ) { throwable root cause = this ; throwable cause = get cause ( ) ; while ( cause ! = null & & cause ! = root cause ) { root cause = cause ; cause = cause . get cause ( ) ; } return root cause ; }
public tag tag ( ) { return tag ; }
public void previous page ( ) { if ( ! be first page ( ) ) { this . page -- ; } }
public list fragment ( ) { return this . fragment ; }
public string get description ( ) { return description ; }
public string get prefix ( ) { return prefix ; }
public tag tag ( ) { return tag ; }
public scope get scope ( ) { return scope ; } // get scope
public final flux < t > repeat ( long num repeat , boolean supplier predicate ) { if ( num repeat < 0l ) { throw new illegal argument exception ( `` num repeat > = 0 require `` ) ; } if ( num repeat == 0 ) { return this . flux ( ) ; } return flux . defer ( ( ) - > repeat ( flux . count boolean supplier ( predicate , num repeat ) ) ) ; }
public byte [ ] to byte array unsafe ( ) { int total size = size ( ) ; if ( total size == 0 ) { return new byte [ 0 ] ; } resize ( total size ) ; return this . buffer . get first ( ) ; }
public void set transfer ( c o s base transfer ) { this . transfer = transfer ; }
public big integer get abstract num i d ( big integer num i d ) { x w p f num num = get num ( num i d ) ; if ( num == null ) return null ; if ( num . get c t num ( ) == null ) return null ; if ( num . get c t num ( ) . get abstract num id ( ) == null ) return null ; return num . get c t num ( ) . get abstract num id ( ) . get val ( ) ; }
public double get scale ( ) { return scale ; }
public long get upload setup time ( ) { return m upload setup time ; }
public void set download setup time ( final long setup time ) { this . m download setup time = setup time ; }
public void add intersection ( line intersector li , int segment index , int geom index , int int index ) { coordinate int pt = new coordinate ( li . get intersection ( int index ) ) ; add intersection ( int pt , segment index ) ; }
public int get index ( ) { return index ; }
public static void assign hole to shell ( list hole , list shell ) { hole assigner assigner = new hole assigner ( shell ) ; assigner . assign hole to shell ( hole ) ; }
public coordinate [ ] snap to ( coordinate [ ] snap pt ) { coordinate list coord list = new coordinate list ( src pt ) ; snap vertex ( coord list , snap pt ) ; snap segment ( coord list , snap pt ) ; coordinate [ ] new pt = coord list . to coordinate array ( ) ; return new pt ; }
public void transform ( coordinate sequence seq , int i ) { double xp = m00 * seq . get ordinate ( i , 0 ) + m01 * seq . get ordinate ( i , 1 ) + m02 ; double yp = m10 * seq . get ordinate ( i , 0 ) + m11 * seq . get ordinate ( i , 1 ) + m12 ; seq . set ordinate ( i , 0 , xp ) ; seq . set ordinate ( i , 1 , yp ) ; }
public static void parse geometry ( geometry geometry , target target ) { parse geometry ( geometry , target , 0 ) ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public void set user data ( object user data ) { this . user data = user data ; }
public object get user data ( ) { return user data ; }
public void remove ( ) { throw new unsupported operation exception ( ) ; }
public static query new slow polygon query ( string field , x y polygon . . . polygon ) { return new slow geometry query ( field , polygon ) ; }
public multi polygon create multi polygon ( polygon [ ] polygon ) { return new multi polygon ( polygon , this ) ; }
public int get array dimension ( ) { return this . array dimension ; }
public static boolean match ( int actual dimension value , char require dimension symbol ) { if ( require dimension symbol == dimension . sym_dontcare ) { return true ; } if ( require dimension symbol == dimension . sym_true & & ( actual dimension value > = 0 || actual dimension value == dimension . true ) ) { return true ; } if ( require dimension symbol == dimension . sym_false & & actual dimension value == dimension . false ) { return true ; } if ( require dimension symbol == dimension . sym_p & & actual dimension value == dimension . p ) { return true ; } if ( require dimension symbol == dimension . sym_l & & actual dimension value == dimension . l ) { return true ; } if ( require dimension symbol == dimension . sym_a & & actual dimension value == dimension . a ) { return true ; } return false ; }
public boolean match ( string require dimension symbol ) { if ( require dimension symbol . length ( ) ! = 9 ) { throw new illegal argument exception ( `` should be length 9 : `` + required dimension symbol ) ; } for ( int ai = 0 ; ai < 3 ; ai++ ) { for ( int bi = 0 ; bi < 3 ; bi++ ) { if ( ! match ( matrix [ ai ] [ bi ] , require dimension symbol . char at ( 3 * ai + bi ) ) ) { return false ; } } } return true ; }
public void set all ( int dimension value ) { for ( int ai = 0 ; ai < 3 ; ai++ ) { for ( int bi = 0 ; bi < 3 ; bi++ ) { matrix [ ai ] [ bi ] = dimension value ; } } }
public output < t > y ( ) { return y ; }
public static string to point ( coordinate p0 ) { return `` point ( `` + p0 . x + `` `` + p0 . y + `` ) `` ; }
public geo distance query builder distance ( string distance ) { return distance ( distance , distance unit . default ) ; }
public boolean equal ( object other ) { return ( this == other || ( other instanceof bean component definition & & super . equal ( other ) ) ) ; }
public static int calculate mod10 check ( final list < integer > digit , int multiplier , int weight ) { int sum = 0 ; boolean even = true ; for ( int index = digit . size ( ) - 1 ; index > = 0 ; index -- ) { int digit = digits . get ( index ) ; if ( even ) { digit * = multiplier ; } else { digit * = weight ; } sum += digit ; even = ! even ; } return ( 10 - ( sum % 10 ) ) % 10 ; }
public void set default scale ( final int scale ) { this . m scale = scale ; }
public void set enable external configuration ( boolean enable external configuration ) { this . enable external configuration = enable external configuration ; }
protect static boolean have non empty element ( geometry [ ] geometry ) { for ( int i = 0 ; i < geometry . length ; i++ ) { if ( ! geometry [ i ] . be empty ( ) ) { return true ; } } return false ; }
protect boolean be any target component in area test ( geometry test geom , list target rep pt ) { point on geometry locator pia loc = new simple point in area locator ( test geom ) ; for ( iterator i = target rep pt . iterator ( ) ; i . have next ( ) ; ) { coordinate p = ( coordinate ) i . next ( ) ; int loc = pia loc . locate ( p ) ; if ( loc ! = location . exterior ) return true ; } return false ; }
protect boolean be all test component in target interior ( geometry test geom ) { list coords = component coordinate extracter . get coordinate ( test geom ) ; for ( iterator i = coords . iterator ( ) ; i . have next ( ) ; ) { coordinate p = ( coordinate ) i . next ( ) ; int loc = target point locator . locate ( p ) ; if ( loc ! = location . interior ) return false ; } return true ; }
public output < t > y ( ) { return y ; }
public int update ( long p1 , long p2 ) throw data access exception { return update ( new object [ ] { p1 , p2 } ) ; }
public void rotate ( double theta , double x , double y ) { _transform . rotate ( theta , x , y ) ; }
public boolean match ( string seq ) { return queue . region match ( true , po , seq , 0 , seq . length ( ) ) ; }
public string to string ( ) { return to string ( `` `` ) ; }
public static double area ( coordinate a , coordinate b , coordinate c ) { return math . ab ( ( ( c . x - a . x ) * ( b . y - a . y ) - ( b . x - a . x ) * ( c . y - a . y ) ) / 2 ) ; }
public void set arm length ratio ( double arm length ratio ) { this . arm length ratio = arm length ratio ; }
public static object to primitive ( final object array ) { if ( array == null ) { return null ; } final class < ? > ct = array . get class ( ) . get component type ( ) ; final class < ? > pt = class utils . wrapper to primitive ( ct ) ; if ( integer . type . equal ( pt ) ) { return to primitive ( ( integer [ ] ) array ) ; } if ( long . type . equal ( pt ) ) { return to primitive ( ( long [ ] ) array ) ; } if ( short . type . equal ( pt ) ) { return to primitive ( ( short [ ] ) array ) ; } if ( double . type . equal ( pt ) ) { return to primitive ( ( double [ ] ) array ) ; } if ( float . type . equal ( pt ) ) { return to primitive ( ( float [ ] ) array ) ; } return array ; }
public int size ( ) { if ( root ! = null ) return root . size ( ) ; return 0 ; }
public void set discount overlap ( boolean v ) { discount overlap = v ; }
public static double sinh ( double x ) { return ( math . exp ( x ) - math . exp ( -x ) ) / 2 . 0 ; }
public int node size ( ) { if ( root ! = null ) return root . node size ( ) ; return 0 ; }
public iterable < item > get item ( ) { return this . item ; }
public boolean intersects ( double x1 , double y1 , double w , double h ) { double x2 = x1 + w ; double y2 = y1 + h ; if ( contains ( x1 , y1 ) ) return true ; if ( contains ( x1 , y2 ) ) return true ; if ( contains ( x2 , y1 ) ) return true ; if ( contains ( x2 , y2 ) ) return true ; int n = get num point ( ) ; if ( n == 0 ) return false ; double [ ] p = get ( 0 ) ; double xb = p [ ai0 ] ; double yb = p [ ai1 ] ; for ( int i = 1 ; i < n ; i++ ) { p = get ( i ) ; double xa = p [ ai0 ] ; double ya = p [ ai1 ] ; if ( get type ( i ) == multi path . line_to ) { if ( geom . get seg seg intersection ( xa , ya , xb , yb , x1 , y1 , x2 , y1 , null ) == geom . intersect ) return true ; if ( geom . get seg seg intersection ( xa , ya , xb , yb , x1 , y1 , x1 , y2 , null ) == geom . intersect ) return true ; if ( geom . get seg seg intersection ( xa , ya , xb , yb , x1 , y2 , x2 , y2 , null ) == geom . intersect ) return true ; if ( geom . get seg seg intersection ( xa , ya , xb , yb , x2 , y1 , x2 , y2 , null ) == geom . intersect ) return true ; if ( xa > = x1 & & ya > = y1 & & xa < = x2 & & ya < = y2 ) return true ; if ( xb > = x1 & & yb > = y1 & & xb < = x2 & & yb < = y2 ) return true ; } xb = xa ; yb = ya ; } return false ; }
public void set last response input stream ( input stream in stream ) { last response input stream = in stream ; }
public boolean be horizontal ( ) { return p0 . y == p1 . y ; }
public int get major version ( ) { return major ; }
public linear location index of ( coordinate pt ) { return location index of point . index of ( linear geom , pt ) ; }
public static boolean be valid name for component ( string component ) { if ( component . equal ( `` . `` ) || component . equal ( `` . . `` ) || component . index of ( `` : `` ) > = 0 || component . index of ( `` / `` ) > = 0 ) { return false ; } return ! be reserve path component ( component ) ; }
public int get index along segment ( int segment index , int int index ) { compute int line index ( ) ; return int line index [ segment index ] [ int index ] ; }
public double index of after ( coordinate pt , double min index ) { return length index of point . index of after ( linear geom , pt , min index ) ; }
public boolean be na n ( ) { return be na n ; }
public boolean equal ( dd y ) { return hi == y . hi & & lo == y . lo ; }
public output < t > y ( ) { return y ; }
public int get index ( ) { return index ; }
public boolean be valid ( string value ) { return be valid ( value , ( string ) null , ( locale ) null ) ; }
public static interior intersection finder create intersection counter ( line intersector li ) { interior intersection finder finder = new interior intersection finder ( li ) ; finder . set find all intersection ( true ) ; finder . set keep intersection ( false ) ; return finder ; }
public static interior intersection finder create all intersection finder ( line intersector li ) { interior intersection finder finder = new interior intersection finder ( li ) ; finder . set find all intersection ( true ) ; return finder ; }
public void add intersection ( line intersector li , int segment index , int geom index , int int index ) { coordinate int pt = new coordinate ( li . get intersection ( int index ) ) ; add intersection ( int pt , segment index ) ; }
public coordinate get intersection ( int int index ) { return int pt [ int index ] ; }
public void set constraint ( list segment , list seg vertex ) { this . segment = segment ; this . seg vertex = seg vertex ; }
public output < boolean > precision ( ) { return precision ; }
public void set line cap style ( int style ) { dict . set int ( c o s name . lc , style ) ; }
public builder < t > set direct address max oversizing factor ( float factor ) { direct address max oversizing factor = factor ; return this ; }
public location get location ( ) { return this . location ; }
public list < overlay edge > get result area edge ( ) { list < overlay edge > result edge = new array list < overlay edge > ( ) ; for ( overlay edge edge : get edge ( ) ) { if ( edge . be in result area ( ) ) { result edge . add ( edge ) ; } } return result edge ; }
public int get line ( ) { return line ; }
public model build result get result ( ) { return result ; }
public static coordinate [ ] to coordinate array ( collection coord list ) { return ( coordinate [ ] ) coord list . to array ( coord array type ) ; }
public void add out edge ( directed edge de ) { de star . add ( de ) ; }
public list < overlay edge > get result area edge ( ) { list < overlay edge > result edge = new array list < overlay edge > ( ) ; for ( overlay edge edge : get edge ( ) ) { if ( edge . be in result area ( ) ) { result edge . add ( edge ) ; } } return result edge ; }
public void set visitor ( boolean visitor ) { optional attrs . put ( visitor , visitor ? boolean . true : boolean . false ) ; }
public final void set matrix ( matrix matrix ) { c o s array matrix array = null ; if ( matrix ! = null ) { matrix array = matrix . to c o s array ( ) ; } dictionary . set item ( c o s name . matrix , matrix array ) ; }
public line merge direct edge get next ( ) { if ( get to node ( ) . get degree ( ) ! = 2 ) { return null ; } if ( get to node ( ) . get out edge ( ) . get edge ( ) . get ( 0 ) == get sym ( ) ) { return ( line merge direct edge ) get to node ( ) . get out edge ( ) . get edge ( ) . get ( 1 ) ; } assert . be true ( get to node ( ) . get out edge ( ) . get edge ( ) . get ( 1 ) == get sym ( ) ) ; return ( line merge direct edge ) get to node ( ) . get out edge ( ) . get edge ( ) . get ( 0 ) ; }
public object get data ( ) { return this . response data ; }
public void remove ( directed edge de ) { de star . remove ( de ) ; }
public void add out edge ( directed edge de ) { de star . add ( de ) ; }
protect static boolean get bit ( int bit vector , int offset ) { int mask = 1 < < offset ; return ( bit vector & mask ) ! = 0 ; }
public geo distance query builder distance ( string distance ) { return distance ( distance , distance unit . default ) ; }
public void set vertex ( float [ ] vertex ) { c o s array new vertex = new c o s array ( ) ; new vertex . set float array ( vertex ) ; annot . set item ( c o s name . vertex , new vertex ) ; }
public quad edge triangle [ ] get neighbour ( ) { quad edge triangle [ ] neigh = new quad edge triangle [ 3 ] ; for ( int i = 0 ; i < 3 ; i++ ) { neigh [ i ] = ( quad edge triangle ) get edge ( i ) . sym ( ) . get data ( ) ; } return neigh ; }
public void set vertex ( float [ ] vertex ) { c o s array new vertex = new c o s array ( ) ; new vertex . set float array ( vertex ) ; annot . set item ( c o s name . vertex , new vertex ) ; }
public quad edge triangle [ ] get neighbour ( ) { quad edge triangle [ ] neigh = new quad edge triangle [ 3 ] ; for ( int i = 0 ; i < 3 ; i++ ) { neigh [ i ] = ( quad edge triangle ) get edge ( i ) . sym ( ) . get data ( ) ; } return neigh ; }
public list get voronoi cell polygon ( geometry factory geom fact ) { / * * compute circumcentres of triangle a vertex for dual edge . * precomputing the circumcentres be more efficient , * and more importantly ensure that the computed centre * be consistent across the voronoi cell . * / visit triangle ( new triangle circumcentre visitor ( ) , true ) ; list cell = new array list ( ) ; collection edge = get vertex unique edge ( false ) ; for ( iterator i = edge . iterator ( ) ; i . have next ( ) ; ) { quad edge qe = ( quad edge ) i . next ( ) ; cell . add ( get voronoi cell polygon ( qe , geom fact ) ) ; } return cell ; }
public static double magnitude ( final double x , final double y , final double z ) { return math . sqrt ( x * x + y * y + z * z ) ; }
public line string get line ( ) { return line ; }
public static coordinate [ ] to coordinate array ( collection coord list ) { return ( coordinate [ ] ) coord list . to array ( coord array type ) ; }
public s o a p envelope get envelope ( ) { return message ; }
public static void parse geometry ( geometry geometry , target target ) { parse geometry ( geometry , target , 0 ) ; }
public location get location ( ) { return this . location ; }
public void set num arm ( int num arm ) { this . num arm = num arm ; }
public void set context ( string context ) { if ( context . start with ( `` / `` ) ) { this . context = context ; } else { this . context = `` / `` + context ; } }
public final byte [ ] buffer ( ) { return buf ; }
public boolean be strict encode ( ) { return this . strict encoding ; }
public float get z ( ) { return z ; }
public static double magnitude ( final double x , final double y , final double z ) { return math . sqrt ( x * x + y * y + z * z ) ; }
public line merge direct edge get next ( ) { if ( get to node ( ) . get degree ( ) ! = 2 ) { return null ; } if ( get to node ( ) . get out edge ( ) . get edge ( ) . get ( 0 ) == get sym ( ) ) { return ( line merge direct edge ) get to node ( ) . get out edge ( ) . get edge ( ) . get ( 1 ) ; } assert . be true ( get to node ( ) . get out edge ( ) . get edge ( ) . get ( 1 ) == get sym ( ) ) ; return ( line merge direct edge ) get to node ( ) . get out edge ( ) . get edge ( ) . get ( 0 ) ; }
public int get return op ( ) { return return op ; }
public io . vertx . reactivex . ext . shell . shell create shell ( io . vertx . reactivex . ext . shell . term . term term ) { io . vertx . reactivex . ext . shell . shell ret = io . vertx . reactivex . ext . shell . shell . new instance ( ( io . vertx . ext . shell . shell ) delegate . create shell ( term . get delegate ( ) ) ) ; return ret ; }
public polygon create polygon ( coordinate sequence shell ) { return create polygon ( create linear ring ( shell ) ) ; }
public collection < statement > get statement ( ) { return statement ; }
public list < t > get ( ) { return new array list < t > ( field ) ; }
public double histogram copy correct for coordinated omission ( final double expect interval between value sample ) { final double histogram target histogram = new double histogram ( configured high to lowest value ratio , get number of significant value digit ( ) ) ; target histogram . set trackable value range ( current low value in auto range , current high value limit in auto range ) ; target histogram . add while correct for coordinate omission ( this , expect interval between value sample ) ; return target histogram ; }
public int size ( ) { return size ; }
public list < operation > static operation ( ) { return static operation ; }
public static < t > sub < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` sub `` , scope . make op name ( `` sub `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new sub < t > ( op builder . build ( ) ) ; }
public output < t > sparse value ( ) { return sparse value ; }
public output < string > output ( ) { return output ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public static < t > sub < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` sub `` , scope . make op name ( `` sub `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new sub < t > ( op builder . build ( ) ) ; }
public io . vertx . axle . core . cli . cli set summary ( string summary ) { delegate . set summary ( summary ) ; return this ; }
public i type get handle ( ) { return this . handle ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public int size ( ) { return size ; }
public static experimental assert next dataset create ( scope scope , operand < ? > input dataset , operand < string > transformation , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental assert next dataset `` , scope . make op name ( `` experimental assert next dataset `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; op builder . add input ( transformation . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new experimental assert next dataset ( op builder . build ( ) ) ; }
public static void set delete old db ( boolean delete old db ) { db upgrade . delete old db = delete old db ; }
public static < t extend number > bitwise xor < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` bitwise xor `` , scope . make op name ( `` bitwise xor `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new bitwise xor < t > ( op builder . build ( ) ) ; }
public static < t extend number > bitwise or < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` bitwise or `` , scope . make op name ( `` bitwise or `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new bitwise or < t > ( op builder . build ( ) ) ; }
public output < string > output ( ) { return output ; }
public void set max request attempt ( int attempt ) { this . max request attempt = attempt ; }
public output < string > summary ( ) { return summary ; }
public restore snapshot request partial ( boolean partial ) { this . partial = partial ; return this ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public static < t > tile grad < t > create ( scope scope , operand < t > input , operand < integer > multiple ) { operation builder op builder = scope . graph ( ) . op builder ( `` tile grad `` , scope . make op name ( `` tile grad `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( multiple . a output ( ) ) ; return new tile grad < t > ( op builder . build ( ) ) ; }
public void increment weight ( double weight ) { this . weight += weight ; }
public static < t > var handle op create ( scope scope , class < t > dtype , shape shape , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` var handle op `` , scope . make op name ( `` var handle op `` ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; op builder . set attr ( `` shape `` , shape ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new var handle op ( op builder . build ( ) ) ; }
public inter process mutex read lock ( ) { return read mutex ; }
public static < t extend number > depthwise conv2d native < t > create ( scope scope , operand < t > input , operand < t > filter , list < long > stride , string padding , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` depthwise conv2d native `` , scope . make op name ( `` depthwise conv2d native `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input ( filter . a output ( ) ) ; long [ ] stride array = new long [ stride . size ( ) ] ; for ( int i = 0 ; i < stride array . length ; ++i ) { strides array [ i ] = stride . get ( i ) ; } op builder . set attr ( `` stride `` , stride array ) ; op builder . set attr ( `` pad `` , pad ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . data format ! = null ) { op builder . set attr ( `` data_format `` , opts . data format ) ; } if ( opts . dilation ! = null ) { long [ ] dilation array = new long [ opts . dilation . size ( ) ] ; for ( int i = 0 ; i < dilation array . length ; ++i ) { dilation array [ i ] = opts . dilation . get ( i ) ; } op builder . set attr ( `` dilation `` , dilation array ) ; } } } return new depthwise conv2d native < t > ( op builder . build ( ) ) ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public output < long > decode value ( ) { return decode value ; }
public output < long > decode index ( ) { return decode index ; }
public output < long > decode value ( ) { return decode value ; }
public output < t > loss ( ) { return loss ; }
public static experimental match file dataset create ( scope scope , operand < string > pattern ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental matching file dataset `` , scope . make op name ( `` experimental matching file dataset `` ) ) ; op builder . add input ( pattern . a output ( ) ) ; return new experimental matching file dataset ( op builder . build ( ) ) ; }
public static < t > stack < t > create ( scope scope , operand < t > value , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` pack `` , scope . make op name ( `` stack `` ) ) ; op builder . add input ( value . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . axis ! = null ) { op builder . set attr ( `` axis `` , opts . axis ) ; } } } return new stack < t > ( op builder . build ( ) ) ; }
public static < t extend number > conv2 d backprop input < t > create ( scope scope , operand < integer > input size , operand < t > filter , operand < t > out backprop , list < long > stride , string padding , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` conv2 d backprop input `` , scope . make op name ( `` conv2 d backprop input `` ) ) ; op builder . add input ( input sizes . a output ( ) ) ; op builder . add input ( filter . a output ( ) ) ; op builder . add input ( out backprop . a output ( ) ) ; long [ ] stride array = new long [ stride . size ( ) ] ; for ( int i = 0 ; i < stride array . length ; ++i ) { strides array [ i ] = stride . get ( i ) ; } op builder . set attr ( `` stride `` , stride array ) ; op builder . set attr ( `` pad `` , pad ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . use cudnn on gpu ! = null ) { op builder . set attr ( `` use_cudnn_on_gpu `` , opts . use cudnn on gpu ) ; } if ( opts . data format ! = null ) { op builder . set attr ( `` data_format `` , opts . data format ) ; } if ( opts . dilation ! = null ) { long [ ] dilation array = new long [ opts . dilation . size ( ) ] ; for ( int i = 0 ; i < dilation array . length ; ++i ) { dilation array [ i ] = opts . dilation . get ( i ) ; } op builder . set attr ( `` dilation `` , dilation array ) ; } } } return new conv2 d backprop input < t > ( op builder . build ( ) ) ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public string get content ( ) { return content ; }
public static experimental indexed dataset get create ( scope scope , operand < ? > materialize , operand < ? > index , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental indexed dataset get `` , scope . make op name ( `` experimental indexed dataset get `` ) ) ; op builder . add input ( materialize . a output ( ) ) ; op builder . add input ( index . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new experimental indexed dataset get ( op builder . build ( ) ) ; }
public static experimental assert next dataset create ( scope scope , operand < ? > input dataset , operand < string > transformation , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental assert next dataset `` , scope . make op name ( `` experimental assert next dataset `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; op builder . add input ( transformation . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new experimental assert next dataset ( op builder . build ( ) ) ; }
public int cardinality ( ) { return cardinality ; }
public static experimental assert next dataset create ( scope scope , operand < ? > input dataset , operand < string > transformation , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental assert next dataset `` , scope . make op name ( `` experimental assert next dataset `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; op builder . add input ( transformation . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new experimental assert next dataset ( op builder . build ( ) ) ; }
public static dataset to graph create ( scope scope , operand < ? > input dataset ) { operation builder op builder = scope . graph ( ) . op builder ( `` dataset to graph `` , scope . make op name ( `` dataset to graph `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; return new dataset to graph ( op builder . build ( ) ) ; }
public static experimental assert next dataset create ( scope scope , operand < ? > input dataset , operand < string > transformation , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental assert next dataset `` , scope . make op name ( `` experimental assert next dataset `` ) ) ; op builder . add input ( input dataset . a output ( ) ) ; op builder . add input ( transformation . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new experimental assert next dataset ( op builder . build ( ) ) ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public void set default scale ( final int scale ) { this . m scale = scale ; }
public big integer get abstract num i d ( big integer num i d ) { x w p f num num = get num ( num i d ) ; if ( num == null ) return null ; if ( num . get c t num ( ) == null ) return null ; if ( num . get c t num ( ) . get abstract num id ( ) == null ) return null ; return num . get c t num ( ) . get abstract num id ( ) . get val ( ) ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public static < t > var handle op create ( scope scope , class < t > dtype , shape shape , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` var handle op `` , scope . make op name ( `` var handle op `` ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; op builder . set attr ( `` shape `` , shape ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new var handle op ( op builder . build ( ) ) ; }
public void set work precision model ( precision model pm ) { work precision model = pm ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public static < t > stack < t > create ( scope scope , operand < t > value , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` pack `` , scope . make op name ( `` stack `` ) ) ; op builder . add input ( value . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . axis ! = null ) { op builder . set attr ( `` axis `` , opts . axis ) ; } } } return new stack < t > ( op builder . build ( ) ) ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public static mutex v2 create ( scope scope , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` mutex v2 `` , scope . make op name ( `` mutex v2 `` ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new mutex v2 ( op builder . build ( ) ) ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static < t > print < t > create ( scope scope , operand < t > input , iterable < operand < ? > > data , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` print `` , scope . make op name ( `` print `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input list ( operands . a output ( data ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . message ! = null ) { op builder . set attr ( `` message `` , opts . message ) ; } if ( opts . first n ! = null ) { op builder . set attr ( `` first_n `` , opts . first n ) ; } if ( opts . summarize ! = null ) { op builder . set attr ( `` summarize `` , opts . summarize ) ; } } } return new print < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static < t > matrix logarithm < t > create ( scope scope , operand < t > input ) { operation builder op builder = scope . graph ( ) . op builder ( `` matrix logarithm `` , scope . make op name ( `` matrix logarithm `` ) ) ; op builder . add input ( input . a output ( ) ) ; return new matrix logarithm < t > ( op builder . build ( ) ) ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public static l m d b reader create ( scope scope , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` l m d b reader `` , scope . make op name ( `` l m d b reader `` ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new l m d b reader ( op builder . build ( ) ) ; }
public short get y maximum ( ) { return y max ; }
public static experimental indexed dataset get create ( scope scope , operand < ? > materialize , operand < ? > index , list < class < ? > > output type , list < shape > output shape ) { operation builder op builder = scope . graph ( ) . op builder ( `` experimental indexed dataset get `` , scope . make op name ( `` experimental indexed dataset get `` ) ) ; op builder . add input ( materialize . a output ( ) ) ; op builder . add input ( index . a output ( ) ) ; data type [ ] output type array = new data type [ output type . size ( ) ] ; for ( int i = 0 ; i < output type array . length ; ++i ) { output type array [ i ] = data type . from class ( output type . get ( i ) ) ; } op builder . set attr ( `` output_types `` , output type array ) ; shape [ ] output shape array = new shape [ output shape . size ( ) ] ; for ( int i = 0 ; i < output shape array . length ; ++i ) { output shape array [ i ] = output shape . get ( i ) ; } op builder . set attr ( `` output_shapes `` , output shape array ) ; return new experimental indexed dataset get ( op builder . build ( ) ) ; }
public static order map unstage no key create ( scope scope , operand < integer > index , list < class < ? > > dtypes , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` order map unstage no key `` , scope . make op name ( `` order map unstage no key `` ) ) ; op builder . add input ( index . a output ( ) ) ; data type [ ] dtypes array = new data type [ dtypes . size ( ) ] ; for ( int i = 0 ; i < dtypes array . length ; ++i ) { dtypes array [ i ] = data type . from class ( dtypes . get ( i ) ) ; } op builder . set attr ( `` dtypes `` , dtypes array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . memory limit ! = null ) { op builder . set attr ( `` memory_limit `` , opts . memory limit ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new order map unstage no key ( op builder . build ( ) ) ; }
public static unstage create ( scope scope , list < class < ? > > dtypes , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` unstage `` , scope . make op name ( `` unstage `` ) ) ; data type [ ] dtypes array = new data type [ dtypes . size ( ) ] ; for ( int i = 0 ; i < dtypes array . length ; ++i ) { dtypes array [ i ] = data type . from class ( dtypes . get ( i ) ) ; } op builder . set attr ( `` dtypes `` , dtypes array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . memory limit ! = null ) { op builder . set attr ( `` memory_limit `` , opts . memory limit ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new unstage ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public static string format create ( scope scope , iterable < operand < ? > > input , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` string format `` , scope . make op name ( `` string format `` ) ) ; op builder . add input list ( operands . a output ( input ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . template ! = null ) { op builder . set attr ( `` template `` , opts . template ) ; } if ( opts . placeholder ! = null ) { op builder . set attr ( `` placeholder `` , opts . placeholder ) ; } if ( opts . summarize ! = null ) { op builder . set attr ( `` summarize `` , opts . summarize ) ; } } } return new string format ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static < t > stack < t > create ( scope scope , operand < t > value , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` pack `` , scope . make op name ( `` stack `` ) ) ; op builder . add input ( value . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . axis ! = null ) { op builder . set attr ( `` axis `` , opts . axis ) ; } } } return new stack < t > ( op builder . build ( ) ) ; }
public static < t > svd < t > create ( scope scope , operand < t > input , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` svd `` , scope . make op name ( `` svd `` ) ) ; op builder . add input ( input . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . compute uv ! = null ) { op builder . set attr ( `` compute_uv `` , opts . compute uv ) ; } if ( opts . full matrix ! = null ) { op builder . set attr ( `` full_matrices `` , opts . full matrix ) ; } } } return new svd < t > ( op builder . build ( ) ) ; }
public output < float > output min ( ) { return output min ; }
public static < t extend number > conv2 d backprop input < t > create ( scope scope , operand < integer > input size , operand < t > filter , operand < t > out backprop , list < long > stride , string padding , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` conv2 d backprop input `` , scope . make op name ( `` conv2 d backprop input `` ) ) ; op builder . add input ( input sizes . a output ( ) ) ; op builder . add input ( filter . a output ( ) ) ; op builder . add input ( out backprop . a output ( ) ) ; long [ ] stride array = new long [ stride . size ( ) ] ; for ( int i = 0 ; i < stride array . length ; ++i ) { strides array [ i ] = stride . get ( i ) ; } op builder . set attr ( `` stride `` , stride array ) ; op builder . set attr ( `` pad `` , pad ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . use cudnn on gpu ! = null ) { op builder . set attr ( `` use_cudnn_on_gpu `` , opts . use cudnn on gpu ) ; } if ( opts . data format ! = null ) { op builder . set attr ( `` data_format `` , opts . data format ) ; } if ( opts . dilation ! = null ) { long [ ] dilation array = new long [ opts . dilation . size ( ) ] ; for ( int i = 0 ; i < dilation array . length ; ++i ) { dilation array [ i ] = opts . dilation . get ( i ) ; } op builder . set attr ( `` dilation `` , dilation array ) ; } } } return new conv2 d backprop input < t > ( op builder . build ( ) ) ; }
public void set activation ( activation activation ) { this . activation = activation ; } // -- void set activation ( activation )
public static queue dequeue up to create ( scope scope , operand < ? > handle , operand < integer > n , list < class < ? > > component type , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` queue dequeue up to v2 `` , scope . make op name ( `` queue dequeue up to `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( n . a output ( ) ) ; data type [ ] component type array = new data type [ component type . size ( ) ] ; for ( int i = 0 ; i < component type array . length ; ++i ) { component type array [ i ] = data type . from class ( component type . get ( i ) ) ; } op builder . set attr ( `` component_types `` , component type array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . timeout m ! = null ) { op builder . set attr ( `` timeout_ms `` , opts . timeout m ) ; } } } return new queue dequeue up to ( op builder . build ( ) ) ; }
public static queue dequeue create ( scope scope , operand < ? > handle , list < class < ? > > component type , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` queue dequeue v2 `` , scope . make op name ( `` queue dequeue `` ) ) ; op builder . add input ( handle . a output ( ) ) ; data type [ ] component type array = new data type [ component type . size ( ) ] ; for ( int i = 0 ; i < component type array . length ; ++i ) { component type array [ i ] = data type . from class ( component type . get ( i ) ) ; } op builder . set attr ( `` component_types `` , component type array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . timeout m ! = null ) { op builder . set attr ( `` timeout_ms `` , opts . timeout m ) ; } } } return new queue dequeue ( op builder . build ( ) ) ; }
public static < t > print < t > create ( scope scope , operand < t > input , iterable < operand < ? > > data , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` print `` , scope . make op name ( `` print `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input list ( operands . a output ( data ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . message ! = null ) { op builder . set attr ( `` message `` , opts . message ) ; } if ( opts . first n ! = null ) { op builder . set attr ( `` first_n `` , opts . first n ) ; } if ( opts . summarize ! = null ) { op builder . set attr ( `` summarize `` , opts . summarize ) ; } } } return new print < t > ( op builder . build ( ) ) ; }
public resolve type get generic resolve type ( ) { resolve type rt = get resolve type x ( ) ; if ( rt . be parameterized type ( ) || rt . be raw type ( ) ) { return rt . get generic type ( ) ; } return rt ; }
public static < t > tensor array create ( scope scope , operand < integer > size , class < t > dtype , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array v3 `` , scope . make op name ( `` tensor array `` ) ) ; op builder . add input ( size . a output ( ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . element shape ! = null ) { op builder . set attr ( `` element_shape `` , opts . element shape ) ; } if ( opts . dynamic size ! = null ) { op builder . set attr ( `` dynamic_size `` , opts . dynamic size ) ; } if ( opts . clear after read ! = null ) { op builder . set attr ( `` clear_after_read `` , opts . clear after read ) ; } if ( opts . identical element shape ! = null ) { op builder . set attr ( `` identical_element_shapes `` , opts . identical element shape ) ; } if ( opts . tensor array name ! = null ) { op builder . set attr ( `` tensor_array_name `` , opts . tensor array name ) ; } } } return new tensor array ( op builder . build ( ) ) ; }
public static < t extend number > cholesky grad < t > create ( scope scope , operand < t > l , operand < t > grad ) { operation builder op builder = scope . graph ( ) . op builder ( `` cholesky grad `` , scope . make op name ( `` cholesky grad `` ) ) ; op builder . add input ( l . a output ( ) ) ; op builder . add input ( grad . a output ( ) ) ; return new cholesky grad < t > ( op builder . build ( ) ) ; }
public output < float > output min ( ) { return output min ; }
public static < t > assign sub < t > create ( scope scope , operand < t > ref , operand < t > value , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` assign sub `` , scope . make op name ( `` assign sub `` ) ) ; op builder . add input ( ref . a output ( ) ) ; op builder . add input ( value . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . use lock ! = null ) { op builder . set attr ( `` use_locking `` , opts . use lock ) ; } } } return new assign sub < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static save v2 create ( scope scope , operand < string > prefix , operand < string > tensor name , operand < string > shape and slice , iterable < operand < ? > > tensor ) { operation builder op builder = scope . graph ( ) . op builder ( `` save v2 `` , scope . make op name ( `` save v2 `` ) ) ; op builder . add input ( prefix . a output ( ) ) ; op builder . add input ( tensor names . a output ( ) ) ; op builder . add input ( shape and slice . a output ( ) ) ; op builder . add input list ( operands . a output ( tensor ) ) ; return new save v2 ( op builder . build ( ) ) ; }
public static save create ( scope scope , operand < string > filename , operand < string > tensor name , iterable < operand < ? > > data ) { operation builder op builder = scope . graph ( ) . op builder ( `` save `` , scope . make op name ( `` save `` ) ) ; op builder . add input ( filename . a output ( ) ) ; op builder . add input ( tensor names . a output ( ) ) ; op builder . add input list ( operands . a output ( data ) ) ; return new save ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public void set sys out ( print stream out ) { this . sys out = out ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public int get day since epoch ( ) { return day since epoch ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public output < float > loss ( ) { return loss ; }
public string to turtle ( ) { string val = this . value ; val = val . replace ( `` \ `` `` , `` \\\ `` `` ) ; val = `` \ `` `` +val+ `` \ `` `` ; if ( data type == null ) { if ( language ! = null ) { val = val+ `` @ `` +language ; } } else { val = val+ `` ^^ < `` + data type . get xml schema u r i string ( ) + `` > `` ; } return val ; }
public static < t extend number > cholesky grad < t > create ( scope scope , operand < t > l , operand < t > grad ) { operation builder op builder = scope . graph ( ) . op builder ( `` cholesky grad `` , scope . make op name ( `` cholesky grad `` ) ) ; op builder . add input ( l . a output ( ) ) ; op builder . add input ( grad . a output ( ) ) ; return new cholesky grad < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public output < t > output ( ) { return output ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public static < t > unstack < t > create ( scope scope , operand < t > value , long num , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` unpack `` , scope . make op name ( `` unstack `` ) ) ; op builder . add input ( value . a output ( ) ) ; op builder . set attr ( `` num `` , num ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . axis ! = null ) { op builder . set attr ( `` axis `` , opts . axis ) ; } } } return new unstack < t > ( op builder . build ( ) ) ; }
public static unicode transcode create ( scope scope , operand < string > input , string input encode , string output encode , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` unicode transcode `` , scope . make op name ( `` unicode transcode `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . set attr ( `` input_encoding `` , input encode ) ; op builder . set attr ( `` output_encoding `` , output encode ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . error ! = null ) { op builder . set attr ( `` error `` , opts . error ) ; } if ( opts . replacement char ! = null ) { op builder . set attr ( `` replacement_char `` , opts . replacement char ) ; } if ( opts . replace control character ! = null ) { op builder . set attr ( `` replace_control_characters `` , opts . replace control character ) ; } } } return new unicode transcode ( op builder . build ( ) ) ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public static < t > print < t > create ( scope scope , operand < t > input , iterable < operand < ? > > data , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` print `` , scope . make op name ( `` print `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input list ( operands . a output ( data ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . message ! = null ) { op builder . set attr ( `` message `` , opts . message ) ; } if ( opts . first n ! = null ) { op builder . set attr ( `` first_n `` , opts . first n ) ; } if ( opts . summarize ! = null ) { op builder . set attr ( `` summarize `` , opts . summarize ) ; } } } return new print < t > ( op builder . build ( ) ) ; }
public static save create ( scope scope , operand < string > filename , operand < string > tensor name , iterable < operand < ? > > data ) { operation builder op builder = scope . graph ( ) . op builder ( `` save `` , scope . make op name ( `` save `` ) ) ; op builder . add input ( filename . a output ( ) ) ; op builder . add input ( tensor names . a output ( ) ) ; op builder . add input list ( operands . a output ( data ) ) ; return new save ( op builder . build ( ) ) ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public static < t > qr < t > create ( scope scope , operand < t > input , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` qr `` , scope . make op name ( `` qr `` ) ) ; op builder . add input ( input . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . full matrix ! = null ) { op builder . set attr ( `` full_matrices `` , opts . full matrix ) ; } } } return new qr < t > ( op builder . build ( ) ) ; }
public static < t > add sparse to tensor map create ( scope scope , operand < long > sparse index , operand < t > sparse value , operand < long > sparse shape , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` add sparse to tensor map `` , scope . make op name ( `` add sparse to tensor map `` ) ) ; op builder . add input ( sparse index . a output ( ) ) ; op builder . add input ( sparse value . a output ( ) ) ; op builder . add input ( sparse shape . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new add sparse to tensor map ( op builder . build ( ) ) ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public static < t > tensor array concat < t > create ( scope scope , operand < ? > handle , operand < float > flow in , class < t > dtype , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array concat v3 `` , scope . make op name ( `` tensor array concat `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( flow in . a output ( ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . element shape except0 ! = null ) { op builder . set attr ( `` element_shape_except0 `` , opts . element shape except0 ) ; } } } return new tensor array concat < t > ( op builder . build ( ) ) ; }
public static < t > tensor list concat < t > create ( scope scope , operand < ? > input handle , class < t > element dtype ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor list concat `` , scope . make op name ( `` tensor list concat `` ) ) ; op builder . add input ( input handle . a output ( ) ) ; op builder . set attr ( `` element_dtype `` , data type . from class ( element dtype ) ) ; return new tensor list concat < t > ( op builder . build ( ) ) ; }
public static < t > tensor array concat < t > create ( scope scope , operand < ? > handle , operand < float > flow in , class < t > dtype , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array concat v3 `` , scope . make op name ( `` tensor array concat `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( flow in . a output ( ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . element shape except0 ! = null ) { op builder . set attr ( `` element_shape_except0 `` , opts . element shape except0 ) ; } } } return new tensor array concat < t > ( op builder . build ( ) ) ; }
public static < t > tensor array read < t > create ( scope scope , operand < ? > handle , operand < integer > index , operand < float > flow in , class < t > dtype ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array read v3 `` , scope . make op name ( `` tensor array read `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( index . a output ( ) ) ; op builder . add input ( flow in . a output ( ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; return new tensor array read < t > ( op builder . build ( ) ) ; }
public static < t > tensor array concat < t > create ( scope scope , operand < ? > handle , operand < float > flow in , class < t > dtype , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` tensor array concat v3 `` , scope . make op name ( `` tensor array concat `` ) ) ; op builder . add input ( handle . a output ( ) ) ; op builder . add input ( flow in . a output ( ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . element shape except0 ! = null ) { op builder . set attr ( `` element_shape_except0 `` , opts . element shape except0 ) ; } } } return new tensor array concat < t > ( op builder . build ( ) ) ; }
public output < t > output ( ) { return output ; }
public output < t > output ( ) { return output ; }
public static < t extend number > cholesky grad < t > create ( scope scope , operand < t > l , operand < t > grad ) { operation builder op builder = scope . graph ( ) . op builder ( `` cholesky grad `` , scope . make op name ( `` cholesky grad `` ) ) ; op builder . add input ( l . a output ( ) ) ; op builder . add input ( grad . a output ( ) ) ; return new cholesky grad < t > ( op builder . build ( ) ) ; }
public static < t > print < t > create ( scope scope , operand < t > input , iterable < operand < ? > > data , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` print `` , scope . make op name ( `` print `` ) ) ; op builder . add input ( input . a output ( ) ) ; op builder . add input list ( operands . a output ( data ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . message ! = null ) { op builder . set attr ( `` message `` , opts . message ) ; } if ( opts . first n ! = null ) { op builder . set attr ( `` first_n `` , opts . first n ) ; } if ( opts . summarize ! = null ) { op builder . set attr ( `` summarize `` , opts . summarize ) ; } } } return new print < t > ( op builder . build ( ) ) ; }
public string get output ( ) { return output ; }
public void set idx ( long value ) { this . idx = value ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public static < t > stack < t > create ( scope scope , operand < t > value , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` pack `` , scope . make op name ( `` stack `` ) ) ; op builder . add input ( value . a output ( ) ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . axis ! = null ) { op builder . set attr ( `` axis `` , opts . axis ) ; } } } return new stack < t > ( op builder . build ( ) ) ; }
public static order map unstage no key create ( scope scope , operand < integer > index , list < class < ? > > dtypes , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` order map unstage no key `` , scope . make op name ( `` order map unstage no key `` ) ) ; op builder . add input ( index . a output ( ) ) ; data type [ ] dtypes array = new data type [ dtypes . size ( ) ] ; for ( int i = 0 ; i < dtypes array . length ; ++i ) { dtypes array [ i ] = data type . from class ( dtypes . get ( i ) ) ; } op builder . set attr ( `` dtypes `` , dtypes array ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . capacity ! = null ) { op builder . set attr ( `` capacity `` , opts . capacity ) ; } if ( opts . memory limit ! = null ) { op builder . set attr ( `` memory_limit `` , opts . memory limit ) ; } if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } } } return new order map unstage no key ( op builder . build ( ) ) ; }
public static < t > conditional accumulator create ( scope scope , class < t > dtype , shape shape , option . . . option ) { operation builder op builder = scope . graph ( ) . op builder ( `` conditional accumulator `` , scope . make op name ( `` conditional accumulator `` ) ) ; op builder . set attr ( `` dtype `` , data type . from class ( dtype ) ) ; op builder . set attr ( `` shape `` , shape ) ; if ( option ! = null ) { for ( option opts : option ) { if ( opts . container ! = null ) { op builder . set attr ( `` container `` , opts . container ) ; } if ( opts . share name ! = null ) { op builder . set attr ( `` shared_name `` , opts . share name ) ; } if ( opts . reduction type ! = null ) { op builder . set attr ( `` reduction_type `` , opts . reduction type ) ; } } } return new conditional accumulator ( op builder . build ( ) ) ; }
public static < t > add < t > create ( scope scope , operand < t > x , operand < t > y ) { operation builder op builder = scope . graph ( ) . op builder ( `` add `` , scope . make op name ( `` add `` ) ) ; op builder . add input ( x . a output ( ) ) ; op builder . add input ( y . a output ( ) ) ; return new add < t > ( op builder . build ( ) ) ; }
public void error ( string msg , throwable t ) { logger . log ( fqcn , level . error , msg , t ) ; }
public level get level ( ) { return level ; }
public static string capitalize ( string str ) { int str len ; if ( str == null || ( str len = str . length ( ) ) == 0 ) { return str ; } return new string buffer ( str len ) . append ( character . to title case ( str . char at ( 0 ) ) ) . append ( str . substring ( 1 ) ) . to string ( ) ; }
public field set set field ( field field ) { return set field ( new field description . for loaded field ( field ) ) ; }
public long get d ( ) { return d ; }
public web app parameter get web app ( ) { return web app ; }
public int compare ( object old info , object new info ) { if ( old info == null & & new info == null ) return 0 ; if ( old info == null || new info == null ) return 1 ; return test equality ( old info , new info ) ? 0 : 1 ; }
public void load ( ) throw configuration exception { if ( source u r l ! = null ) { load ( source u r l ) ; } else { load ( get file name ( ) ) ; } }
public list get stop class ( ) { return stop class ; }
public void set be dirty ( boolean value ) { this . be dirty = value ; }
public token create token ( int token type , string text ) { return new common token ( token type , text ) ; }
public final string encode ( byte [ ] byte , int off , int len ) { check position index ( off , off + len , byte . length ) ; string builder result = new string builder ( max encode size ( len ) ) ; try { encode to ( result , byte , off , len ) ; } catch ( i o exception impossible ) { throw new assertion error ( impossible ) ; } return result . to string ( ) ; }
public void set count ( int count ) { this . count = count ; }
public static class get class ( class loader class loader , string class name ) throw class not find exception { return get class ( class loader , class name , true ) ; }
public int get buffer limit ( ) { return buffer limit byte ; }
public static boolean be whitespace ( int c ) { return c == ' ' || c == '\t ' || c == '\n ' || c == '\f ' || c == '\r ' ; }
public boolean add token ( token < ? extend token identifier > token ) { return ( token ! = null ) ? add token ( token . get service ( ) , token ) : false ; }
public string get exception class name ( ) { return exception class name ; }
public void set token stream ( token stream input ) { this . input = null ; reset ( ) ; this . input = input ; }
public int get offset ( ) { return offset ; }
public scriptable get prototype ( ) { return prototype object ; }
public void write ( data output out ) throw i o exception { out . write ( code ) ; }
public codec registry register ( type codec < ? > new codec ) { for ( type codec < ? > old codec : built_in_codecs ) { if ( old codec . accepts ( new codec . get cql type ( ) ) & & old codec . accepts ( new codec . get java type ( ) ) ) { logger . warn ( `` ignore codec { } because it collide with previously register codec { } `` , new codec , old codec ) ; return this ; } } for ( type codec < ? > old codec : codecs ) { if ( old codec . accepts ( new codec . get cql type ( ) ) & & old codec . accepts ( new codec . get java type ( ) ) ) { logger . warn ( `` ignore codec { } because it collide with previously register codec { } `` , new codec , old codec ) ; return this ; } } cache key key = new cache key ( new codec . get cql type ( ) , new codec . get java type ( ) ) ; type codec < ? > exist = cache . get if present ( key ) ; if ( exist ! = null ) { logger . warn ( `` ignore codec { } because it collide with previously generate codec { } `` , new codec , exist ) ; return this ; } this . codecs . add ( new codec ) ; return this ; }
public int get position ( ) { return position ; }
public void set level ( int level ) { this . level = level ; }
public final byte [ ] a unquoted u t f8 ( ) { byte [ ] result = _unquoted u t f8 ref ; if ( result == null ) { _unquoted u t f8 ref = result = json_encoder . encode a u t f8 ( _value ) ; } return result ; }
public void set store term vector payload ( boolean value ) { check if frozen ( ) ; this . store term vector payload = value ; }
public void set store term vector position ( boolean value ) { check if frozen ( ) ; this . store term vector position = value ; }
public int get numeric value ( ) { return numeric value ; }
protect void visit term ( term enum te , int term num ) throw i o exception { }
public int num term ( ) { return num term in field ; }
public string get attribute ( string key ) { return get table value ( attribute , key ) ; }
public boolean have result ( ) { return have result ; }
public void set payload ( boolean request payload ) { this . request payload = request payload ; }
public double get l1 norm ( ) { double norm = 0 ; iterator < entry > it = iterator ( ) ; while ( it . have next ( ) ) { final entry e = it . next ( ) ; norm += fast math . ab ( e . get value ( ) ) ; } return norm ; }
public int get position ( ) { return this . position ; }
public static void main ( string . . . args ) { new profiler ( ) . run ( args ) ; }
public final byte ref term ( ) { return term ; }
public int get numeric value ( ) { return numeric value ; }
public void set in stream ( in stream stream ) { this . stream = stream ; }
public analyzer get analyzer ( ) { return analyzer ; }
public double get max merge segment m b ( ) { return max merge segment bytes/1024/1024 . ; }
/ * * package private constructor , call only from static open ( ) method * / standard directory reader ( directory directory , leaf reader [ ] reader , index writer writer , segment info si , comparator < leaf reader > leaf sorter , boolean apply all deletes , boolean write all deletes ) throw i o exception { super ( directory , reader , leaf sorter ) ; this . writer = writer ; this . segment info = si ; this . apply all deletes = apply all deletes ; this . write all deletes = write all deletes ; }
public long size in byte ( ) { return cache . size in byte ( ) ; }
public long get next doc value gen ( ) { return next write doc value gen ; }
public void set file ( file file ) { this . file = file ; }
public void add all ( change [ ] change ) { for ( change change : change ) { add ( change ) ; } }
public long get field info gen ( ) { return field info gen ; }
public final byte ref term ( ) { return term ; }
public void set min merge m b ( double mb ) { min merge size = ( long ) ( mb * 1024 * 1024 ) ; }
public void increment weight ( double weight ) { this . weight += weight ; }
public int get bytes per sum ( ) { return bytes per checksum ; }
public final boolean be cacheable ( ) { return cacheable ; }
public query get query ( ) { return query ; }
public int size ( ) { return size ; }
public final void add term ( string term text , int freq ) { if ( ! be document open ( ) ) throw new illegal state exception ( `` can not add term when document be not open `` ) ; if ( ! be field open ( ) ) throw new illegal state exception ( `` can not add term when field be not open `` ) ; add term internal ( term text , freq ) ; }
public static int next high power of two ( int v ) { v -- ; v |= v > > 1 ; v |= v > > 2 ; v |= v > > 4 ; v |= v > > 8 ; v |= v > > 16 ; v++ ; return v ; }
public static < b > builder < b > builder ( ) { return new builder < b > ( ) ; }
public boolean be check normalization ( ) { return check normalization ; }
public double get z ( ) { return z ; }
public void set low case term ( boolean low case term ) { this . low case term = low case term ; }
protect void visit term ( term enum te , int term num ) throw i o exception { }
public void set variable time ( long time ) { }
public group search set include max score ( boolean include max score ) { this . include max score = include max score ; return this ; }
public string get file name ( ) { return file name ; }
public final void write raw byte ( final byte [ ] value ) throw i o exception { write ( value , 0 , value . length ) ; }
public int byte size ( ) { return byte size ; }
public long size in byte ( ) { return cache . size in byte ( ) ; }
public static boolean same language ( automaton a1 , automaton a2 ) { if ( a1 == a2 ) { return true ; } return subset of ( a2 , a1 ) & & subset of ( a1 , a2 ) ; }
public static string get common prefix ( automaton a ) { if ( a . be singleton ( ) ) return a . singleton ; string builder b = new string builder ( ) ; hash set < state > visit = new hash set < state > ( ) ; state s = a . initial ; boolean do ; do { do = true ; visit . add ( s ) ; if ( ! s . accept & & s . num transition ( ) == 1 ) { transition t = s . get transition ( ) . iterator ( ) . next ( ) ; if ( t . min == t . max & & ! visit . contains ( t . to ) ) { b . append code point ( t . min ) ; s = t . to ; do = false ; } } } while ( ! do ) ; return b . to string ( ) ; }
public void set state ( final object state ) { this . state = state ; }
public static boolean be total ( automaton a ) { if ( a . be singleton ( ) ) return false ; if ( a . initial . accept & & a . initial . num transition ( ) == 1 ) { transition t = a . initial . get transition ( ) . iterator ( ) . next ( ) ; return t . to == a . initial & & t . min == character . min_code_point & & t . max == character . max_code_point ; } return false ; }
public string get ref ( ) { return ref ; }
public int get id ( ) { return id ; }
public static void put u int ( byte [ ] data , int offset , long value ) { int i = offset ; data [ i++ ] = ( byte ) ( ( value > > > 0 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 8 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 16 ) & 0x f f ) ; data [ i++ ] = ( byte ) ( ( value > > > 24 ) & 0x f f ) ; }
static public void reset ( ) { logger factory . reset ( ) ; }
public string get ref ( ) { return ref ; }
public byte [ ] get byte ( ) { return byte ; }
public final e first ( ) { final int bit = this . bit ; if ( bit == 0 ) throw new no such element exception ( ) ; return item of ( number of trail zero ( low one bit ( bit ) ) ) ; }
public string to turtle ( ) { string val = this . value ; val = val . replace ( `` \ `` `` , `` \\\ `` `` ) ; val = `` \ `` `` +val+ `` \ `` `` ; if ( data type == null ) { if ( language ! = null ) { val = val+ `` @ `` +language ; } } else { val = val+ `` ^^ < `` + data type . get xml schema u r i string ( ) + `` > `` ; } return val ; }
public void set idx ( long value ) { this . idx = value ; }
public long long value ( ) { return value ; }
public string get encode ( ) { return encode ; }
public long get high ( ) { return high ; }
public analyzer get analyzer ( ) { return analyzer ; }
public boolean be enable ( ) { return this . enable ; }
public static string [ ] node string array value ( object node ) { if ( be array ( node ) ) { list list = ( list ) node ; string [ ] arr = new string [ list . size ( ) ] ; for ( int i = 0 ; i < arr . length ; i++ ) { arr [ i ] = node string value ( list . get ( i ) , null ) ; } return arr ; } else { return string . split string by comma to array ( node . to string ( ) ) ; } }
public void parent ( string name , string parent name ) { element type child = get element type ( name ) ; element type parent = get element type ( parent name ) ; if ( child == null ) { throw new error ( `` no child `` + name + `` for parent `` + parent name ) ; } if ( parent == null ) { throw new error ( `` no parent `` + parent name + `` for child `` + name ) ; } child . set parent ( parent ) ; }
public void set merge enable ( boolean merge enable ) { this . merge enable = merge enable ; }
public store field context store field ( ) { return store field context ; }
public static query new range query ( string field , float low value , float upper value ) { return new range query ( field , new float [ ] { low value } , new float [ ] { upper value } ) ; }
public static boolean match ( int actual dimension value , char require dimension symbol ) { if ( require dimension symbol == dimension . sym_dontcare ) { return true ; } if ( require dimension symbol == dimension . sym_true & & ( actual dimension value > = 0 || actual dimension value == dimension . true ) ) { return true ; } if ( require dimension symbol == dimension . sym_false & & actual dimension value == dimension . false ) { return true ; } if ( require dimension symbol == dimension . sym_p & & actual dimension value == dimension . p ) { return true ; } if ( require dimension symbol == dimension . sym_l & & actual dimension value == dimension . l ) { return true ; } if ( require dimension symbol == dimension . sym_a & & actual dimension value == dimension . a ) { return true ; } return false ; }
public final query get query ( ) { return query ; }
public x m l reader get x m l reader ( ) throw s a x exception { if ( reader == null ) { reader = get parser ( ) . get x m l reader ( ) ; } reader . set d t d handler ( this ) ; reader . set content handler ( this ) ; if ( entity resolver == null ) { reader . set entity resolver ( this ) ; } else { reader . set entity resolver ( entity resolver ) ; } reader . set error handler ( this ) ; return reader ; }
public string get illegal value a string ( ) { string value = i string value ; if ( value == null ) { value = string . value of ( i number value ) ; } return value ; }
public token stream normalize ( token stream input ) { return input ; }
public static string encode lat lon ( double latitude , double longitude ) { return encode lat lon ( latitude , longitude , 12 ) ; }
public static query new slow polygon query ( string field , x y polygon . . . polygon ) { return new slow geometry query ( field , polygon ) ; }
public static query new polygon query ( string field , polygon . . . polygon ) { return new geometry query ( field , shape field . query relation . intersects , polygon ) ; }
public static query new distance query ( string field , query relation query relation , x y circle . . . circle ) { return new geometry query ( field , query relation , circle ) ; }
public static query new line query ( string field , query relation query relation , x y line . . . line ) { return new geometry query ( field , query relation , line ) ; }
public static double magnitude ( final double x , final double y , final double z ) { return math . sqrt ( x * x + y * y + z * z ) ; }
public void set bound box ( bound box b box ) { bound box = b box ; }
public static double function constant ( final double c ) { return new double function ( ) { @ override public double apply ( double a ) { return c ; } } ; }
public string get checksum policy ( ) { return checksum policy ; }
public void set auto update ( string auto update ) { this . auto update = auto update ; } // -- void set auto update ( string )
public double get min ( int dimension ) { future object . check index ( dimension , type . point dimension count ( ) /2 ) ; return decode min ( ( ( bytes ref ) field data ) . byte , dimension ) ; }
public version get version ( ) { return version ; }
public static force merge request force merge request ( string . . . index ) { return new force merge request ( index ) ; }
public int get num doc ( ) { return num doc ; }
public version get min version ( ) { return min version ; }
public listenable future < commit log position > switch memtable ( ) { synchronize ( data ) { log flush ( ) ; flush flush = new flush ( false ) ; flush executor . execute ( flush ) ; post flush executor . execute ( flush . post flush task ) ; return flush . post flush task ; } }
public string get sub type ( ) { return sub type ; }
public long get field info gen ( ) { return field info gen ; }
public version get min version ( ) { return min version ; }
public void set calibrate size by deletes ( boolean calibrate size by deletes ) { this . calibrate size by deletes = calibrate size by deletes ; }
public list < string > get delete ( ) { return delete ; }
public void set cache ( boolean cache ) { this . cache = cache ; }
public sort field get sort field ( boolean reverse ) { return new value source sort field ( reverse ) ; }
public static double value source from int field ( string field ) { return from long field ( field ) ; }
public static double value source from double field ( string field ) { return from field ( field , double : : long bit to double ) ; }
public void detail ( boolean detail ) { this . detailed = detail ; }
public long long value ( ) { return value ; }
public void clear ( ) { size = 0 ; }
public void add child ( unknown element child ) { if ( child == null ) { child = new array list ( ) ; } child . add ( child ) ; }
public example set property selector ( property selector selector ) { this . selector = selector ; return this ; }
public void write byte ( final byte octet ) { if ( remain ( ) < 1 ) { if ( index == block . size ( ) - 1 ) { allocate new block ( ) ; } index++ ; current = block . get ( index ) ; } final block block = current ; block . data [ block . limit ] = octet ; block . limit++ ; }
public void set skip empty filesets ( boolean skip ) { skip empty = skip ; }
public static string flatten to string ( collection < ? > c ) { final string builder sb = new string builder ( ) ; for ( object o : c ) { if ( sb . length ( ) ! = 0 ) { sb . append ( `` , `` ) ; } sb . append ( o ) ; } return sb . to string ( ) ; }
public static accountable name accountable ( final string description , final collection < accountable > child , final long byte ) { return new accountable ( ) { @ override public long ram byte use ( ) { return byte ; } @ override public collection < accountable > get child resource ( ) { return child ; } @ override public string to string ( ) { return description ; } } ; }
public static accountable name accountable ( string description , long bytes ) { return name accountable ( description , collection . < accountable > empty list ( ) , bytes ) ; }
public state get state ( ) { return state . get ( ) . get state ( ) ; }
public list < attribute source > get term ( int state ) { int num t = det . init transition ( state , transition ) ; list < attribute source > tokens = new array list < > ( ) ; for ( int i = 0 ; i < num t ; i++ ) { det . get next transition ( transition ) ; token . add all ( array . a list ( this . token ) . sub list ( transition . min , transition . max + 1 ) ) ; } return token ; }
public static boolean equal ( string a1 , char [ ] a2 ) { return equal ( a1 , 0 , a2 ) ; }
public static int append any char ( automaton a , int state ) { int new state = a . create state ( ) ; a . add transition ( state , new state , character . min_code_point , character . max_code_point ) ; return new state ; }
public void set label frequency ( short field_2_label frequency ) { this . field_2_label frequency = field_2_label frequency ; }
public void set boost factor ( float boost factor ) { this . boost factor = boost factor ; }
public void set target ( string target to add ) { if ( target to add . equal ( `` `` ) ) { throw new build exception ( `` target attribute must not be empty `` ) ; } target . add ( target to add ) ; target attribute set = true ; }
public int get ( final int index , final byte [ ] a ) { return get ( index , a , 0 , a . length ) ; }
public void add epsilon ( int source , int dest ) { transition t = new transition ( ) ; int count = init transition ( d , t ) ; for ( int i=0 ; i < count ; i++ ) { get next transition ( t ) ; add transition ( source , t . d , t . min , t . max ) ; } if ( be accept ( d ) ) { set accept ( source , true ) ; } }
public long get length ( ) { return length ; }
public query get query ( ) { return query ; }
public final byte ref term ( ) { return term ; }
public output < long > cardinality ( ) { return cardinality ; }
public void set cache ( boolean cache ) { this . cache = cache ; }
public void set max score ( float max score ) { this . max score = max score ; }
public void add group ( string group ) { if ( be wild card a c l value ( group ) ) { throw new illegal argument exception ( `` group `` + group + `` can not be add `` ) ; } if ( ! be all allow ( ) ) { list < string > group list = new link list < string > ( ) ; group list . add ( group ) ; group map . cache group add ( group list ) ; group . add ( group ) ; } }
public collector result get collector ( ) { return collector . get collector tree ( ) ; }
public collection < string > get group ( ) { return group ; }
public static < t > collection < search group < t > > merge ( list < collection < search group < t > > > top group , int offset , int top n , sort group sort ) { if ( top group . be empty ( ) ) { return null ; } else { return new group merger < t > ( group sort ) . merge ( top group , offset , top n ) ; } }
protect void set name source start ( int start ) { this . name start= start ; }
public void set highlight secondary language ( boolean highlight ) { if ( this . highlight secondary language ! =highlight ) { highlight secondary language = highlight ; repaint ( ) ; fire property change ( highlight_secondary_languages_property , ! highlight , highlight ) ; } }
public final query get query ( ) { return query ; }
public string minimum should match ( ) { return this . minimum should match ; }
public string get doc ( ) { return doc ; }
public sort field get sort field ( boolean reverse ) { return new double value sort field ( this , reverse ) ; }
public void set interval ( long interval ) { this . interval = interval ; }
public final byte ref term ( ) { return term ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public field set set field ( field field ) { return set field ( new field description . for loaded field ( field ) ) ; }
public void add child ( unknown element child ) { if ( child == null ) { child = new array list ( ) ; } child . add ( child ) ; }
public query get query ( ) { return query ; }
public int get fuzzy prefix length ( ) { return fuzzy prefix length ; }
protect query new prefix query ( string text ) { boolean query . builder bq = new boolean query . builder ( ) ; for ( map . entry < string , float > entry : weight . entry set ( ) ) { final string field name = entry . get key ( ) ; final byte ref term = get analyzer ( ) . normalize ( field name , text ) ; query q = new prefix query ( new term ( field name , term ) ) ; float boost = entry . get value ( ) ; if ( boost ! = 1f ) { q = new boost query ( q , boost ) ; } bq . add ( q , boolean clause . occur . should ) ; } return simplify ( bq . build ( ) ) ; }
protect query new phrase query ( string text , int slop ) { boolean query . builder bq = new boolean query . builder ( ) ; for ( map . entry < string , float > entry : weight . entry set ( ) ) { query q = create phrase query ( entry . get key ( ) , text , slop ) ; if ( q ! = null ) { float boost = entry . get value ( ) ; if ( boost ! = 1f ) { q = new boost query ( q , boost ) ; } bq . add ( q , boolean clause . occur . should ) ; } } return simplify ( bq . build ( ) ) ; }
public boolean skip to ( term target ) throw i o exception { do { if ( ! next ( ) ) return false ; } while ( target . compare to ( term ( ) ) > 0 ) ; return true ; }
public static query new range query ( string field , double [ ] low value , double [ ] upper value ) { point range query . check args ( field , low value , upper value ) ; return new point range query ( field , pack ( low value ) . byte , pack ( upper value ) . byte , low value . length ) { @ override protect string to string ( int dimension , byte [ ] value ) { return double . to string ( decode dimension ( value , 0 ) ) ; } } ; }
public string get doc ( ) { return doc ; }
public void set http only ( boolean http only ) { this . http only = http only ; }
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public geo distance query builder distance ( string distance ) { return distance ( distance , distance unit . default ) ; }
public static sort field new distance sort ( string field , double latitude , double longitude ) { return new lat lon point sort field ( field , latitude , longitude ) ; }
public static sort field new outside distance sort ( final string field , final double latitude , final double longitude , final double max radius meter , final planet model planet model ) { final geo outside distance shape = geo3 d util . from distance ( planet model , latitude , longitude , max radius meter ) ; return new geo3 d point outside sort field ( field , planet model , shape ) ; }
public static double magnitude ( final double x , final double y , final double z ) { return math . sqrt ( x * x + y * y + z * z ) ; }
public static < t extend ring position < t > > set < bound < t > > get non overlap bound ( iterable < bound < t > > bound ) { array list < bound < t > > sort bound = list . new array list ( bound ) ; collection . sort ( sorted bound , new comparator < bound < t > > ( ) { public int compare ( bound < t > o1 , bound < t > o2 ) { return o1 . leave . compare to ( o2 . left ) ; } } ) ; set < bound < t > > non overlap bound = set . new hash set ( ) ; peek iterator < bound < t > > it = iterators . peek iterator ( sorted bound . iterator ( ) ) ; while ( it . have next ( ) ) { bound < t > begin bound = it . next ( ) ; bound < t > end bound = begin bound ; while ( it . have next ( ) & & end bound . right . compare to ( it . peek ( ) . leave ) > = 0 ) end bound = it . next ( ) ; non overlap bound . add ( new bound < > ( begin bound . leave , end bound . right ) ) ; } return non overlap bound ; }
public static int next high power of two ( int v ) { v -- ; v |= v > > 1 ; v |= v > > 2 ; v |= v > > 4 ; v |= v > > 8 ; v |= v > > 16 ; v++ ; return v ; }
public double length ( ) { return math . sqrt ( x * x + y * y + z * z ) ; }
public static double magnitude ( final double x , final double y , final double z ) { return math . sqrt ( x * x + y * y + z * z ) ; }
public static double magnitude ( final double x , final double y , final double z ) { return math . sqrt ( x * x + y * y + z * z ) ; }
public double get x ( ) { return x ; }
public int get min length ( ) { return this . min length ; }
public void set low case name ( boolean b ) { this . low case name = b ; }
public int frequency ( int key ) { return frequency . frequency ( key ) ; }
public word list get word list ( ) { return word list ; }
public static boolean be finite ( automaton a ) { if ( a . get num state ( ) == 0 ) { return true ; } return be finite ( new transition ( ) , a , 0 , new bit set ( a . get num state ( ) ) , new bit set ( a . get num state ( ) ) , 0 ) ; }
public regexp query builder max determinized state ( int value ) { this . max determinized state = value ; return this ; }
public analyzer get analyzer ( ) { return analyzer ; }
public collector result get collector ( ) { return collector . get collector tree ( ) ; }
public int collision count ( ) { int count = 0 ; for ( bucket bucket : _buckets ) { if ( bucket ! = null ) { count += bucket . length ; } } return count ; }
public node get node ( ) { return node ; }
public int num node ( ) { return num node ( root node ) ; }
public int num data node ( ) { return num data node ( root node ) ; }
public string get ( string key ) { synchronize ( this . cache ) { return this . cache . get ( key ) ; } }
protect void reset cache ( ) { contain cache . clear ( ) ; resolve value cache . clear ( ) ; }
public int get index ( ) { return index ; }
public static string to string ( string forest path , string dataset path , string [ ] attr name ) throw i o exception { configuration conf = new configuration ( ) ; decision forest forest = decision forest . load ( conf , new path ( forest path ) ) ; dataset dataset = dataset . load ( conf , new path ( dataset path ) ) ; return to string ( forest , dataset , attr name ) ; }
public string get file path ( ) { return file path ; }
public string get partition ( ) { return partition ; }
public static decision forest load ( configuration conf , path forest path ) throw i o exception { file system fs = forest path . get file system ( conf ) ; path [ ] file ; if ( f . get file status ( forest path ) . be dir ( ) ) { file = d f utils . list output file ( f , forest path ) ; } else { file = new path [ ] { forest path } ; } decision forest forest = null ; for ( path path : file ) { f s data input stream data input = new f s data input stream ( f . open ( path ) ) ; try { if ( forest == null ) { forest = read ( data input ) ; } else { forest . read field ( data input ) ; } } finally { closeables . close ( data input , true ) ; } } return forest ; }
public option group get option group ( option opt ) { return ( option group ) option group . get ( opt . get opt ( ) ) ; }
public void increment weight ( double weight ) { this . weight += weight ; }
public final void set matrix ( matrix matrix ) { c o s array matrix array = null ; if ( matrix ! = null ) { matrix array = matrix . to c o s array ( ) ; } dictionary . set item ( c o s name . matrix , matrix array ) ; }
public option set hidden ( boolean hidden ) { this . hidden = hidden ; return this ; }
public static double sinh ( double x ) { return ( math . exp ( x ) - math . exp ( -x ) ) / 2 . 0 ; }
public line string get line ( ) { return line ; }
public geo distance query builder distance ( string distance ) { return distance ( distance , distance unit . default ) ; }
public json object get metric snapshot ( io . vertx . reactivex . core . metric . measure measure ) { json object ret = delegate . get metric snapshot ( measure . get delegate ( ) ) ; return ret ; }
public path get path ( ) { return path ; }
public static string get cluster name ( ) { return database descriptor . get cluster name ( ) ; }
public option get option ( ) { return option ; }
public big fraction pow ( final int exponent ) { if ( exponent < 0 ) { return new big fraction ( denominator . pow ( -exponent ) , numerator . pow ( -exponent ) ) ; } return new big fraction ( numerator . pow ( exponent ) , denominator . pow ( exponent ) ) ; }
public path filter get path filter ( ) { return path filter ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public mapping get mapping ( ) { return mapping ; }
public vector get target ( ) { return target vector ; }
public double get time ( ) { return time ; }
public geo distance query builder distance ( string distance ) { return distance ( distance , distance unit . default ) ; }
public static vector get initial vector ( vector iterable corpus ) { vector initial vector = new dense vector ( corpus . num col ( ) ) ; initial vector . assign ( 1 . 0 / math . sqrt ( corpus . num col ( ) ) ) ; return initial vector ; }
protect static int hash ( string term1 , string term2 , int probe , int num feature ) { long r = murmur hash . hash64 a ( byte for string ( term1 ) , probe ) ; r = murmur hash . hash64 a ( byte for string ( term2 ) , ( int ) r ) % num feature ; if ( r < 0 ) { r += num feature ; } return ( int ) r ; }
public void set r ( string value ) { this . r = value ; }
public double value ( ) { return value ; }
public big integer get abstract num i d ( big integer num i d ) { x w p f num num = get num ( num i d ) ; if ( num == null ) return null ; if ( num . get c t num ( ) == null ) return null ; if ( num . get c t num ( ) . get abstract num id ( ) == null ) return null ; return num . get c t num ( ) . get abstract num id ( ) . get val ( ) ; }
public string to string ( ) { if ( i to string == null ) { string buffer buf = new string buffer ( 4 ) ; if ( be negate ( ) ) { buf . append ( '^ ' ) ; } buf . append ( start ) ; if ( start ! = end ) { buf . append ( '- ' ) ; buf . append ( end ) ; } i to string = buf . to string ( ) ; } return i to string ; }
public static double function mod ( final double b ) { return new double function ( ) { @ override public double apply ( double a ) { return a % b ; } } ; }
public static double function plus ( final double b ) { return new double function ( ) { @ override public double apply ( double a ) { return a + b ; } } ; }
public static double function mod ( final double b ) { return new double function ( ) { @ override public double apply ( double a ) { return a % b ; } } ; }
public boolean be true ( ) { return value == true ; }
public void for each ( lambda expression comsumer ) { iterator < object > iter = iterator ( ) ; while ( iter . have next ( ) ) { comsumer . invoke ( iter . next ( ) ) ; } }
public void tick ( ) { final long count = uncounted . sum then reset ( ) ; final double instant rate = count / interval ; if ( initialize ) { rate += ( alpha * ( instant rate - rate ) ) ; } else { rate = instant rate ; initialize = true ; } }
public double get x ( ) { return x ; }
public image diff with diff size trigger ( final int diff size trigger ) { this . diff markup policy . set diff size trigger ( diff size trigger ) ; return this ; }
public static double gamma ( double alpha , double beta , double x ) { if ( x < 0 . 0 ) { return 0 . 0 ; } return gamma . incomplete gamma ( alpha , beta * x ) ; }
public static double beta ( double alpha , double beta ) { double y ; if ( alpha < 40 & & beta < 40 ) { y = gamma ( alpha + beta ) ; if ( y == 0 . 0 ) { return 1 . 0 ; } if ( alpha > beta ) { y = gamma ( alpha ) / y ; y * = gamma ( beta ) ; } else { y = gamma ( beta ) / y ; y * = gamma ( alpha ) ; } } else { y = math . exp ( log gamma ( alpha ) + log gamma ( beta ) - log gamma ( alpha + beta ) ) ; } return y ; }
public double get a double ( ) { if ( element . size ( ) == 1 ) { return element . get ( 0 ) . get a double ( ) ; } throw new illegal state exception ( ) ; }
public str builder delete char at ( int index ) { if ( index < 0 || index > = size ) { throw new string index out of bound exception ( index ) ; } delete impl ( index , index + 1 , 1 ) ; return this ; }
public final void sort ( ) { sort from to ( 0 , size ( ) - 1 ) ; }
public void set sort ( string value ) { this . sort = value ; }
public list < byte > get byte list ( string key ) { return get byte list ( key , new array list < byte > ( ) ) ; }
public list < byte > get byte list ( string key ) { return get byte list ( key , new array list < byte > ( ) ) ; }
public list < v > value ( ) { array list < v > list = new array list < v > ( ) ; for ( long k : key set ( ) ) { v value = find ( k ) . value ; if ( value ! = null ) { list . add ( value ) ; } } return list ; }
public static final void clamp ( byte [ ] k ) { k [ 31 ] & = 0x7 f ; k [ 31 ] |= 0x40 ; k [ 0 ] & = 0x f8 ; }
public string a string ( ) { return a string ( format . full , null ) ; }
public vector view row ( int row ) { if ( row < 0 || row > = row size ( ) ) { throw new index exception ( row , row size ( ) ) ; } return new permuted vector view ( base . view row ( row pivot [ row ] ) , column pivot , column unpivot ) ; }
public void row process ( string [ ] row , t context ) { row . add ( row ) ; }
public vector get target ( ) { return target vector ; }
public static void merge sort ( final boolean a [ ] , boolean comparator comp ) { merge sort ( a , 0 , a . length , comp ) ; }
public enumeration < header > get all header ( ) throw message exception { check expunge ( ) ; load header ( ) ; return super . get all header ( ) ; }
public map get extension item ( ) { if ( extension item == null ) extension item = new hash map ( ) ; return extension item ; }
protect void handle extension fetch item ( map extension item ) throw message exception { if ( item == null ) item = extension item ; else item . put all ( extension item ) ; }
public input stream get input stream ( ) { return stream ; }
public void add header ( header header ) { header . add ( header ) ; }
public void set flag ( byte flag ) { this . flag = flag ; }
public void set body ( expression body ) { super . set body ( body ) ; use = body ; }
public activation file get file ( ) { return this . file ; } // -- activation file get file ( )
public boolean be active ( ) { return this . active ; } // -- boolean be active ( )
public void set exists ( string exists ) { this . exist = exists ; } // -- void set exists ( string )
public string get miss ( ) { return this . miss ; } // -- string get missing ( )
public string get name ( ) { return this . name ; } // -- string get name ( )
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public void set output directory ( string output directory ) { this . output directory = output directory ; } // -- void set output directory ( string )
public string get url ( ) { return this . url ; } // -- string get url ( )
public void set system id ( string system id ) { this . system id = system id ; }
public organization get organization ( ) { return this . organization ; } // -- organization get organization ( )
public void set group id ( int group id ) { this . group id = group id ; }
public string get url ( ) { return this . url ; } // -- string get url ( )
public remote repository get repository ( ) { return repository ; }
public shard rout remove relocation source ( ) { assert primary == false : this ; assert state == shard rout state . initializing : this ; assert assign to node ( ) : this ; assert relocate node id ! = null : this ; return new shard routing ( shard id , current node id , null , primary , state , recovery source , unassigned info , allocation id . finish relocation ( allocation id ) , expect shard size ) ; }
public string get comment ( ) { return comment ; }
public string get url ( ) { return this . url ; } // -- string get url ( )
public void end unsubscribe ( i async result async result ) throw exception { this . get service ( ) . end unsubscribe ( async result ) ; }
public build get build ( ) { return this . build ; } // -- build get build ( )
public void set file set ( java . util . list < file set > file set ) { this . file set = file set ; } // -- void set file set ( java . util . list )
public void set file set ( java . util . list < file set > file set ) { this . file set = file set ; } // -- void set file set ( java . util . list )
public inet address get address ( ) { return address ; }
public list < warn message > get warning ( ) { return warning ; }
public void set artifact id ( string artifact id ) { this . artifact id = artifact id ; } // -- void set artifact id ( string )
public resource create relative ( string relative path ) { string path to use = string utils . apply relative path ( this . path , relative path ) ; return new file system resource ( path to use ) ; }
public static object a type ( object object , class type ) throw throwable { if ( object == null ) object = null object . get null object ( ) ; return invoke method n ( object . get class ( ) , object , `` a type `` , new object [ ] { type } ) ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public command line exception get execution exception ( ) { return execution exception ; }
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public < t > plugin create rule builder use default plugin class ( / * @ nullable * / class < t > type ) { this . dflt plugin class = type ; return this ; }
public void set connection ( string connection ) { this . connection = connection ; } // -- void set connection ( string )
public plugin builder with configuration ( final configuration configuration ) { this . configuration = configuration ; return this ; }
public boolean be boolean ( ) { return false ; }
public void set last modified ( final long last modify ) { this . last modify = last modify ; }
public boolean be update ( ) { return be update ; }
public activation file get file ( ) { return this . file ; } // -- activation file get file ( )
public string get exists ( ) { return this . exist ; } // -- string get exists ( )
public void set version ( string version ) { this . version = version ; } // -- void set version ( string )
public output < u > activation ( ) { return activation ; }
public void set snapshot ( snapshot snapshot ) { this . snapshot = snapshot ; } // -- void set snapshot ( snapshot )
public string get id ( ) { return this . id ; } // -- string get id ( )
public void set artifact id ( string artifact id ) { this . artifact id = artifact id ; } // -- void set artifact id ( string )
public void set name ( string name ) { this . name = name ; } // -- void set name ( string )
public void release ( ) { }
public string get miss ( ) { return this . miss ; } // -- string get missing ( )
public string get url ( ) { return this . url ; } // -- string get url ( )
public int get port ( ) { return this . port ; }
public boolean be active by default ( ) { return this . active by default ; } // -- boolean be active by default ( )
public synchronize void set host ( final http host host ) { this . host = host ; }
public string get url ( ) { return this . url ; } // -- string get url ( )
public delegate permission get permission ( ) { return this . permission ; }
public void set local repository ( string local repository ) { this . local repository = local repository ; } // -- void set local repository ( string )
protect void validate profile ( string profile ) { if ( ! string utils . have text ( profile ) ) { throw new illegal argument exception ( `` invalid profile [ `` + profile + `` ] : must contain text `` ) ; } if ( profile . char at ( 0 ) == ' ! ' ) { throw new illegal argument exception ( `` invalid profile [ `` + profile + `` ] : must not begin with ! operator `` ) ; } }
public static interval of hour minute second ( long hour , int minute , int second ) { return of hour minute nanos ( hour , minute , second * nanos_per_second ) ; }
public mutable rate new rate ( string name ) { return new rate ( name , name , false ) ; }
public static table option . speculative retry value percentile ( int percentile ) { if ( percentile < 0 || percentile > 100 ) { throw new illegal argument exception ( `` percentile value for speculative retry should be between 0 and 100 `` ) ; } return new table option . speculative retry value ( `` ' `` + percentile + `` percentile ' `` ) ; }
public void set in stream ( in stream stream ) { this . stream = stream ; }
public boolean be empty ( ) { return name . be empty ( ) ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public short get endnote restart qualifier ( ) { return _props . get rnc edn ( ) ; }
public void set class ( class clazz ) { this . clazz = clazz ; if ( clazz == null ) { return ; } this . class loader = ( class loader == null ) ? clazz . get class loader ( ) : class loader ; this . class name = ( class name == null ) ? clazz . get name ( ) : class name ; }
public access get access ( ) { return this . access ; }
public static string get version ( ) { package pkg = spring version . class . get package ( ) ; return ( pkg ! = null ? pkg . get implementation version ( ) : null ) ; }
public static class get wrapper type ( class primitive type ) { if ( primitive type . be primitive ( ) ) { return primitives_to_wrappers . get ( primitive type ) ; } return primitive type ; }
public static class get class ( class loader class loader , string class name ) throw class not find exception { return get class ( class loader , class name , true ) ; }
public static parameterized type find parameterized type ( class < ? > class to search , class < ? > parameterized interface ) { class current = class to search ; while ( current ! = object . class ) { for ( type current interface : current . get generic interface ( ) ) { if ( current interface instanceof parameterized type & & parameterized interface . be assignable from ( reflection utils . get raw type ( ( ( parameterized type ) current interface ) . get raw type ( ) ) ) ) { return ( parameterized type ) current interface ; } } current = current . get superclass ( ) ; } throw new jsonb exception ( message . get message ( message key . non_parametrized_type , parameterized interface ) ) ; }
public boolean be primitive type ( ) { return false ; }
public field set set field ( field field ) { return set field ( new field description . for loaded field ( field ) ) ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public boolean be empty ( ) { return map . be empty ( ) ; }
public static < e > iterable < e > empty if null ( final iterable < e > iterable ) { return iterable == null ? iterable utils . < e > empty iterable ( ) : iterable ; }
public class < ? > get reactive type ( ) { return this . reactive type ; }
public list < resource > get resource ( ) { return resource ; }
public string get key store type ( ) { return this . key store type ; }
public static void read from file channel with eof exception ( file channel channel , long channel position , byte [ ] d , int d offset , int length ) throw i o exception { int read = read from file channel ( channel , channel position , dest , d offset , length ) ; if ( read < 0 ) { throw new e o f exception ( `` read past eof . pos [ `` + channel position + `` ] length : [ `` + length + `` ] end : [ `` + channel . size ( ) + `` ] `` ) ; } }
public optional < string > get path ( ) { return optional . of nullable ( path ) ; }
public void set proxy ( web proxy proxy ) { this . proxy = proxy ; }
public example set property selector ( property selector selector ) { this . selector = selector ; return this ; }
public void set optional ( boolean optional ) { this . be optional = optional ; }
public boolean match ( i undo context context ) { return context == this ; }
public void set server ( string server ) { this . server = server ; }
public string get host ( ) { return host ; }
public access get access ( ) { return this . access ; }
public t max header size ( int value ) { if ( value < = 0 ) { throw new illegal argument exception ( `` max header size must be strictly positive `` ) ; } this . max header size = value ; return get ( ) ; }
public int get chunk size ( ) { return chunk size ; }
public int get threshold ( ) { return threshold ; }
public void start worker ( int count ) { worker . add and get ( count ) ; }
public void set request header ( header header ) { header [ ] header = get request header group ( ) . get header ( header . get name ( ) ) ; for ( int i = 0 ; i < header . length ; i++ ) { get request header group ( ) . remove header ( header [ i ] ) ; } get request header group ( ) . add header ( header ) ; }
public final byte [ ] buffer ( ) { return buf ; }
public set < injection point > get injection point ( ) throw configuration exception { return injection point . for instance method and field ( type ) ; }
public string generate bean name ( bean definition bean definition ) { return this . reader . get bean name generator ( ) . generate bean name ( bean definition , get registry ( ) ) ; }
public void clear ( ) { synchronize ( cache ) { cache . clear ( ) ; } }
public void clear ( ) { clear ( size ) ; }
public static annotation [ ] get filtering annotation ( final annotation [ ] annotation ) { if ( annotation == null || annotation . length == 0 ) { return filter helper . empty_annotations ; } final list < annotation > filtering annotation = new array list < > ( annotation . length ) ; for ( final annotation annotation : annotation ) { final class < ? extend annotation > annotation type = annotation . annotation type ( ) ; for ( final annotation meta annotation : annotation type . get declared annotation ( ) ) { if ( meta annotation instanceof entity filter ) { filter annotation . add ( annotation ) ; } } } return filter annotation . to array ( new annotation [ filter annotation . size ( ) ] ) ; }
public name get qualifier ( ) { return this . optional qualifier ; }
public void option ( string path , route route ) { add route ( http method . option . name ( ) , route impl . create ( path , route ) ) ; }
public locale get locale ( ) { return locale ; }
public class < ? > get reactive type ( ) { return this . reactive type ; }
public void set rebuild ( boolean rebuild ) { this . always rebuild = rebuild ; }
protect void post process builder ( application context builder builder ) { }
public class < ? extend application context builder > [ ] context builder ( ) { return context builder ; }
protect set < configurable application context > find application context ( ) { synchronize ( application context ) { return new link hash set < configurable application context > ( application context ) ; } }
public final string get template ( ) { return template ; }
protect final void register extractor ( class < ? extend throwable > throwable type , throwable cause extractor extractor ) { assert . not null ( extractor , `` invalid extractor : null `` ) ; this . extractor map . put ( throwable type , extractor ) ; }
public int size ( ) { return size ; }
public line string get line ( ) { return line ; }
public void remove ( ) { throw new unsupported operation exception ( ) ; }
public void set ( object instance ) { this . declared class = instance . get class ( ) ; this . instance = instance ; }
public boolean be valid ( string value ) { return be valid ( value , ( string ) null , ( locale ) null ) ; }
public long get timestamp ( ) { return timestamp ; }
public long get last used ( ) { return last used millis ; }
public long get timestamp ( ) { return timestamp ; }
public collection < statement > get statement ( ) { return statement ; }
public class loader get class loader ( ) { return class loader ; }
public static void set default class loader ( class loader loader ) { if ( loader ! = null ) default class loader = loader ; }
public int get offset ( ) { return offset ; }
public object get result ( ) { return result ; }
public string get mode ( ) { return mode ; }
public void set auto map unknown column behavior ( auto map unknown column behavior auto map unknown column behavior ) { this . auto map unknown column behavior = auto map unknown column behavior ; }
public auto map unknown column behavior get auto map unknown column behavior ( ) { return auto map unknown column behavior ; }
public void set interceptor ( object [ ] interceptor ) { this . interceptor = interceptor ; }
public void init ( filter config config ) throw servlet exception { this . config = config ; this . init ( ) ; }
public string get identifier ( ) { return identifier ; }
protect http2 frame logger frame logger ( ) { return frame logger ; }
public synchronize int size ( ) { int sz = get resource collection ( ) . size ( ) ; int ct = get valid count ( ) ; return sz < ct ? sz : ct ; }
public node get node ( ) { return node ; }
public t get result ( ) { return result ; }
public int get size ( ) { return size ; }
public static void identity to string ( string buffer buffer , object object ) { if ( object == null ) { throw new null pointer exception ( `` can not get the to string of a null identity `` ) ; } buffer . append ( object . get class ( ) . get name ( ) ) . append ( ' @ ' ) . append ( integer . to hex string ( system . identity hash code ( object ) ) ) ; }
public object get result ( ) { return result ; }
protect void pre write ( ) { if ( _children . size ( ) > 0 ) { property [ ] child = _children . to array ( new property [ 0 ] ) ; array . sort ( child , new property comparator ( ) ) ; int midpoint = child . length / 2 ; set child property ( child [ midpoint ] . get index ( ) ) ; child [ 0 ] . set previous child ( null ) ; child [ 0 ] . set next child ( null ) ; for ( int j = 1 ; j < midpoint ; j++ ) { child [ j ] . set previous child ( child [ j - 1 ] ) ; child [ j ] . set next child ( null ) ; } if ( midpoint ! = 0 ) { child [ midpoint ] . set previous child ( child [ midpoint - 1 ] ) ; } if ( midpoint ! = ( child . length - 1 ) ) { child [ midpoint ] . set next child ( child [ midpoint + 1 ] ) ; for ( int j = midpoint + 1 ; j < child . length - 1 ; j++ ) { child [ j ] . set previous child ( null ) ; child [ j ] . set next child ( child [ j + 1 ] ) ; } child [ child . length - 1 ] . set previous child ( null ) ; child [ child . length - 1 ] . set next child ( null ) ; } else { child [ midpoint ] . set next child ( null ) ; } } }
public set < v > value ( ) { if ( value == null ) { value = new value < > ( this ) ; } return value ; }
public i progress monitor get wrap progress monitor ( ) { return progress monitor ; }
public int get head fingerprint ( ) { return head ; }
public submodule add command set u r i ( string uri ) { this . uri = uri ; return this ; }
public j tree get tree ( ) { return f tree ; }
public static pre push hook pre push ( repository repo , print stream output stream ) { if ( lfs factory . get instance ( ) . be available ( ) ) { pre push hook hook = lf factory . get instance ( ) . get pre push hook ( repo , output stream ) ; if ( hook ! = null ) { if ( hook . be native hook present ( ) ) { print stream p = output stream ; if ( ps == null ) { ps = system . out ; } p . println ( message format . format ( j git text . get ( ) . lfs hook conflict , repo ) ) ; } return hook ; } } return new pre push hook ( repo , output stream ) ; }
public void run ( ) { this . delegate . run ( ) ; }
public void set branch ( string branch ) { m branch = branch ; }
public resource get archive ( ) { return be reference ( ) ? ( ( archive resource ) get check ref ( ) ) . get archive ( ) : archive ; }
public string [ ] get command ( ) { return command ; }
public void set count ( int count ) { this . count = count ; }
public boolean be squash ( ) { return squash ; }
public long get checkout timestamp ( ) { return checkout timestamp ; }
public object get fetch value ( ) { return fetch value ; }
public object get fetch value ( ) { return fetch value ; }
public int get timeout ( ) { return timeout ; }
public set < string > get change ( ) { return collection . unmodifiable set ( diff . get change ( ) ) ; }
public set < string > get change ( ) { return change ; }
public set < string > get untracked folder ( ) { return collection . unmodifiable set ( diff . get untracked folder ( ) ) ; }
public set < string > get untracked ( ) { return collection . unmodifiable set ( diff . get untracked ( ) ) ; }
public clone command set u r i ( string uri ) { this . uri = uri ; return this ; }
public status get status ( ) { return null ; }
public path get path ( ) { return path ; }
public annotate element get annotate element ( ) { return ( this . field ! = null ? this . field : obtain method parameter ( ) . get annotated element ( ) ) ; }
public boolean be empty ( ) { return this . map . be empty ( ) ; }
public string put attribute ( string key , string value ) { if ( attribute == null ) { attribute = new hash map < string , string > ( ) ; } return attribute . put ( key , value ) ; }
public string get state ( ) { return state ; }
public list < string > get custom parameter ( final string name ) { return custom params . get ( name ) ; }
public file get dir ( ) { return this . dir ; }
public void set relative path ( string relative path ) { this . relative path = relative path ; } // -- void set relative path ( string )
public person ident get author ( ) { return author ; }
public static sort property from line ( string s ) { sorted property p = new sort property ( ) ; for ( string line : string utils . array split ( s , '\n ' , true ) ) { int idx = line . index of ( '= ' ) ; if ( idx > 0 ) { p . put ( line . substring ( 0 , idx ) , line . substring ( idx + 1 ) ) ; } } return p ; }
public string get prefix ( ) { return prefix ; }
public string get prefix ( ) { return prefix ; }
public string get prefix ( ) { return prefix ; }
public boolean get rename ( ) { return m rename ; }
public void set filter ( tree filter filter ) { this . filter = filter ; }
public line string get line ( ) { return line ; }
public void end c d a t a ( ) throw s a x exception { }
public void override default editor ( class < ? > require type , property editor property editor ) { if ( this . overridden default editor == null ) { this . overridden default editor = new hash map < class < ? > , property editor > ( ) ; } this . overridden default editor . put ( require type , property editor ) ; }
public long get change timestamp ( ) { synchronize ( lock ) { return change time ; } }
public j tree get tree ( ) { return f tree ; }
public int get ( int i ) { if ( count < = i ) throw new array index out of bound exception ( i ) ; return entry [ i ] ; }
public project get project ( ) { return project ; }
public string get path ( ) { return path ; }
public string get hook name ( ) { return hook name ; }
public string get miss ( ) { return this . miss ; } // -- string get missing ( )
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
public void set system ( string system ) { this . system = system ; } // -- void set system ( string )
public void close ( ) { if ( replica ! = null ) { if ( anchor ) { replica . remove no checksum anchor ( ) ; } replica . unref ( ) ; } replica = null ; }
public schedule executor service get schedule executor ( ) throw illegal state exception { assert . state ( this . schedule executor ! = null , `` thread pool task scheduler not initialize `` ) ; return this . schedule executor ; }
public string get message ( ) { return message ; }
public state get state ( ) { return state . get ( ) . get state ( ) ; }
public string get ref ( ) { return ref ; }
public throwable get exception ( ) { return exception ; }
public long get block cache hit ( ) { return stats . block cache hit ; }
public void init ( filter config config ) throw servlet exception { this . config = config ; this . init ( ) ; }
public dfs garbage collector set pack config ( pack config new config ) { pack config = new config ; return this ; }
protect void commit pack ( collection < dfs pack description > desc , collection < dfs pack description > replaces ) throw i o exception { commit pack impl ( desc , replaces ) ; get repository ( ) . fire event ( new dfs pack change event ( ) ) ; }
public set < dfs pack description > get source pack ( ) { return to prune ( ) ; }
public void clear ( ) { synchronize ( cache ) { cache . clear ( ) ; } }
public long get plan cache hit count ( ) { return plan cache hit count . sum ( ) ; }
public option get option ( ) { return option ; }
public list < e > a list ( ) { return unmodifiable list . unmodifiable list ( set order ) ; }
public void set expire ( date expire ) { this . expire = expire ; expire age millis = -1 ; }
public void set expire age millis ( long expire age millis ) { this . expire age millis = expire age millis ; expire = null ; }
public void set remove pack file ( final boolean remove pack file ) { this . remove pack file = remove pack file ; }
public object id insert ( int type , byte [ ] data ) throw i o exception { return insert ( type , data , 0 , data . length ) ; }
public string get ref ( ) { return ref ; }
public byte [ ] get byte ( ) { return byte ; }
public string value ( ) { return value ; }
public byte [ ] buffer ( ) { return this . buffer ; }
public void set ( object object , object value ) throw exception { }
public ref first exact ref ( string . . . ref ) throw i o exception { for ( string name : ref ) { ref ref = exact ref ( name ) ; if ( ref ! = null ) { return ref ; } } return null ; }
public boolean be in range ( final level min level , final level max level ) { return this . int level > = min level . int level & & this . int level < = max level . int level ; }
public string [ ] index ( ) { return index ; }
public long get pending num doc ( ) { return pending num doc . get ( ) ; }
public void set id ( string id ) { this . id = id ; }
public void set alternate link ( final list < link > alternate link ) { this . alternate link = alternate link ; }
public string get mode ( ) { return mode ; }
public person ident get source author ( ) { return out candidate . get author ( ) ; }
public void set path filter ( tree filter filter ) { path filter = filter ! = null ? filter : tree filter . all ; }
public change get change ( ) { return f change ; }
public void remove ( int index ) { entry . remove ( index ) ; }
public set < string > get untracked folder ( ) { return collection . unmodifiable set ( diff . get untracked folder ( ) ) ; }
public final string id ( ) { return id ; }
public byte [ ] buffer ( ) { return this . buffer ; }
public int size ( ) { return size ; }
public static builder build ( ) { return new builder ( ) ; }
public object id get data ( ) { return data ; }
public boolean be atomic type ( ) { return false ; }
public string get ref ( ) { return ref ; }
public void add message destination ref ( message destination ref mdr ) { get naming resource ( ) . add message destination ref ( mdr ) ; }
public double get push end ( ) { return push end ; }
public void set worker ( worker worker ) { this . worker = worker ; }
public merge command set squash ( boolean squash ) { check callable ( ) ; this . squash = boolean . value of ( squash ) ; return this ; }
public long get commit time ( ) { return commit time ; }
public void set modify property ( string modify ) { try { this . modified = set date value ( modify ) ; } catch ( invalid format exception e ) { throw new illegal argument exception ( `` modify : `` + e . get localized message ( ) , e ) ; } }
public void set context ( object data ) { this . data = data ; }
public string get id ( ) { return id ; }
public int length ( ) { return get size ( ) ; }
public int get d s e patch ( ) { return dse patch ; }
public static final string get last error ( ) { string error = last error . get ( ) ; return error ! = null ? error : `` unknown `` ; }
public void put rec ptr ( final long offset , final long value ) { make dirty ( ) ; int idx = rec ptr to index ( offset ) ; database . put rec ptr ( value , this . f buffer , idx ) ; record write ( offset , 4 ) ; }
public synchronize void add child ( runtime configurable child ) { child = ( child == null ) ? new array list ( ) : child ; child . add ( child ) ; }
public rev commit get new head ( ) { return new head ; }
public string [ ] get pattern ( ) { return pattern ; }
public date get not before time ( ) { return nbf ; }
public void set skip empty filesets ( boolean skip ) { skip empty = skip ; }
public boolean get rename ( ) { return m rename ; }
public node get parent ( ) { return parent ; }
public static reference token from raw ( final string raw ) { bundle . check not null ( raw , `` null input `` ) ; return new reference token ( a cook ( raw ) , raw ) ; }
public person ident get author ( ) { return author ; }
public boolean have flag ( property definition flag flag ) { return this . have flag ( flag , null ) ; }
public string get name ( ) { return tag name ; }
public void set limit ( long limit ) { this . limit = limit ; }
public final i resource delta get delta ( i project project ) { return super . get delta ( project ) ; }
public span detach ( ) { detached = true ; span cur = tracer . get instance ( ) . current span ( ) ; if ( cur ! = span ) { tracer . log . debug ( `` closing trace span `` + span + `` but `` + cur + `` be top-of-stack `` ) ; } else { tracer . get instance ( ) . set current span ( save span ) ; } return span ; }
public void set total count ( int total count ) { this . total count = total count ; }
public double get time ( ) { return time ; }
public string get provider ( ) { return provider ; }
public inet address get address ( ) { return address ; }
public int get timeout ( ) { return timeout ; }
public void set entry ( final list < entry > entry ) { this . entry = entry ; }
protect void update track ref ( rev walk walk ) throw i o exception { if ( be delete ( ) ) track ref update . set result ( local update . delete ( walk ) ) ; else track ref update . set result ( local update . update ( walk ) ) ; }
public static boolean be whitespace ( int c ) { return c == ' ' || c == '\t ' || c == '\n ' || c == '\f ' || c == '\r ' ; }
public void set type ( int type ) { this . type = type ; }
public void set email ( final string email ) { this . email = email ; }
public void add ( resource collection rc ) { get buildpath ( ) . add ( rc ) ; }
public u r iish set host ( string n ) { final u r iish r = new u r iish ( this ) ; r . host = n ; return r ; }
public u r iish set host ( string n ) { final u r iish r = new u r iish ( this ) ; r . host = n ; return r ; }
public string get message ( ) { return message ; }
public track ref update get track ref update ( string local name ) { return update . get ( local name ) ; }
public pem key cert option add cert path ( string cert path ) { argument . require ( cert path ! = null , `` null cert path `` ) ; cert path . add ( cert path ) ; return this ; }
public string get protocol ( ) { return protocol ; }
public void set object checker ( object checker impl ) { object checker = impl ; }
public keyword builder with syntax checker ( final syntax checker syntax checker ) { bundle . check not null printf ( syntax checker , `` null syntax checker `` , name ) ; this . syntax checker = syntax checker ; return this ; }
public ref first exact ref ( string . . . ref ) throw i o exception { for ( string name : ref ) { ref ref = exact ref ( name ) ; if ( ref ! = null ) { return ref ; } } return null ; }
public u r iish set raw path ( string n ) throw u r i syntax exception { final u r iish r = new u r iish ( this ) ; r . path = unescape ( n ) ; r . raw path = n ; return r ; }
public u r iish set host ( string n ) { final u r iish r = new u r iish ( this ) ; r . host = n ; return r ; }
public void set password ( string password ) { this . password = password ; }
public void set id ( string id ) { this . id = id ; }
public string get mode ( ) { return mode ; }
public int get offset ( ) { return offset ; }
public static attribute get attribute for path ( repository db , string path , rev commit commit ) throw i o exception { if ( commit == null ) { return get attribute for path ( db , path ) ; } try ( tree walk walk = tree walk . for path ( db , path , commit . get tree ( ) ) ) { attribute attr = walk == null ? null : walk . get attribute ( ) ; if ( attr == null ) { throw new i o exception ( message format . format ( j git text . get ( ) . no path attribute find , path ) ) ; } return attr ; } }
public string get mode ( ) { return mode ; }
public file get git system config ( ) { if ( git system config == null ) { git system config = new holder < > ( discover git system config ( ) ) ; } return git system config . value ; }
public void set src ( file src ) { set src resource ( new file resource ( src ) ) ; }
public string get public i d ( ) { return public i d ; }
public final throwable get throwable ( ) { return throwable ; }
public void set factory ( j d o m factory factory ) { this . factory = factory ; }
public boolean be dir no git link ( ) { return dir no git link ; }
protected boolean file exists ( file file ) { return file . exists ( ) & & file . be file ( ) ; }
public string get encode ( ) { return encode ; }
public s s l context builder set trust manager factory algorithm ( final string trust manager factory algorithm ) { this . trust manager factory algorithm = trust manager factory algorithm ; return this ; }
public static final int occurences of ( char to be find , char [ ] array ) { int count = 0 ; for ( int i = 0 ; i < array . length ; i++ ) if ( to be find == array [ i ] ) count++ ; return count ; }
public output stream create output stream ( ) throw i o exception { return create output stream ( null ) ; }
public int get timeout ( ) { return timeout ; }
public static boolean copy stream ( input stream in stream , output stream out stream ) { try { byte [ ] buffer = new byte [ 1024 ] ; int bytes read ; while ( ( bytes read = in stream . read ( buffer ) ) > = 0 ) { out stream . write ( buffer , 0 , byte read ) ; } } catch ( exception e ) { return false ; } return true ; }
public path get path ( ) { return path ; }
public long get n ( ) { return n ; }
public boolean be empty ( ) { return size ( ) == 0 ; }
public static int encode length ( byte [ ] b ) { return ( ( b . length + 2 ) /3 ) * 4 ; }
public static boolean be empty ( string str ) { return ( str == null || str . length ( ) == 0 ) ; }
public string get public i d ( ) { return public i d ; }
public static string get organzations regex ( ) { string builder sb = new string builder ( ) ; sb . append ( `` ( `` ) ; int i = 0 ; for ( string org : organization . key set ( ) ) { if ( i > 0 ) { sb . append ( `` | `` ) ; } sb . append ( org ) ; i++ ; } sb . append ( `` ) `` ) ; return sb . to string ( ) ; }
public void write ( byte [ ] b ) throw i o exception { count += b . length ; super . write ( b ) ; }
public input stream get input stream ( ) throw i o exception { return url . open stream ( ) ; }
public string type ( ) { return type ; }
public int get size ( ) { return num of item ; }
public character get quote character ( ) { return quote character ; }
public file get file ( ) { return file ; }
public boolean be ternary ( ) { return true ; }
public final string buffer dump tree recursively ( ) { final string writer out = new string writer ( ) ; dump tree recursively ( new print writer ( out , true ) , new string builder ( ) , snapshot . current_state_id ) ; return out . get buffer ( ) ; }
public static void read word ( final input stream in , final string charset , final list < string > word ) throw i o exception { read word ( new input stream reader ( in , charset ) , word ) ; }
public word list get word list ( ) { return word list ; }
public final void set rule ( int rule ) { this . rule = rule ; }
public int get max length ( ) { return max length ; }
public static string trim trailing character ( string str , char trail character ) { if ( ! have length ( str ) ) { return str ; } string builder sb = new string builder ( str ) ; while ( sb . length ( ) > 0 & & sb . char at ( sb . length ( ) - 1 ) == trail character ) { sb . delete char at ( sb . length ( ) - 1 ) ; } return sb . to string ( ) ; }
public dependency resolver get resolver ( ) { return resolver ; }
protect string list get category ( ) { return this . category ; }
public example ignore case ( ) { this . be ignore case enable = true ; return this ; }
public boolean contains number ( number number ) { if ( number == null ) { return false ; } return contains integer ( number . int value ( ) ) ; }
public x m p schema p d f get p d f schema ( ) throw i o exception { return ( x m p schema p d f ) get schema by class ( x m p schema p d f . class ) ; }
public void set acro form merge mode ( document merge mode the document merge mode ) { this . document merge mode = the document merge mode ; }
public document merge mode get document merge mode ( ) { return document merge mode ; }
public void set numeric type ( numeric type type ) { check if frozen ( ) ; numeric type = type ; }
public s o a p element add child element ( name child name ) throw s o a p exception { message element child = new message element ( child name . get local name ( ) , child name . get prefix ( ) , child name . get u r i ( ) ) ; add child ( child ) ; return child ; }
public static long to vertex id ( long id ) { precondition . check argument ( id > 0 , `` vertex id must be positive : % s `` , id ) ; precondition . check argument ( i d manager . vertex i d type . normal vertex . remove padding ( long . max_value ) > = id , `` vertex id be too large : % s `` , id ) ; return i d manager . vertex i d type . normal vertex . add pad ( id ) ; }
public font box font get font box font ( ) { if ( cid font ! = null ) { return cid font ; } else { return t1 font ; } }
public c o s name get crypt filter method ( ) { return ( c o s name ) crypt filter dictionary . get dictionary object ( c o s name . cfm ) ; }
public geometry sym difference ( geometry other ) { return geometry overlay . sym difference ( this , other ) ; }
public void set variable q name ( structure q name name ) { variable q name = name ; }
public void set image ( final image image ) { this . image = image ; }
public byte [ ] decode ( ) { return base64 codec . decode ( value ) ; }
public string get include ( ) { return include ; }
public final throwable get throwable ( ) { return throwable ; }
public static string remove path ( final string filepath , final char file separator char ) { final int index = filepath . last index of ( file separator char ) ; if ( -1 == index ) { return filepath ; } return filepath . substring ( index + 1 ) ; }
public static string remove path ( final string filepath ) { return remove path ( filepath , file . separator char ) ; }
public input stream get input stream ( ) throw i o exception { return new reader input stream ( reader ) ; }
public void set buffer debug ( boolean debug ) { this . buffer . set debug ( debug ) ; }
public void set parameter ( string parameter ) { assert . have text ( parameter , `` parameter name can not be empty or null `` ) ; this . parameter = parameter ; }
public node get node ( ) { return node ; }
public type any ( type meta type , type identifier type ) { return any ( meta type , identifier type , true ) ; }
public node get node ( ) { return node ; }
public string get display name ( ) { return display name ; }
public string get language ( ) { return language ; }
public string get version ( ) { return version ; }
public void clear ( ) { clear ( size ) ; }
public option get option ( ) { return option ; }
public list < node > get node ( ) { return node ; }
public string get version ( ) { return version ; }
public version get version ( ) { return version ; }
public string get expression ( ) { return expression ; }
public node get node ( ) { return node ; }
public final void set rule ( int rule ) { this . rule = rule ; }
public static class loader get class loader ( ) { return get class loader ( loader . class , null ) ; }
public string get extend stack trace a string ( ) { return this . get extended stack trace a string ( null , plain text renderer . get instance ( ) , string . empty , eol_str ) ; }
public void set report ( object report ) { this . report = report ; } // -- void set report ( object )
public boolean be unknown ( ) { return unknown . be set ( field_4_format ) ; }
public set < v > value ( ) { if ( value == null ) { value = new value < > ( this ) ; } return value ; }
public constraint find constraint ( session session , string name ) { constraint constraint = constraint . get ( name ) ; if ( constraint == null ) { constraint = session . find local temp table constraint ( name ) ; } return constraint ; }
public dynamic double property get double property ( string prop name , double default value , final runnable property change callback ) { check and warn ( prop name ) ; dynamic double property property = new dynamic double property ( prop name , default value ) ; add callback ( property change callback , property ) ; return property ; }
public int get numeric value ( ) { return numeric value ; }
public string get regex ( ) { return regex ; }
public void evaluate ( final node node , final rule context data ) { if ( x path rule query need initialization ( ) ) { init x path rule query ( ) ; } list < node > node with violation = xpath rule query . evaluate ( node , data ) ; for ( node node with violation : node with violation ) { add violation ( data , node with violation , node with violation . get image ( ) ) ; } }
public object get attribute ( string name ) { return this . request . get attribute ( name ) ; }
public boolean use d f a ( language language ) { for ( rule set rule set : rule set ) { if ( rule set . us d f a ( language ) ) { return true ; } } return false ; }
public boolean be enable ( ) { return this . enable ; }
public rule get rule ( ) { return this . rule ; }
public boolean use d f a ( language language ) { for ( rule r : rule ) { if ( r . get language ( ) . equal ( language ) & & r . be dfa ( ) ) { return true ; } } return false ; }
public final void set rule ( int rule ) { this . rule = rule ; }
public final collection < t > to collection ( ) { list < t > list = new array list < t > ( ) ; add to ( list ) ; return list ; }
public input stream get input stream ( ) { return input stream ; }
public static void close quietly ( closeable closeable ) { try { if ( closeable ! = null ) { closeable . close ( ) ; } } catch ( i o exception e ) { logger . error ( `` i o exception should not have be throw . `` , e ) ; } }
public final class get element type ( ) { return this . element type ; }
public int get size ( ) { return num of item ; }
public int size ( ) { return this . get num child ( ) ; }
public boolean be true ( ) { return value == true ; }
public boolean be fix arity method ( ) { return ! be variable arity method ( ) ; }
public collection < statement > get statement ( ) { return statement ; }
public a s t statement get body ( ) { return ( a s t statement ) get child ( 0 ) ; }
public void import class ( string name ) { if ( import class == null ) import class = new hashtable ( ) ; import class . put ( name . suffix ( name , 1 ) , name ) ; name space change ( ) ; }
public void set image ( final image image ) { this . image = image ; }
public weld add decorator ( class < ? > decorator class ) { enabled decorator . add ( synthetic metadata ( decorator class ) ) ; return this ; }
public node get node ( ) { return node ; }
public class loader get class loader ( ) { return class loader ; }
public void set declaration ( body declaration declaration ) { f declaration= declaration ; }
public static string parse text node ( node node ) { final int node count = node . get child node ( ) . get length ( ) ; if ( node count == 0 ) { return `` `` ; } string builder buffer = new string builder ( ) ; for ( int i = 0 ; i < node count ; i++ ) { node child node = node . get child node ( ) . item ( i ) ; if ( child node . get node type ( ) == node . cdata_section_node || child node . get node type ( ) == node . text_node ) { buffer . append ( child node . get node value ( ) ) ; } } return buffer . to string ( ) ; }
public tag tag ( ) { return tag ; }
public node get node ( ) { return node ; }
public int count ( ) { return count ; }
public void set index ( int index ) { this . index = index ; }
protect void validate index ( int index ) { if ( index < 0 || index > size ) { throw new string index out of bound exception ( index ) ; } }
protect void check freed ( ) throw s q l exception { if ( sub l o == null ) { throw new p s q l exception ( gt . tr ( `` free ( ) be call on this lob previously `` ) , p s q l state . object_not_in_state ) ; } }
public synchronize void truncate ( long len ) throw s q l exception { check freed ( ) ; if ( ! conn . have minimum server version ( server version . v8_3 ) ) { throw new p s q l exception ( gt . tr ( `` truncation of large object be only implement in 8 . 3 and late server . `` ) , p s q l state . not_implemented ) ; } if ( len < 0 ) { throw new p s q l exception ( gt . tr ( `` can not truncate lob to a negative length . `` ) , p s q l state . invalid_parameter_value ) ; } if ( len > integer . max_value ) { if ( support64bit ) { get lo ( true ) . truncate64 ( len ) ; } else { throw new p s q l exception ( gt . tr ( `` postgre s q l l o b can only index to : { 0 } `` , integer . max_value ) , p s q l state . invalid_parameter_value ) ; } } else { get lo ( true ) . truncate ( ( int ) len ) ; } }
public void set location ( resource . . . location ) { this . location = location ; }
public synchronize void set host ( final http host host ) { this . host = host ; }
protect void check freed ( ) throw s q l exception { if ( sub l o == null ) { throw new p s q l exception ( gt . tr ( `` free ( ) be call on this lob previously `` ) , p s q l state . object_not_in_state ) ; } }
public pattern get pattern ( ) { return pattern ; }
public synchronize void truncate ( long len ) throw s q l exception { check freed ( ) ; if ( ! conn . have minimum server version ( server version . v8_3 ) ) { throw new p s q l exception ( gt . tr ( `` truncation of large object be only implement in 8 . 3 and late server . `` ) , p s q l state . not_implemented ) ; } if ( len < 0 ) { throw new p s q l exception ( gt . tr ( `` can not truncate lob to a negative length . `` ) , p s q l state . invalid_parameter_value ) ; } if ( len > integer . max_value ) { if ( support64bit ) { get lo ( true ) . truncate64 ( len ) ; } else { throw new p s q l exception ( gt . tr ( `` postgre s q l l o b can only index to : { 0 } `` , integer . max_value ) , p s q l state . invalid_parameter_value ) ; } } else { get lo ( true ) . truncate ( ( int ) len ) ; } }
public static void sqlchar ( string builder buf , list < ? extend char sequence > parse args ) throw s q l exception { single argument function call ( buf , `` chr ( `` , `` char `` , parse args ) ; }
public static void sqlsubstring ( string builder buf , list < ? extend char sequence > parse args ) throw s q l exception { int arg size = parse args . size ( ) ; if ( arg size ! = 2 & & arg size ! = 3 ) { throw new p s q l exception ( gt . tr ( `` { 0 } function take two or three argument . `` , `` substring `` ) , p s q l state . syntax_error ) ; } append call ( buf , `` substr ( `` , `` , `` , `` ) `` , parse args ) ; }
public static void sqlchar ( string builder buf , list < ? extend char sequence > parse args ) throw s q l exception { single argument function call ( buf , `` chr ( `` , `` char `` , parse args ) ; }
public boolean mark support ( ) { return false ; }
public static preference service get default ( ) { if ( instance == null ) instance = new preference service ( ) ; return instance ; }
public output < v > idx ( ) { return idx ; }
public boolean equal ( object obj ) { if ( obj instanceof string list ) { string list other = ( string list ) obj ; return this . to string ( ) . equal ( other . to string ( ) ) ; } else { return false ; } }
public calendar get a calendar ( ) { return get a calendar ( calendar . get instance ( ) ) ; }
public string to string ( ) { return xid to string ( this ) ; }
public string to string ( ) { return to string ( `` `` ) ; }
public static string null to empty ( @ nullable string string ) { return ( string == null ) ? `` `` : string ; }
public void copy ( ) { set ( current ( ) . copy ( ) ) ; }
public int read off size ( ) throw i o exception { int off size = read unsigned byte ( ) ; if ( off size < 1 || off size > 4 ) { throw new i o exception ( `` illegal ( < 1 or > 4 ) off size value `` + off size + `` in cff font at position `` + ( get position ( ) - 1 ) ) ; } return off size ; }
public string get description ( ) { return description ; }
public final long storagespace consume ( ) { return storagespace consume no replication ( ) * get block replication ( ) ; }
public < t > class < t > resolve ( ) { return class for name ( fully qualify class name ) ; }
public static < a > answer < void > answer void ( void answer1 < a > answer ) { return to answer ( answer ) ; }
public boolean be map constructor parameter name ( ) { return map constructor parameter name ; }
public static synchronize void suppress method ( method . . . method ) { for ( method method : method ) { mock repository . add method to suppress ( method ) ; } }
public method get method ( ) { return method ; }
protected remote invocation create remote invocation ( method invocation method invocation ) { return get remote invocation factory ( ) . create remote invocation ( method invocation ) ; }
public class < ? > get value class ( ) { return object . class ; }
public method get method ( ) { return method ; }
public void record suppress field ( string field ) { this . suppressed field . add ( field ) ; }
public string get method name ( ) { return method name ; }
public field set set field ( field field ) { return set field ( new field description . for loaded field ( field ) ) ; }
public method get method ( ) { return this . method ; }
public proxy . type get proxy type ( ) { return proxy type ; }
public void set parameter type ( class < ? > [ ] parameter type ) { this . parameter type = parameter type ; }
public object get context ( ) { return context ; }
public static void set internal state ( object object , string field name , object value ) { field find field = find field in hierarchy ( object , field name ) ; set field ( object , value , find field ) ; }
public static synchronize < t > t invoke method ( class < ? > clazz , string method to execute , object . . . argument ) throw exception { return whitebox impl . < t > invoke method ( clazz , method to execute , argument ) ; }
public static synchronize < t > t invoke method ( object instance , string method to execute , class < ? > define in , class < ? > [ ] argument type , object . . . argument ) throw exception { return whitebox impl . < t > invoke method ( instance , method to execute , define in , argument type , argument ) ; }
public class < ? > get declare class ( ) { return method . get declare class ( ) ; }
public java . lang . string get description ( ) { java . lang . object ref = description_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; description_ = s ; return s ; } }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public java . util . list < com . google . api . usage rule > get rule list ( ) { return rules_ ; }
public com . google . protobuf . byte string get value ( ) { return value_ ; }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public void set label ( string label ) { this . label = label ; }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public static void disable metric ( ) { set metric collector ( metric collector . none ) ; }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public java . lang . string get description ( ) { java . lang . object ref = description_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; description_ = s ; return s ; } }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public void init ( filter config config ) throw servlet exception { this . config = config ; this . init ( ) ; }
public list < enum < ? > > enums ( ) { return array . a list ( _values ) ; }
public java . util . list < com . google . api . http rule > get rule list ( ) { return rules_ ; }
public void set allow header name ( predicate < string > allow header name ) { assert . not null ( allow header name , `` allow header name can not be null `` ) ; this . allow header name = allow header name ; }
public void set skip empty filesets ( boolean skip ) { skip empty = skip ; }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public authentication builder add custom ( authentication authentication ) { if ( authentication ! = null ) { authentication . add ( authentication ) ; } return this ; }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public java . lang . string get name ( ) { java . lang . object ref = name_ ; if ( ref instanceof java . lang . string ) { return ( java . lang . string ) ref ; } else { com . google . protobuf . byte string b = ( com . google . protobuf . byte string ) ref ; java . lang . string s = b . to string utf8 ( ) ; name_ = s ; return s ; } }
public list < operation > static operation ( ) { return static operation ; }
public string get speculative retry ( ) { return speculative retry ; }
protect void compute time ( ) { boolean unset year = ! be set ( year ) ; if ( unset year ) set ( year , get default year ( ) ) ; try { super . compute time ( ) ; } finally { if ( unset year ) clear ( year ) ; } }
public static string encode lat lon ( double latitude , double longitude ) { return encode lat lon ( latitude , longitude , 12 ) ; }
public void set minute ( int minute ) { super . set field ( duration field type . minute ( ) , minute ) ; }
public int get nanos ( ) { return nanos_ ; }
public int get count ( ) { return message . size ( ) ; }
public byte iterator a utf8 ( ) { return a utf8 ( false ) ; }
public schema type get schema type ( ) { return schema type ; }
public list < m type > get message list ( ) { if ( external message list == null ) { external message list = new message external list < m type , b type , i type > ( this ) ; } return external message list ; }
public void set parameter type ( class < ? > [ ] parameter type ) { this . parameter type = parameter type ; }
public int get number of syntax error ( ) { return state . syntax error ; }
public void set level ( int level ) { this . level = level ; }
public string get name ( ) { return name ; }
protect search sequence get search sequence ( ) { if ( search sequence == null ) search sequence = new search sequence ( this ) ; return search sequence ; }
public static void set context class loader ( class loader loader ) { thread current thread = thread . current thread ( ) ; current thread . set context class loader ( loader ) ; }
public i s s table scanner get scanner ( iterator < abstract bound < partition position > > bound iterator ) { return big table scanner . get scanner ( this , bound iterator ) ; }
public static object get value ( annotation annotation , string attribute name ) { if ( annotation == null || ! string utils . have text ( attribute name ) ) { return null ; } try { method method = annotation . annotation type ( ) . get declared method ( attribute name ) ; reflection utils . make accessible ( method ) ; return method . invoke ( annotation ) ; } catch ( exception ex ) { return null ; } }
public static class get class ( class loader class loader , string class name ) throw class not find exception { return get class ( class loader , class name , true ) ; }
public static e w a h compress bitmap xor ( final e w a h compressed bitmap . . . bitmap ) { if ( bitmap . length == 1 ) return bitmap [ 0 ] ; int large size = calculate initial size ( bitmap ) ; int size = ( int ) ( large size * 1 . 5 ) ; final e w a h compress bitmap container = new e w a h compress bitmap ( size ) ; xor with container ( container , bitmap ) ; return container ; }
protect void append copy ( pointable roar array high low container , int start index , int end ) { extend array ( end - start index ) ; for ( int i = start index ; i < end ; ++i ) { this . key [ this . size ] = high low container . get key at index ( i ) ; this . value [ this . size ] = high low container . get container at index ( i ) . clone ( ) ; this . size++ ; } }
public container get container ( ) { return container ; }
public int get cardinality ( ) { int size = 0 ; for ( int i = 0 ; i < this . high low container . size ( ) ; ++i ) { size += this . high low container . get cardinality ( i ) ; } return size ; }
public void set mode ( string mode ) { this . mode = mode ; }
public b add alternate object directory ( file other ) { if ( other ! = null ) { if ( alternate object directory == null ) alternate object directory = new link list < > ( ) ; alternate object directory . add ( other ) ; } return self ( ) ; }
public void set id ( string id ) { this . id = id ; }
public void set title ( final string title ) { this . title = title ; }
public string get title ( ) { return title ; }
public e get entry ( ) { return entry ; }
public string get name ( ) { return name ; }
public string get email address ( ) { int email begin = user id . index of ( ' < ' ) ; if ( email begin < 0 ) { return null ; } int email end = user id . index of ( ' > ' , email begin ) ; if ( email end < 0 ) { return null ; } return user id . substring ( email begin + 1 , email end ) ; }
public string get identifier ( ) { return identifier ; }
public void set coverage ( final string coverage ) { this . coverage = list . create ( coverage ) ; }
public string get coverage ( ) { return list . first entry ( coverage ) ; }
public boolean be update ( ) { return be update ; }
public string get uri ( ) { return uri ; }
public void set image data ( byte [ ] image data array ) { image data = image data array ; }
public int get port ( ) { return port ; }
public string get procedure term ( ) { debug code call ( `` get procedure term `` ) ; return `` procedure `` ; }
public void set title ( final string title ) { this . title = title ; }
public void set width ( string width value ) { x w p f table . set width value ( width value , get tc width ( ) ) ; }
public void set title ( final string title ) { this . title = title ; }
public string get content ( ) { return content ; }
public void set author ( string author ) { _comment . set author id ( _comments . find author ( author ) ) ; }
public void set foreign markup ( final list < element > foreign markup ) { this . foreign markup = foreign markup ; }
public void set mode ( string mode ) { this . mode = mode ; }
public list < element > get foreign markup ( ) { return foreign markup = list . create when null ( foreign markup ) ; }
public string get uri ( ) { return uri ; }
public static uri normalize ( final string uri ) { return normalize ( uri . create ( uri ) ) ; }
public void set title ex ( final content title ) { this . title = title ; }
public @ nullable string get module ( ) { return module ; }
public icon get large icon ( string name ) { return get icon impl ( path + large icon sub dir + `` / `` + name + `` . `` + extension ) ; }
public governator add override module ( module . . . module ) { if ( module ! = null ) { this . override module . add all ( array . a list ( module ) ) ; } return this ; }
public string get encode ( ) { return encode ; }
public void set style ( style style ) { this . style = style ; }
public static string get element content ( final element element ) throw exception { return get element content ( element , null ) ; }
public void set subject ( string subject ) { this . subject = subject ; }
public static void read from file channel with eof exception ( file channel channel , long channel position , byte [ ] d , int d offset , int length ) throw i o exception { int read = read from file channel ( channel , channel position , dest , d offset , length ) ; if ( read < 0 ) { throw new e o f exception ( `` read past eof . pos [ `` + channel position + `` ] length : [ `` + length + `` ] end : [ `` + channel . size ( ) + `` ] `` ) ; } }
public namespace get namespace ( ) { return namespace ; }
public void set feed type ( string fee type ) { this . fee type = feed type ; }
public static < t > observable . on subscribe < t > on create ( observable . on subscribe < t > on subscribe ) { func1 < observable . on subscribe , observable . on subscribe > f = on observable create ; if ( f ! = null ) { return f . call ( on subscribe ) ; } return on subscribe ; }
public void set reconnection delay ( int delay ) { this . reconnection delay = delay ; }
public final completable do after terminate ( action0 on after terminate ) { return do on lifecycle ( action . empty ( ) , action . empty ( ) , action . empty ( ) , on after terminate , action . empty ( ) ) ; }
public final completable do on error ( action1 < ? super throwable > on error ) { return do on lifecycle ( action . empty ( ) , on error , action . empty ( ) , action . empty ( ) , action . empty ( ) ) ; }
public final subscription subscribe ( final action0 on complete ) { require non null ( on complete ) ; final multiple assignment subscription mad = new multiple assignment subscription ( ) ; unsafe subscribe ( new rx . completable subscriber ( ) { boolean do ; @ override public void on complete ( ) { if ( ! do ) { do = true ; try { on complete . call ( ) ; } catch ( throwable e ) { rx java hook . on error ( e ) ; deliver uncaught exception ( e ) ; } finally { mad . unsubscribe ( ) ; } } } @ override public void on error ( throwable e ) { rx java hook . on error ( e ) ; mad . unsubscribe ( ) ; deliver uncaught exception ( e ) ; } @ override public void on subscribe ( subscription d ) { mad . set ( d ) ; } } ) ; return mad ; }
public final subscription subscribe ( ) { final multiple assignment subscription mad = new multiple assignment subscription ( ) ; unsafe subscribe ( new rx . completable subscriber ( ) { @ override public void on complete ( ) { mad . unsubscribe ( ) ; } @ override public void on error ( throwable e ) { rx java hook . on error ( e ) ; mad . unsubscribe ( ) ; deliver uncaught exception ( e ) ; } @ override public void on subscribe ( subscription d ) { mad . set ( d ) ; } } ) ; return mad ; }
public long get n ( ) { return n ; }
public list < future type > submit task and wait ( key type key , list < callable < future type > > task ) { list < future type > result = list . new array list ( ) ; submit task ( key , task , null ) ; list < future < future type > > future = null ; synchronize ( m_future map ) { future = m_future map . get ( key ) ; if ( future ! = null ) { while ( ! be finish ( future ) ) { try { thread . sleep ( 1000 ) ; } catch ( interrupted exception e ) { e . print stack trace ( ) ; } } for ( future < future type > future : future ) { try { if ( future ! = null ) result . add ( future . get ( ) ) ; } catch ( interrupted exception e ) { e . print stack trace ( ) ; } catch ( execution exception e ) { e . print stack trace ( ) ; } } } } return result ; }
public boolean have throwable ( ) { return observer . get ( ) == terminate & & error ! = null ; }
public string get version ( ) { return version ; }
public void set value ( t t ) { this . value = t ; }
public final observable < t > single or default ( t default value ) { return lift ( new operator single < t > ( default value ) ) ; }
public static < t > observable < t > amb ( observable < ? extend t > o1 , observable < ? extend t > o2 , observable < ? extend t > o3 , observable < ? extend t > o4 , observable < ? extend t > o5 ) { return unsafe create ( on subscribe amb . amb ( o1 , o2 , o3 , o4 , o5 ) ) ; }
public static < t > observable < t > amb ( iterable < ? extend observable < ? extend t > > source ) { return unsafe create ( on subscribe amb . amb ( source ) ) ; }
public function score query builder boost mode ( combine function combine function ) { if ( combine function == null ) { throw new illegal argument exception ( `` [ `` + name + `` ] require 'boost_mode ' field `` ) ; } this . boost mode = combine function ; return this ; }
public static < t > observable < t > concat ( observable < ? extend t > t1 , observable < ? extend t > t2 , observable < ? extend t > t3 , observable < ? extend t > t4 ) { return concat ( just ( t1 , t2 , t3 , t4 ) ) ; }
public static < t > observable < t > concat delay error ( observable < ? extend t > t1 , observable < ? extend t > t2 , observable < ? extend t > t3 , observable < ? extend t > t4 ) { return concat delay error ( just ( t1 , t2 , t3 , t4 ) ) ; }
public static < t > observable < t > concat ( observable < ? extend t > t1 , observable < ? extend t > t2 , observable < ? extend t > t3 , observable < ? extend t > t4 ) { return concat ( just ( t1 , t2 , t3 , t4 ) ) ; }
public static < t > observable < t > merge ( observable < ? extend single < ? extend t > > source , int max concurrency ) { return source . flat map single ( ( func1 ) utility function . identity ( ) , false , max concurrency ) ; }
public static < t > observable < t > concat ( observable < ? extend t > t1 , observable < ? extend t > t2 ) { return concat ( just ( t1 , t2 ) ) ; }
public static < t > observable < t > concat delay error ( observable < ? extend t > t1 , observable < ? extend t > t2 , observable < ? extend t > t3 , observable < ? extend t > t4 ) { return concat delay error ( just ( t1 , t2 , t3 , t4 ) ) ; }
public final observable < time interval < t > > time interval ( scheduler scheduler ) { return lift ( new operator time interval < t > ( scheduler ) ) ; }
public string default boundary ( ) { return default boundary ; }
public static < t > observable < t > concat ( observable < ? extend t > t1 , observable < ? extend t > t2 ) { return concat ( just ( t1 , t2 ) ) ; }
public final observable < t > last ( ) { return take last ( 1 ) . single ( ) ; }
public final observable < t > first ( ) { return take ( 1 ) . single ( ) ; }
public static < t > observable < t > merge ( observable < ? extend t > t1 , observable < ? extend t > t2 ) { return merge ( new observable [ ] { t1 , t2 } ) ; }
public final flux < t > repeat ( long num repeat , boolean supplier predicate ) { if ( num repeat < 0l ) { throw new illegal argument exception ( `` num repeat > = 0 require `` ) ; } if ( num repeat == 0 ) { return this . flux ( ) ; } return flux . defer ( ( ) - > repeat ( flux . count boolean supplier ( predicate , num repeat ) ) ) ; }
public single < t > to single ( ) { return new single < t > ( on subscribe single . create ( this ) ) ; }
public retry policy with max duration ( long max duration , time unit time unit ) { assert . not null ( time unit , `` time unit `` ) ; assert . state ( time unit . to nanos ( max duration ) > delay . to nanos ( ) , `` max duration must be great than the delay `` ) ; this . max duration = new duration ( max duration , time unit ) ; return this ; }
public static observable < integer > range ( int start , int count , scheduler scheduler ) { return range ( start , count ) . subscribe on ( scheduler ) ; }
public final collection < t > to collection ( ) { list < t > list = new array list < t > ( ) ; add to ( list ) ; return list ; }
public static < t > test subscriber < t > create ( observer < t > delegate , long initial request ) { return new test subscriber < t > ( delegate , initial request ) ; }
public static < t > test subscriber < t > create ( long initial request ) { return new test subscriber < t > ( initial request ) ; }
public int count ( ) { return count ; }
public static completable complete ( ) { on subscribe co = rx java hook . on create ( complete . on subscribe ) ; if ( cos == complete . on subscribe ) { return complete ; } return new completable ( co , false ) ; }
public void set fail on error ( boolean fail on error ) { this . fail on error = fail on error ; }
public schedule executor service get schedule executor ( ) throw illegal state exception { assert . state ( this . schedule executor ! = null , `` thread pool task scheduler not initialize `` ) ; return this . schedule executor ; }
protect void set name source start ( int start ) { this . name start= start ; }
public static < t > observable < t > concat ( single < ? extend t > t1 , single < ? extend t > t2 , single < ? extend t > t3 , single < ? extend t > t4 , single < ? extend t > t5 , single < ? extend t > t6 , single < ? extend t > t7 , single < ? extend t > t8 ) { return observable . concat ( a observable ( t1 ) , a observable ( t2 ) , a observable ( t3 ) , a observable ( t4 ) , a observable ( t5 ) , a observable ( t6 ) , a observable ( t7 ) , a observable ( t8 ) ) ; }
public static < t > observable < t > concat ( single < ? extend t > t1 , single < ? extend t > t2 , single < ? extend t > t3 , single < ? extend t > t4 , single < ? extend t > t5 , single < ? extend t > t6 , single < ? extend t > t7 ) { return observable . concat ( a observable ( t1 ) , a observable ( t2 ) , a observable ( t3 ) , a observable ( t4 ) , a observable ( t5 ) , a observable ( t6 ) , a observable ( t7 ) ) ; }
public static < t > observable < t > concat ( single < ? extend t > t1 , single < ? extend t > t2 , single < ? extend t > t3 , single < ? extend t > t4 , single < ? extend t > t5 , single < ? extend t > t6 , single < ? extend t > t7 ) { return observable . concat ( a observable ( t1 ) , a observable ( t2 ) , a observable ( t3 ) , a observable ( t4 ) , a observable ( t5 ) , a observable ( t6 ) , a observable ( t7 ) ) ; }
public static < t > observable < t > merge ( observable < ? extend observable < ? extend t > > source ) { if ( source . get class ( ) == scalar synchronous observable . class ) { return ( ( scalar synchronous observable < t > ) source ) . scalar flat map ( ( func1 ) utility function . identity ( ) ) ; } return source . lift ( operator merge . < t > instance ( false ) ) ; }
public static < t > observable < t > concat ( observable < ? extend t > t1 , observable < ? extend t > t2 ) { return concat ( just ( t1 , t2 ) ) ; }
public throwable get error ( ) { object o = value ; if ( notification lite . be error ( o ) ) { return notification lite . get error ( o ) ; } return null ; }
public static < t > maybe subject < t > create ( ) { return new maybe subject < t > ( ) ; }
public state get state ( ) { return state . get ( ) . get state ( ) ; }
public void set strip extension ( boolean strip extension ) { this . strip extension = strip extension ; }
public boolean be close ( ) { return close ; }
public static int range set get category ( byte mask ) { int range set irs = new int range set ( ) ; for ( int i=0 ; i < 65536 ; i++ ) { if ( ( data [ i ] & mask ) ! = 0 ) { irs . add ( i ) ; } } if ( ( mask & ( name_start_11_mask | name_11_mask ) ) ! = 0 ) { irs . add range ( utf16 . nonbmp_min , max_xml11_name_char ) ; } return irs ; }
public int get range ( ) { return i range ; }
public boolean have result ( ) { return have result ; }
public void set u r i resolver ( u r i resolver resolver ) { uri resolver = resolver ; }
public model map get default model ( ) { return this . default model ; }
public document get document ( ) { return doc ; }
public void set executable ( executable executable ) { this . executable = executable ; }
public class loader get class loader ( ) { return class loader ; }
public void set base u r i ( string base u r i ) { this . base u r i = base u r i ; }
public mode get stripper rule ( ) { return stripper rule ; }
public handler [ ] get and set handler ( final handler [ ] handler ) throw security exception { final handler [ ] safe handler = handler . clone ( ) ; for ( handler handler : safe handler ) { if ( handler == null ) { throw new illegal argument exception ( `` a handler be null `` ) ; } } return logger node . set handler ( safe handler ) ; }
public boolean be form list ( ) { return form list ; }
public iterator get namespaces ( ) { return m namespaces . iterator ( ) ; }
public locator get location ( ) { return d o m locator . get location info ( e ) ; }
public void set require well form ( boolean well form ) { require well form = well form ; }
public void set d pipeline ( string pipeline name ) { this . get destination ( ) . set pipeline ( pipeline name ) ; }
public string get system id ( ) { return system id ; }
public void set u r i resolver ( u r i resolver resolver ) { user u r i resolver = resolver ; if ( resolver instanceof standard u r i resolver ) { ( ( standard u r i resolver ) resolver ) . set configuration ( get configuration ( ) ) ; } }
public view controller registration add view controller ( string url path ) { view controller registration registration = new view controller registration ( url path ) ; registration . set application context ( this . application context ) ; this . registration . add ( registration ) ; return registration ; }
public boolean get expand entity ( ) { return expand ; }
public void set receiver type ( type receiver type ) { unsupported in2_3_4 ( ) ; a s t node old child = this . optional receiver type ; pre replace child ( old child , receiver type , receiver_type_property ) ; this . optional receiver type = receiver type ; post replace child ( old child , receiver type , receiver_type_property ) ; }
public string [ ] get permission data ( string location ) { if ( location == null ) return default info ; synchronize ( location ) { if ( location . size ( ) == 0 ) return null ; return location . get ( location ) ; } }
public string get u r l ( ) { return service . get u r l ( ) ; }
public void set attribute start ( string attribute start ) { this . attribute start = attribute start ; }
public string get name ( int code ) { string name = code to name . get ( code ) ; if ( name ! = null ) { return name ; } return `` . notdef `` ; }
public static node info build ( source source , stripper stripper , configuration config ) throw x path exception { return build ( source , stripper , config . make pipeline configuration ( ) ) ; }
public int get last ( ) throw x path exception { x path exception err = new x path exception ( `` the context item be undefined `` ) ; err . set error code ( `` xpdy0002 `` ) ; throw err ; }
public receiver get underlying receiver ( ) { return next receiver ; }
public type get type ( ) { return type ; }
public void remove variable ( string name ) { if ( null == variable ) { return ; } variable . remove ( name ) ; }
public boolean be boolean ( ) { return false ; }
public item type get item type ( type hierarchy th ) { item type t = atomizer . get atomized item type ( argument [ 0 ] , false , th ) ; if ( t . get primitive type ( ) == standard name . xs_untyped_atomic ) { return build in atomic type . double ; } else { return t ; } }
public int cardinality ( ) { return cardinality ; }
public void set default collation name ( string name ) { default collation name = name ; }
public string collator get name collation ( string name ) { if ( name . equal ( namespace constant . codepoint_collation_uri ) ) { return codepoint collator . get instance ( ) ; } if ( map ! = null ) { string collator c = ( string collator ) map . get ( name ) ; if ( c ! = null ) { return c ; } } return config . get collation u r i resolver ( ) . resolve ( name , null , config ) ; }
public void set name collation ( string absolute u r i , string collator collator ) { if ( map == null ) { map = new hash map ( ) ; } map . put ( absolute u r i , collator ) ; }
public iterable < item > get item ( ) { return this . item ; }
public sequence iterator get regex group iterator ( ) { int c = matcher . group count ( ) ; if ( c == 0 ) { return empty iterator . get instance ( ) ; } else { string value [ ] group = new string value [ c ] ; for ( int i=1 ; i < =groups . length ; i++ ) { group [ i-1 ] = string value . make string value ( matcher . group ( i ) ) ; } return new array iterator ( group ) ; } }
public boolean be at last ( ) throw x path exception { x path exception err = new x path exception ( `` the context item be undefined `` ) ; err . set error code ( `` xpdy0002 `` ) ; throw err ; }
public int get last ( ) throw x path exception { x path exception err = new x path exception ( `` the context item be undefined `` ) ; err . set error code ( `` xpdy0002 `` ) ; throw err ; }
public void set ( int value ) { this . value = value ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public iterable < item event > get item event ( ) { collection < item event > item event = new array list < item event > ( ) ; for ( object event : this . event ) { if ( event instanceof item event ) { item event . add ( ( item event ) event ) ; } } return item event ; }
public artifact descriptor result set dependency ( list < dependency > dependency ) { if ( dependency == null ) { this . dependency = collection . empty list ( ) ; } else { this . dependency = dependency ; } return this ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public string get language ( ) { return language ; }
public string get system id ( ) { return system id ; }
public double get line number ( ) { return line number ; }
public void set executable ( executable executable ) { this . executable = executable ; }
public static stack get stack ( ) { stack stack = interception context . get ( ) ; if ( stack == null ) { stack = new stack ( interception context ) ; interception context . set ( stack ) ; } return stack ; }
public void set variable q name ( structure q name name ) { variable q name = name ; }
public int get min length ( ) { return this . min length ; }
public pattern analyze ( expression visitor visitor , item type context item type ) throw x path exception { id expression = visitor . type check ( id expression , context item type ) ; role locator role = new role locator ( role locator . function , `` id `` , 1 ) ; id expression = type checker . static type check ( id expression , sequence type . atomic_sequence , false , role , visitor ) ; return this ; }
public int hash code ( ) { return to string ( ) . hash code ( ) ; }
public string get configuration ( ) { return this . configuration ; } // -- string get configuration ( )
public string get expression ( ) { return expression ; }
public class < ? > get type ( ) { return i type ; }
public int cardinality ( ) { return cardinality ; }
public boolean be function ( ) { return this . function ; }
public object [ ] get argument ( ) { return argument ; }
public x path context get x path context object ( ) { return context object ; }
public static double day in month ( x path context context ) throw x path exception { return day in month ( date time ( context ) ) ; }
public static double day in year ( x path context context ) throw x path exception { return day in year ( date time ( context ) ) ; }
public static double day in year ( x path context context ) throw x path exception { return day in year ( date time ( context ) ) ; }
public static double day in week ( x path context context ) throw x path exception { return day in week ( date time ( context ) ) ; }
public expression pre evaluate ( expression visitor visitor ) { return this ; }
public char sequence evaluate a string ( x path context c ) throw x path exception { return evaluate item ( c ) . get string value c s ( ) ; }
public static boolean be x m l whitespace ( char c ) { if ( c== ' ' || c=='\n ' || c=='\t ' || c=='\r ' ) { return true ; } return false ; }
public static global order comparer get instance ( ) { return instance ; }
public atomic integer array assert contain only once ( int . . . value ) { array . assert contain only once ( info , array , value ) ; return myself ; }
public char sequence evaluate a string ( x path context c ) throw x path exception { return evaluate item ( c ) . get string value c s ( ) ; }
public expression pre evaluate ( expression visitor visitor ) { return this ; }
public item type get item type ( type hierarchy th ) { return require item type ; }
public expression pre evaluate ( expression visitor visitor ) throw x path exception { return argument [ 0 ] ; }
public static map synchronize map ( map map ) { return collection . synchronize map ( map ) ; }
public expression pre evaluate ( expression visitor visitor ) throw x path exception { return this ; }
public pipeline configuration get pipeline configuration ( ) { return pipeline config ; }
public option get option ( ) { return option ; }
public int get return option ( ) { return return option ; }
public void add attribute ( attribute info attribute ) { attribute . put ( attribute . get name ( ) , attribute ) ; }
public int get instruction name code ( ) { return standard name . xsl_variable ; }
public string get expression ( ) { return expression ; }
public namespace get namespace ( ) { return namespace ; }
public namespace get namespace ( ) { return namespace ; }
public rule get rule ( ) { return this . rule ; }
public final string get template ( ) { return template ; }
public rule get rule ( ) { return this . rule ; }
public structure q name get format q name ( ) { return output format name ; }
public string get default collation name ( ) { return default collation name ; }
public string get reason ( ) { return reason ; }
public boolean be require ( ) { return require ; }
public int get instruction name code ( ) { return standard name . xsl_attribute ; }
public void set id ( string id ) { this . id = id ; }
public schema get schema ( ) { return schema ; }
public void set mode ( string mode ) { this . mode = mode ; }
public void set select ( expression select , configuration config ) throw x path exception { this . select = select ; adopt child expression ( select ) ; }
public void set separator ( string separator ) { this . separator = separator ; }
public expression get select expression ( ) { return select ; }
public final void set precedence dfa ( boolean precedence dfa ) { if ( precedence dfa ! = be precedence dfa ( ) ) { throw new unsupported operation exception ( `` the precedence dfa field can not change after a dfa be construct . `` ) ; } }
public void set type ( int type ) { this . type = type ; }
public void set line number ( int line number ) { this . line number = line number ; }
public void set update reference ( boolean update reference ) { f update references= update reference ; }
public boolean be memo function ( ) { return memo function ; }
public final q name get name ( ) { return name ; }
public expression get select expression ( ) { return select ; }
public string get expression ( ) { return expression ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public static expect condition < boolean > attribute to be ( final by locator , final string attribute , final string value ) { return new expect condition < boolean > ( ) { private string current value = null ; @ override public boolean apply ( web driver driver ) { web element element = driver . find element ( locator ) ; current value = element . get attribute ( attribute ) ; if ( current value == null||current value . be empty ( ) ) { current value = element . get css value ( attribute ) ; } return value . equal ( current value ) ; } @ override public string to string ( ) { return string . format ( `` element find by % s to have value \ `` % s\ `` . current value : \ `` % s\ `` `` , locator , value , current value ) ; } } ; }
public boolean contains number ( number number ) { if ( number == null ) { return false ; } return contains integer ( number . int value ( ) ) ; }
public group iterator get current group iterator ( ) { not allow ( ) ; return null ; }
public boolean contains number ( number number ) { if ( number == null ) { return false ; } return contains long ( number . long value ( ) ) ; }
public document get document ( ) { return doc ; }
public static int [ ] new int array ( int len ) { if ( len == 0 ) { return empty_int_array ; } return new int [ len ] ; }
public static boolean [ ] set length ( final boolean [ ] array , final int length ) { if ( length == array . length ) return array ; if ( length < array . length ) return trim ( array , length ) ; return ensure capacity ( array , length ) ; }
protect void validate index ( int index ) { if ( index < 0 || index > size ) { throw new string index out of bound exception ( index ) ; } }
public node get node ( ) { return node ; }
public string to string ( ) { return `` [ namespace : prefix \ `` `` + prefix + `` \ `` be map to uri \ `` `` + uri + `` \ `` ] `` ; }
public node info get node ( ) { return node ; }
public void set line number ( int line number ) { this . line number = line number ; }
public string get value ( ) { return value ; }
public string get prefix ( ) { return prefix ; }
public double get priority ( ) { return 0 . 5 ; }
public void set nillable ( boolean nillable ) { this . nillable = nillable ; }
public final expression type check ( expression visitor visitor , item type context item type ) { return this ; }
public pattern get pattern ( ) { return pattern ; }
public string get namespace u r i ( ) { return namespace . get u r i ( ) ; }
public atomic boolean assert be false ( ) { be not null ( ) ; assert equal ( false ) ; return myself ; }
public container get container ( ) { return container ; }
public rev commit get new head ( ) { return new head ; }
public void set visitor ( boolean visitor ) { optional attrs . put ( visitor , visitor ? boolean . true : boolean . false ) ; }
public pattern get r h s ( ) { return p2 ; }
public pattern get l h s ( ) { return p1 ; }
public void set system id ( string system id ) { this . system id = system id ; }
public string get prefix ( ) { return prefix ; }
public void set skip empty filesets ( boolean skip ) { skip empty = skip ; }
public string get name ( ) { return name ; }
public void set parameter ( string name , string . . . value ) { assert . not null ( name , `` parameter name must not be null `` ) ; this . parameter . put ( name , value ) ; }
public string get system id ( ) { return system id ; }
public iterator iterator ( ) { return new iterator ( ) ; }
public boolean import namespace ( string uri ) { return import module namespaces ! = null & & import module namespaces . contains ( uri ) ; }
public void add import namespace ( string uri ) { if ( import module namespaces == null ) { import module namespaces = new hash set ( 5 ) ; } import module namespaces . add ( uri ) ; get import function library ( ) . add imported namespace ( uri ) ; }
public boolean import namespace ( string uri ) { return import module namespaces ! = null & & import module namespaces . contains ( uri ) ; }
public boolean be function ( ) { return this . function ; }
public void set executable ( executable executable ) { this . executable = executable ; }
public projection list add ( projection projection ) { element . add ( projection ) ; return this ; }
public int get column number ( ) { return -1 ; }
public void set executable ( executable executable ) { this . executable = executable ; }
public boolean be memo function ( ) { return memo function ; }
public int get column number ( ) { return -1 ; }
public boolean be function ( ) { return this . function ; }
public static input source to input source ( source s ) { return to input source ( s , null ) ; }
public boolean have next ( ) { return have next inet socket address ( ) || have next proxy ( ) || have next postpone ( ) ; }
public deployment option set instance ( int instance ) { this . instance = instance ; return this ; }
public int iterator key iterator ( ) { return new int to int hash map key iterator ( ) ; }
public void normalize ( ) { for ( int i = 0 ; i < size ; i++ ) { key [ i ] = low case ( key [ i ] ) ; } }
public iterator get key ( ) { return key a list . iterator ( ) ; }
public string get uri ( ) { return uri ; }
public void set order ( int order ) { this . order = order ; }
public void set output ( final print writer output ) { if ( output == null ) { this . output = new print writer ( null writer . default ) ; } else { this . output = output ; } }
public static set < error object > get standard error ( ) { return standard_errors ; }
protect synchronized void handle error output ( string output ) { if ( error print stream == null ) { error print stream = new print stream ( error stream ) ; } error print stream . print ( output ) ; }
public item type get item type ( type hierarchy th ) { return require item type ; }
public static int next high power of two ( int v ) { v -- ; v |= v > > 1 ; v |= v > > 2 ; v |= v > > 4 ; v |= v > > 8 ; v |= v > > 16 ; v++ ; return v ; }
public synchronize void put stylesheet ( object key , stylesheet sheet ) { _cache . put ( key , sheet ) ; }
public void set base u r i ( string base u r i ) { this . base u r i = base u r i ; }
public param type get param type ( ) { return param type ; }
public boolean have available disk space ( ) { return name node resource policy . be resource available ( volume . value ( ) , minimum redundant volume ) ; }
public structure q name get function name ( ) { return name ; }
public location get location ( ) { return this . location ; }
public build get build ( ) { return this . build ; } // -- build get build ( )
public function library get function library ( ) { return executable . get function library ( ) ; }
public void set base u r i ( string base u r i ) { this . base u r i = base u r i ; }
protect final void add function library ( function library library ) { function library library list = executable . get function library ( ) ; if ( library list instanceof function library list ) { ( ( function library list ) library list ) . add function library ( library ) ; } else { throw new illegal state exception ( `` register function library can not be extend `` ) ; } }
public namespace get namespace ( ) { return namespace ; }
public final int get node kind ( ) { return type . attribute ; }
public x path static context get static context ( ) { return static context ; }
public x path context get x path context object ( ) { return context object ; }
synchronize public final slot register slot ( int slot idx , extend block id block id ) throw invalid request exception { if ( slot idx < 0 ) { throw new invalid request exception ( this + `` : invalid negative slot `` + `` index `` + slot idx ) ; } if ( slot idx > = slot . length ) { throw new invalid request exception ( this + `` : invalid slot `` + `` index `` + slot idx ) ; } if ( allocated slot . get ( slot idx ) ) { throw new invalid request exception ( this + `` : slot `` + slot idx + `` be already in use . `` ) ; } slot slot = new slot ( calculate slot address ( slot idx ) , block id ) ; if ( ! slot . be valid ( ) ) { throw new invalid request exception ( this + `` : slot `` + slot idx + `` be not mark a valid . `` ) ; } slot [ slot idx ] = slot ; allocate slot . set ( slot idx , true ) ; if ( log . be trace enable ( ) ) { log . trace ( this + `` : register slot `` + slot idx + `` : allocate slots= `` + allocated slot + string utils . get stack trace ( thread . current thread ( ) ) ) ; } return slot ; }
public string get expression ( ) { return expression ; }
public char sequence get subsequence ( final int start position , final int end position ) { return string . sub sequence ( start position , end position ) ; }
public byte [ ] buffer ( ) { return this . buffer ; }
public string get namespace u r i ( ) { return name pool . get u r i from u r i code ( uri code ) ; }
public void set namespaces ( node info node ) { namespaces . clear ( ) ; int kind = node . get node kind ( ) ; if ( kind == type . attribute || kind == type . text || kind == type . comment || kind == type . processing_instruction || kind == type . namespace ) { node = node . get parent ( ) ; } if ( node == null ) { return ; } axis iterator iter = node . iterate axis ( axis . namespace ) ; while ( true ) { node info n = ( node info ) iter . next ( ) ; if ( ns == null ) { return ; } string prefix = n . get local part ( ) ; if ( `` `` . equal ( prefix ) ) { set default element namespace ( n . get string value ( ) ) ; } else { declare namespace ( n . get local part ( ) , ns . get string value ( ) ) ; } } }
public void set line number ( int line number ) { this . line number = line number ; }
public j tree get tree ( ) { return f tree ; }
public string id ( ) { return id ; }
public j tree get tree ( ) { return f tree ; }
public void set container ( object container ) { this . container = container ; }
public void set trace listener ( i trace listener trace listener ) { this . trace listener = trace listener ; this . trace enable = ( trace listener ! = null ) ; }
public http request with body ( string body ) { this . body = new string body ( body ) ; return this ; }
public void set mode name ( string mode name ) { this . mode name = mode name ; }
public void set make ( boolean make ) { this . make = make ; }
public autodiscover error code get error code ( ) { return error code ; }
public source get source ( ) { return source ; }
public configuration get configuration ( ) { return config ; }
public fast string buffer uncompress ( fast string buffer buffer ) { if ( buffer == null ) { buffer = new fast string buffer ( length ( ) ) ; } uncompress ( value , buffer ) ; return buffer ; }
public string value ( ) { return value ; }
public void set line number ( int line number ) { this . line number = line number ; }
public string get system id ( ) { return system id ; }
public boolean be boolean ( ) { return false ; }
public static class get wrapper type ( class primitive type ) { if ( primitive type . be primitive ( ) ) { return primitives_to_wrappers . get ( primitive type ) ; } return primitive type ; }
public boolean require property order ( ) { return false ; }
public static class get wrapper type ( class primitive type ) { if ( primitive type . be primitive ( ) ) { return primitives_to_wrappers . get ( primitive type ) ; } return primitive type ; }
public synchronize boolean be case sensitive ( ) { return be case sensitive ; }
public static void reset date time context ( ) { date time context holder . remove ( ) ; }
public boolean be reduce ( ) { return reduce ; }
protect object process parse value ( object value , format formatter ) { big decimal decimal = null ; if ( value instanceof long ) { decimal = big decimal . value of ( ( ( long ) value ) . long value ( ) ) ; } else { decimal = new big decimal ( value . to string ( ) ) ; } int scale = determine scale ( ( number format ) formatter ) ; if ( scale > = 0 ) { decimal = decimal . set scale ( scale , big decimal . round_down ) ; } return decimal ; }
public final q name get name ( ) { return name ; }
public json structure get root structure ( ) { return root ; }
public json content assert be equal to json ( string path , class < ? > resource load class , j s o n compare mode compare mode ) { string expect json = this . loader . get json ( path , resource load class ) ; return assert not fail ( compare ( expect json , compare mode ) ) ; }
public string get release ( ) { return this . release ; } // -- string get release ( )
public void set action ( string action ) { this . action = action ; }
public void set action ( string action ) { this . action = action ; }
public sys property get system property ( ) { return sys property ; }
public int get platform ( ) { return platform ; }
protect void configure ssl ( ssl context factory . server factory , ssl ssl , ssl store provider ssl store provider ) { factory . set protocol ( ssl . get protocol ( ) ) ; configure ssl client auth ( factory , ssl ) ; configure ssl password ( factory , ssl ) ; factory . set cert alias ( ssl . get key alias ( ) ) ; if ( ! object utils . be empty ( ssl . get cipher ( ) ) ) { factory . set include cipher suite ( ssl . get cipher ( ) ) ; factory . set exclude cipher suite ( ) ; } if ( ssl . get enabled protocol ( ) ! = null ) { factory . set include protocol ( ssl . get enabled protocol ( ) ) ; } if ( ssl store provider ! = null ) { try { factory . set key store ( ssl store provider . get key store ( ) ) ; factory . set trust store ( ssl store provider . get trust store ( ) ) ; } catch ( exception ex ) { throw new illegal state exception ( `` unable to set ssl store `` , ex ) ; } } else { configure ssl key store ( factory , ssl ) ; configure ssl trust store ( factory , ssl ) ; } }
public void set proxy username ( string proxy username ) { this . proxy username = proxy username ; }
public proxy set sock username ( string username ) { verify proxy type compatibility ( proxy type . manual ) ; this . proxy type = proxy type . manual ; this . sock username = username ; return this ; }
protect http2 frame logger frame logger ( ) { return frame logger ; }
public header configurer < h > default disable ( ) { this . content type option . disable ( ) ; this . xss protection . disable ( ) ; this . cache control . disable ( ) ; this . hsts . disable ( ) ; this . frame option . disable ( ) ; return this ; }
public void set auth response ( message auth response ) { this . _auth response = auth response ; }
public string get script ( ) { return script ; }
public void set line number ( int line number ) { this . line number = line number ; }
public void set post only ( boolean post only ) { this . post only = post only ; }
public policy get policy ( ) { return policy ; }
public string get url ( ) { return url ; }
public string get resource type ( ) { return resource type ; }
protect push certificate get push certificate ( ) { return push cert ; }
public t remote address ( supplier < ? extend socket address > remote address supplier ) { object . require non null ( remote address supplier , `` remote address supplier `` ) ; t dup = duplicate ( ) ; dup . configuration ( ) . remote address = remote address supplier ; return dup ; }
public string get t l s client auth san email ( ) { return tl client auth san email ; }
public byte [ ] get signature ( ) { return signature ; }
public pem key cert option add cert path ( string cert path ) { argument . require ( cert path ! = null , `` null cert path `` ) ; cert path . add ( cert path ) ; return this ; }
public void ensure validity ( ) { super . ensure validity ( ) ; if ( type == null ) { throw new illegal argument exception ( `` type must not be null `` ) ; } }
protect void set internal date ( final string date ) { this . date = date ; }
public request < ? > get request ( ) { return request ; }
public void on closing ( web socket web socket , int code , string reason ) { }
protect void validate profile ( string profile ) { if ( ! string utils . have text ( profile ) ) { throw new illegal argument exception ( `` invalid profile [ `` + profile + `` ] : must contain text `` ) ; } if ( profile . char at ( 0 ) == ' ! ' ) { throw new illegal argument exception ( `` invalid profile [ `` + profile + `` ] : must not begin with ! operator `` ) ; } }
public receive message result receive message ( receive message request request ) { request = before client execution ( request ) ; return execute receive message ( request ) ; }
public void set target ( string target to add ) { if ( target to add . equal ( `` `` ) ) { throw new build exception ( `` target attribute must not be empty `` ) ; } target . add ( target to add ) ; target attribute set = true ; }
public void set resource ( resource resource ) { this . resource = resource ; }
public void set preference ( string key , boolean value ) { additional prefs . set preference ( key , value ) ; }
public void set preference ( string key , string value ) { additional prefs . set preference ( key , value ) ; }
public synchronize void set host ( final http host host ) { this . host = host ; }
public path get path ( ) { return path ; }
public option get option ( ) { return option ; }
public string get location ( ) { return dictionary . get string ( c o s name . location ) ; }
public void run ( ) { this . delegate . run ( ) ; }
public int root ( ) { return root ; }
public process get process implementation ( ) { if ( process implementation == null & & process implementation class name ! = null ) { synchronize ( this ) { if ( process implementation == null & & process implementation class name ! = null ) { process implementation = classloading utility . load and instantiate class ( process . class , process implementation class name , null ) ; } } } return process implementation ; }
public string get address ( ) { return this . address ; } // -- string get address ( )
public list < generic info > get capability ( ) { return get capability ( null ) ; }
public option get option ( ) { return option ; }
public list < generic info > get capability ( ) { return get capability ( null ) ; }
public void clean up ( ) { }
public static void sleep at least ignore interrupt ( long millis ) { long start = time . now ( ) ; while ( time . now ( ) - start < millis ) { long time to sleep = millis - ( time . now ( ) - start ) ; try { thread . sleep ( time to sleep ) ; } catch ( interrupted exception ie ) { log . warn ( `` interrupt while sleep `` , ie ) ; } } }
public static expect condition < list < web element > > visibility of all element locate by ( final by locator ) { return new expect condition < list < web element > > ( ) { @ override public list < web element > apply ( web driver driver ) { list < web element > element = driver . find element ( locator ) ; for ( web element element : element ) { if ( ! element . be display ( ) ) { return null ; } } return element . size ( ) > 0 ? element : null ; } @ override public string to string ( ) { return `` visibility of all element locate by `` + locator ; } } ; }
public string get url pattern ( ) { return url pattern ; }
public static expect condition < list < web element > > number of element to be ( final by locator , final integer number ) { return new expect condition < list < web element > > ( ) { private integer current number = 0 ; @ override public list < web element > apply ( web driver web driver ) { list < web element > element = web driver . find element ( locator ) ; current number = element . size ( ) ; return current number . equal ( number ) ? element : null ; } @ override public string to string ( ) { return string . format ( `` number of element find by % s to be \ `` % s\ `` . current number : \ `` % s\ `` `` , locator , number , current number ) ; } } ; }
public item current ( ) { return string value . make string value ( current ) ; }
public static expect condition < list < web element > > visibility of all element locate by ( final by locator ) { return new expect condition < list < web element > > ( ) { @ override public list < web element > apply ( web driver driver ) { list < web element > element = driver . find element ( locator ) ; for ( web element element : element ) { if ( ! element . be display ( ) ) { return null ; } } return element . size ( ) > 0 ? element : null ; } @ override public string to string ( ) { return `` visibility of all element locate by `` + locator ; } } ; }
public static expect condition < list < web element > > visibility of all element locate by ( final by locator ) { return new expect condition < list < web element > > ( ) { @ override public list < web element > apply ( web driver driver ) { list < web element > element = driver . find element ( locator ) ; for ( web element element : element ) { if ( ! element . be display ( ) ) { return null ; } } return element . size ( ) > 0 ? element : null ; } @ override public string to string ( ) { return `` visibility of all element locate by `` + locator ; } } ; }
public static uri qname to u r i ( q name qname ) { if ( datatype constant . datetime . equal ( qname ) ) { return x m l schema . datetime ; } else if ( datatype constant . date . equal ( qname ) ) { return x m l schema . date ; } else if ( datatype constant . time . equal ( qname ) ) { return x m l schema . time ; } else if ( datatype constant . gyearmonth . equal ( qname ) ) { return x m l schema . gyearmonth ; } else if ( datatype constant . gmonthday . equal ( qname ) ) { return x m l schema . gmonthday ; } else if ( datatype constant . gyear . equal ( qname ) ) { return x m l schema . gyear ; } else if ( datatype constant . gmonth . equal ( qname ) ) { return x m l schema . gmonth ; } else if ( datatype constant . gday . equal ( qname ) ) { return x m l schema . gday ; } else if ( datatype constant . duration . equal ( qname ) ) { return x m l schema . duration ; } else { throw new illegal argument exception ( `` q name can not be map to an xml schema uri : `` + qname . to string ( ) ) ; } }
public long get d ( ) { return d ; }
public boolean be normalize ( ) { return be normalize ; }
public void set integer value ( int integer value ) { this . integer value = integer value ; }
public static boolean be primitive datatype ( uri datatype ) { return datatype . equal ( x m l schema . duration ) || datatype . equal ( x m l schema . datetime ) || datatype . equal ( x m l schema . time ) || datatype . equal ( x m l schema . date ) || datatype . equal ( x m l schema . gyearmonth ) || datatype . equal ( x m l schema . gyear ) || datatype . equal ( x m l schema . gmonthday ) || datatype . equal ( x m l schema . gday ) || datatype . equal ( x m l schema . gmonth ) || datatype . equal ( x m l schema . string ) || datatype . equal ( x m l schema . boolean ) || datatype . equal ( x m l schema . base64binary ) || datatype . equal ( x m l schema . hexbinary ) || datatype . equal ( x m l schema . float ) || datatype . equal ( x m l schema . decimal ) || datatype . equal ( x m l schema . double ) || datatype . equal ( x m l schema . anyuri ) || datatype . equal ( x m l schema . qname ) || datatype . equal ( x m l schema . notation ) ; }
public diff builder normalize whitespace ( ) { normalize whitespace = true ; return this ; }
public string get acl string ( ) { string builder sb = new string builder ( initial_capacity ) ; if ( all allow ) { sb . append ( ' * ' ) ; } else { sb . append ( get user string ( ) ) ; sb . append ( `` `` ) ; sb . append ( get group string ( ) ) ; } return sb . to string ( ) ; }
public void set fallback ( parser fallback ) { this . fallback = fallback ; }
public void clear ( ) { clear ( size ) ; }
public statement type get statement type ( ) { return statement type ; }
public void set base u r i ( string base u r i ) { this . base u r i = base u r i ; }
public ff get file format for file name ( string file name , ff fallback ) { return file format . match file name ( file name , this . get key ( ) , fallback ) ; }
public document parser ( parser parser ) { this . parser = parser ; return this ; }
public static void put unicode l e ( string input , byte [ ] output , int offset ) { byte [ ] bytes = input . get byte ( utf16le ) ; system . arraycopy ( byte , 0 , output , offset , byte . length ) ; }
public int [ ] get value ( ) { int [ ] result = new int [ size ( ) ] ; for ( int i = 0 ; i < result . length ; i++ ) { result [ i ] = get value ( i ) ; } return result ; }
public static string hex encode ( byte [ ] bytes ) { string builder sb = new string builder ( ) ; for ( byte a byte : byte ) { string string = integer . to hex string ( a byte & 0xff ) ; if ( string . length ( ) == 1 ) { sb . append ( `` 0 `` ) ; } sb . append ( string . to upper case ( locale . u ) ) ; } return sb . to string ( ) ; }
public string get extension ( ) { return this . extension ; } // -- string get extension ( )
public static r d f format for file name ( string file name , r d f format fallback ) { return match file name ( file name , rdf_formats , fallback ) ; }
public version result get result ( ) { return result ; }
public class < t > get type ( ) { return type ; }
protect resource get resource by path ( string path ) { if ( path ! = null & & path . start with ( `` / `` ) ) { path = path . substring ( 1 ) ; } return new file system resource ( path ) ; }
public void close ( ) throw i o exception { input . close ( ) ; }
public string get format ( ) { return format ; }
public void flush invalidate cache entry ( final http host host , final http request req ) { final string the uri = cache key generator . get u r i ( host , req ) ; final http cache entry parent = get entry ( the uri ) ; if ( request should not be cache ( req ) || should invalidate head cache entry ( req , parent ) ) { log . debug ( `` invalidate parent cache entry : `` + parent ) ; if ( parent ! = null ) { for ( final string variant u r i : parent . get variant map ( ) . value ( ) ) { flush entry ( variant u r i ) ; } flush entry ( the uri ) ; } final url req u r l = get absolute u r l ( the uri ) ; if ( req u r l == null ) { log . error ( `` could n't transform request into valid url `` ) ; return ; } final header cl hdr = req . get first header ( `` content- location `` ) ; if ( cl hdr ! = null ) { final string content location = cl hdr . get value ( ) ; if ( ! flush absolute uri from same host ( req u r l , content location ) ) { flush relative uri from same host ( req u r l , content location ) ; } } final header l hdr = req . get first header ( `` location `` ) ; if ( l hdr ! = null ) { flush absolute uri from same host ( req u r l , l hdr . get value ( ) ) ; } } }
public static string parse text node ( node node ) { final int node count = node . get child node ( ) . get length ( ) ; if ( node count == 0 ) { return `` `` ; } string builder buffer = new string builder ( ) ; for ( int i = 0 ; i < node count ; i++ ) { node child node = node . get child node ( ) . item ( i ) ; if ( child node . get node type ( ) == node . cdata_section_node || child node . get node type ( ) == node . text_node ) { buffer . append ( child node . get node value ( ) ) ; } } return buffer . to string ( ) ; }
public child label ( string . . . label value ) { if ( label value . length ! = label name . size ( ) ) { throw new illegal argument exception ( `` incorrect number of label . `` ) ; } for ( string label : label value ) { if ( label == null ) { throw new illegal argument exception ( `` label can not be null . `` ) ; } } list < string > key = array . a list ( label value ) ; child c = child . get ( key ) ; if ( c ! = null ) { return c ; } child c2 = new child ( ) ; child tmp = child . put if absent ( key , c2 ) ; return tmp == null ? c2 : tmp ; }
public static builder builder ( ) { return new builder ( ) ; }
public void set label ( string label ) { this . label = label ; }
public tag tag ( ) { return tag ; }
public < t > t load ( string yaml ) { return ( t ) load from reader ( new stream reader ( yaml ) , object . class ) ; }
public t load ( string yaml ) { return ( t ) loader . load ( new string reader ( yaml ) ) ; }
public static boolean be valid compress buffer ( byte [ ] input , int offset , int length ) throw i o exception { if ( input == null ) throw new null pointer exception ( `` input be null `` ) ; return impl . be valid compress buffer ( input , offset , length ) ; }
public static int compress ( byte [ ] input , int input offset , int input length , byte [ ] output , int output offset ) throw i o exception { return raw compress ( input , input offset , input length , output , output offset ) ; }
public static int uncompressed length ( byte [ ] input ) throw i o exception { return impl . uncompressed length ( input , 0 , input . length ) ; }
public static char [ ] uncompress char array ( byte [ ] input , int offset , int length ) throw i o exception { int uncompressed length = snappy . uncompressed length ( input , offset , length ) ; char [ ] result = new char [ uncompressed length / 2 ] ; int byte size = impl . raw uncompress ( input , offset , length , result , 0 ) ; return result ; }
protect float from string ( string input ) { return float . value of ( input ) ; }
public static float [ ] uncompress float array ( byte [ ] input ) throw i o exception { return uncompress float array ( input , 0 , input . length ) ; }
public void write optional byte reference ( @ nullable byte reference byte ) throw i o exception { if ( bytes == null ) { write v int ( 0 ) ; return ; } write v int ( byte . length ( ) + 1 ) ; byte . write to ( this ) ; }
public void set exception handler ( final thread . uncaught exception handler exception handler ) { assert . check not null param ( `` exception handler `` , exception handler ) ; this . exception handler = exception handler ; }
public < t > t get attribute ( string name ) { return ( t ) this . get attribute ( ) . get ( name ) ; }
public page split ( int at ) { return be leaf ( ) ? split leaf ( at ) : split node ( at ) ; }
public void option ( string path , route route ) { add route ( http method . option . name ( ) , route impl . create ( path , route ) ) ; }
public void option ( string path , route route ) { add route ( http method . option . name ( ) , route impl . create ( path , route ) ) ; }
public void trace ( string path , route route ) { add route ( http method . trace . name ( ) , route impl . create ( path , route ) ) ; }
public io . vertx . reactivex . ext . web . handler . graphql . apollo w s handler connection handler ( handler < io . vertx . reactivex . core . http . server web socket > connection handler ) { delegate . connection handler ( new handler < io . vertx . core . http . server web socket > ( ) { public void handle ( io . vertx . core . http . server web socket event ) { connection handler . handle ( io . vertx . reactivex . core . http . server web socket . new instance ( ( io . vertx . core . http . server web socket ) event ) ) ; } } ) ; return this ; }
public void set resource ( resource resource ) { this . resource = resource ; }
public int row view to model ( int view row ) { return sort model . target to source ( view row ) ; }
public path get spill file ( int spill number ) throw i o exception { return l dir alloc . get local path to read ( string . format ( spill_file_pattern , conf . get ( job context . task_attempt_id ) , spill number ) , conf ) ; }
public string get event ( ) { return event ; }
public void set mode ( string mode ) { this . mode = mode ; }
public spark launcher add app args ( string . . . args ) { for ( string arg : args ) { check not null ( arg , `` arg `` ) ; builder . app args . add ( arg ) ; } return this ; }
public static < t > void not empty ( string arg description , t . . . args ) { if ( args == null ) { throw new illegal argument exception ( arg description + `` must not be null `` ) ; } if ( args . length == 0 ) { throw new illegal argument exception ( arg description + `` must not be empty `` ) ; } }
public spark launcher redirect error ( file err file ) { error stream = process builder . redirect . to ( err file ) ; return this ; }
public spark launcher redirect error ( ) { redirect error stream = true ; return this ; }
public request < ? > get request ( ) { return request ; }
public string get property value ( string property name ) { return get property ( ) . get ( property name ) ; }
public synchronize byte [ ] response ( byte [ ] token ) { try { return sasl server ! = null ? sasl server . evaluate response ( token ) : new byte [ 0 ] ; } catch ( sasl exception e ) { throw throwables . propagate ( e ) ; } }
public synchronize boolean be complete ( ) { return sasl server ! = null & & sasl server . be complete ( ) ; }
public transport client factory create client factory ( list < transport client bootstrap > bootstrap ) { return new transport client factory ( this , bootstrap ) ; }
public void channel inactive ( transport client client ) { }
public static i o exception close all ( collection < ? extend auto closeable > closeables ) { i o exception compose = null ; for ( auto closeable it : closeables ) { try { it . close ( ) ; } catch ( exception e ) { if ( composed == null ) { compose = new i o exception ( `` can not close resource `` + it , e ) ; } else { compose . add suppressed ( e ) ; } } } return compose ; }
public static byte [ ] to array ( byte buffer buffer ) { if ( buffer . have array ( ) ) { byte [ ] array = buffer . array ( ) ; int from = buffer . array offset ( ) + buffer . position ( ) ; return array . copy of range ( array , from , from + buffer . remain ( ) ) ; } else { byte [ ] to = new byte [ buffer . remain ( ) ] ; buffer . slice ( ) . get ( to ) ; return to ; } }
public version version ( ) { return version ; }
public algorithm get algorithm ( ) { return algorithm ; }
public boolean sasl server always encrypt ( ) { return conf . get boolean ( `` spark . network . sasl . server always encrypt `` , false ) ; }
public int max sasl encrypt block size ( ) { return ints . check cast ( java utils . byte string a byte ( conf . get ( `` spark . network . sasl . max encrypt block size `` , `` 64k `` ) ) ) ; }
public static void init ( ) { }
public byte [ ] get byte ( ) { return byte ; }
public double get x ( ) { return x ; }
public bound add x value ( final double x ) { final double small = x - fudge_factor ; if ( min x == null || min x > small ) { min x = small ; } final double large = x + fudge_factor ; if ( max x == null || max x < large ) { max x = large ; } return this ; }
public double get shape ( ) { return shape ; }
public static sort field new distance sort ( string field , double latitude , double longitude ) { return new lat lon point sort field ( field , latitude , longitude ) ; }
public void fill rect ( int x , int y , int width , int height ) { rectangle rect = new rectangle ( x , y , width , height ) ; fill ( rect ) ; }
public double get x ( ) { return x ; }
public static void parse geometry ( geometry geometry , target target ) { parse geometry ( geometry , target , 0 ) ; }
public void set value ( string name , double value ) { if ( double . be na n ( value ) ) throw new illegal argument exception ( ) ; final double double value = get double ( name ) ; if ( value == double value ) return ; double old value = double . value of ( double value ) ; double new value = double . value of ( value ) ; try { notify = false ; if ( get default double ( name ) == value ) get plugin preference ( true ) . remove ( name ) ; else get plugin preference ( true ) . put double ( name , value ) ; fire property change event ( name , old value , new value ) ; } finally { notify = true ; } }
public void set parameter value type name ( string value ) { this . parameter value type name = value ; }
public int get fetch size ( ) { return fetch size ; }
public void set catalog name ( @ nullable string catalog name ) { check if configuration modification be allow ( ) ; this . table meta data context . set catalog name ( catalog name ) ; }
public void set require ( boolean value ) { this . require = value ; }
public boolean be name binding ( ) { return this . name binding ; }
public void set name binding ( boolean name binding ) { this . name bind = name binding ; }
public boolean have function ( string function name ) { return function map . contains key ( function name ) ; }
public boolean be nullable ( ) { return nullable ; }
public boolean store low case identifier ( ) throw s q l exception { debug code call ( `` store low case identifier `` ) ; string m = get mode ( ) ; if ( m . equal ( `` my s q l `` ) ) { return true ; } return false ; }
public string get include ( ) { return include ; }
public void set property name ( string property name ) { this . property name = property name ; }
public final string get template ( ) { return template ; }
public string get callback name ( ) { return callback name ; }
public static reflect compile ( string name , string content ) throw reflect exception { return on ( compile . compile ( name , content ) ) ; }
public call get call ( ) { return call ; }
public string get catalog name ( ) { return this . catalog name ; }
public void set column name ( string column name ) { this . column name = column name ; }
public integer get auto generate key ( ) { return auto generate key ; }
public void release connection ( ) { reset ( ) ; }
public void set connection ( string connection ) { this . connection = connection ; } // -- void set connection ( string )
public void set enforce ( boolean value ) { this . enforce = value ; }
public string get sql ( ) { return this . sql ; }
public void set line separator ( string separator ) { line separator = separator ; }
public void set delimiter ( string delimiter ) { this . delimiter = delimiter ; }
public void set read only ( boolean read only ) { set ( efs . attribute_read_only , read only ) ; }
public io . vertx . reactivex . ext . sql . s q l connection set auto commit ( boolean auto commit , handler < async result < void > > result handler ) { delegate . set auto commit ( auto commit , result handler ) ; return this ; }
public boolean contains key ( final object key ) { check key ( key ) ; return lookup key ( key ) ! = null ; }
public schema get schema ( ) { return schema ; }
public object get actual value ( ) { return this . actual value ; }
public int get batch size ( ) { if ( batch size == null ) { return -1 ; } else { return batch size ; } }
protect string resolve sql ( ) { string sql = get sql ( ) ; assert . state ( sql ! = null , `` no sql set `` ) ; return sql ; }
public string get sql ( ) { return this . sql ; }
public void set parameter ( string parameter ) { assert . have text ( parameter , `` parameter name can not be empty or null `` ) ; this . parameter = parameter ; }
public void start callable processing ( callable < ? > callable , object . . . process context ) throw exception { assert . not null ( callable , `` callable must not be null `` ) ; start callable processing ( new web async task ( callable ) , process context ) ; }
public void row process ( string [ ] row , t context ) { row . add ( row ) ; }
public t find object ( string p1 , @ nullable map < ? , ? > context ) throw data access exception { return find object ( new object [ ] { p1 } , context ) ; }
public t find object ( int p1 , @ nullable map < ? , ? > context ) throw data access exception { return find object ( new object [ ] { p1 } , context ) ; }
public void row process ( string [ ] row , t context ) { row . add ( row ) ; }
public int update ( long p1 , long p2 ) throw data access exception { return update ( new object [ ] { p1 , p2 } ) ; }
public int update ( long p1 ) throw data access exception { return update ( new object [ ] { p1 } ) ; }
public class < ? > get value class ( ) { return object . class ; }
public local result get key ( session session ) { database db = session == null ? null : session . get database ( ) ; if ( boolean . false . equal ( generate key request ) ) { clear ( null ) ; return new local result ( ) ; } array list < expression column > expression column ; if ( boolean . true . equal ( generate key request ) ) { expression column = new array list < > ( all column . size ( ) ) ; for ( column column : all column ) { expression column . add ( new expression column ( db , column ) ) ; } } else if ( generate key request instanceof int [ ] ) { if ( table ! = null ) { int [ ] index = ( int [ ] ) generate keys request ; column [ ] column = table . get columns ( ) ; int cnt = column . length ; all column . clear ( ) ; expression columns = new array list < > ( index . length ) ; for ( int idx : index ) { if ( idx > = 1 & & idx < = cnt ) { column column = column [ idx - 1 ] ; expression column . add ( new expression column ( db , column ) ) ; all column . add ( column ) ; } } } else { clear ( null ) ; return new local result ( ) ; } } else if ( generate key request instanceof string [ ] ) { if ( table ! = null ) { string [ ] name = ( string [ ] ) generate keys request ; all column . clear ( ) ; expression columns = new array list < > ( names . length ) ; for ( string name : name ) { column column ; search : if ( table . do column exist ( name ) ) { column = table . get column ( name ) ; } else { name = string utils . to upper english ( name ) ; if ( table . do column exist ( name ) ) { column = table . get column ( name ) ; } else { for ( column c : table . get columns ( ) ) { if ( c . get name ( ) . equal ignore case ( name ) ) { column = c ; break search ; } } continue ; } } expression column . add ( new expression column ( db , column ) ) ; all column . add ( column ) ; } } else { clear ( null ) ; return new local result ( ) ; } } else { clear ( null ) ; return new local result ( ) ; } int column count = expression column . size ( ) ; if ( column count == 0 ) { clear ( null ) ; return new local result ( ) ; } local result result = new local result ( session , expression column . to array ( new expression [ 0 ] ) , column count ) ; for ( map < column , value > map : data ) { value [ ] row = new value [ column count ] ; for ( map . entry < column , value > entry : map . entry set ( ) ) { int idx = all column . index of ( entry . get key ( ) ) ; if ( idx > = 0 ) { row [ idx ] = entry . get value ( ) ; } } for ( int i = 0 ; i < column count ; i++ ) { if ( row [ i ] == null ) { row [ i ] = value null . instance ; } } result . add row ( row ) ; } clear ( null ) ; return result ; }
public int size ( ) { return cache . size ( ) ; }
public void set database product name ( @ nullable string database product name ) { this . database product name = new string [ ] { database product name } ; }
public database get database ( ) { return database ; }
public void set require annotation type ( class < ? extend annotation > require annotation type ) { assert . not null ( required annotation type , `` 'required annotation type ' must not be null `` ) ; this . require annotation type = require annotation type ; }
protect connection do create connection ( ) throw resource exception { connection factory connection factory = get target connection factory ( ) ; assert . state ( connection factory ! = null , `` no 'target connection factory ' set `` ) ; return connection factory . get connection ( ) ; }
public void set target connection factory ( @ nullable connection factory target connection factory ) { this . target connection factory = target connection factory ; }
public void set target connection factory ( @ nullable connection factory target connection factory ) { this . target connection factory = target connection factory ; }
public void set creator tool ( string creator ) { set text property ( prefix + `` : creator tool `` , creator ) ; }
public cci template get derive template ( connection spec connection spec ) { cci template derive = new cci template ( obtain connection factory ( ) , connection spec ) ; record creator record creator = get output record creator ( ) ; if ( record creator ! = null ) { derive . set output record creator ( record creator ) ; } return derive ; }
public location get location ( ) { return this . location ; }
public i transaction get transaction ( ) { return this . transaction ; }
public void set activation ( activation activation ) { this . activation = activation ; } // -- void set activation ( activation )
public string get phase ( ) { return phase ; }
public void set resource ( resource resource ) { this . resource = resource ; }
public boolean be run ( ) { return process . be run ( ) ; }
public string get release ( ) { return this . release ; } // -- string get release ( )
public transport client factory create client factory ( list < transport client bootstrap > bootstrap ) { return new transport client factory ( this , bootstrap ) ; }
public boolean be work time ( ) { return be work time ; }
public string get phase ( ) { return phase ; }
public void add listener ( event listener listener ) { listener . add ( listener ) ; }
public void set transaction manager ( final transaction manager transaction manager ) { this . transaction manager = transaction manager ; }
public i transaction get transaction ( ) { return this . transaction ; }
public void set transaction manager ( final transaction manager transaction manager ) { this . transaction manager = transaction manager ; }
public final user transaction get user transaction ( ) { return this . user transaction ; }
public void set user transaction ( @ nullable user transaction user transaction ) { this . user transaction = user transaction ; }
public final void set transaction synchronization ( int transaction synchronization ) { this . transaction synchronization = transaction synchronization ; }
public string get isolation group ( ) { return isolation group ; }
public final user transaction get user transaction ( ) { return this . user transaction ; }
public i transaction get transaction ( ) { return this . transaction ; }
public void set user transaction ( @ nullable user transaction user transaction ) { this . user transaction = user transaction ; }
public void set manager ( string manager ) { this . manager = manager ; }
public boolean be synchronization active ( ) { return ( this . transaction context . get synchronization ( ) ! = null ) ; }
public transaction manager get transaction manager ( ) { return transaction manager ; }
public final int get transaction synchronization ( ) { return this . transaction synchronization ; }
public i transaction get transaction ( ) { return this . transaction ; }
public final int get transaction synchronization ( ) { return this . transaction synchronization ; }
public final void set transaction synchronization ( int transaction synchronization ) { this . transaction synchronization = transaction synchronization ; }
public void rollback ( ) { rollback to ( current version ) ; }
public i transaction get transaction ( ) { return this . transaction ; }
public address resolver option set cache negative time to live ( int cache negative time to live ) { if ( cache negative time to live < 0 ) { throw new illegal argument exception ( `` cache negative time to live must be > = 0 `` ) ; } this . cache negative time to live = cache negative time to live ; return this ; }
public boolean be rollback only ( ) { return ( be local rollback only ( ) || be global rollback only ( ) ) ; }
public matrix get q ( ) { int column = math . min ( original column , original row ) ; matrix q = qr . like ( original row , column ) ; for ( int k = columns - 1 ; k > = 0 ; k -- ) { vector q rcolk = qr . view column ( k ) . view part ( k , original row - k ) ; q . set ( k , k , 1 ) ; for ( int j = k ; j < columns ; j++ ) { if ( qr . get ( k , k ) ! = 0 ) { vector qcolj = q . view column ( j ) . view part ( k , original row - k ) ; double s = - q rcolk . dot ( qcolj ) / qr . get ( k , k ) ; qcolj . assign ( q rcolk , function . plus mult ( s ) ) ; } } } return q ; }
public int remain capacity ( ) { lock . lock ( ) ; try { return capacity - count ; } finally { lock . unlock ( ) ; } }
public static byte [ ] clone byte array ( byte [ ] b ) { if ( b == null ) { return null ; } int len = b . length ; if ( len == 0 ) { return empty_bytes ; } byte [ ] copy = new byte [ len ] ; system . arraycopy ( b , 0 , copy , 0 , len ) ; return copy ; }
public void stop ( ) throw i o exception { synchronize ( this . monitor ) { if ( this . listen thread ! = null ) { close all connection ( ) ; try { this . executor . shutdown ( ) ; this . executor . await termination ( 1 , time unit . minute ) ; } catch ( interrupted exception ex ) { thread . current thread ( ) . interrupt ( ) ; } this . server socket . close ( ) ; try { this . listen thread . join ( ) ; } catch ( interrupted exception ex ) { thread . current thread ( ) . interrupt ( ) ; } this . listen thread = null ; this . server socket = null ; } } }
public charset charset ( ) { return charset ! = null ? charset . for name ( charset ) : null ; }
public string key ( ) { return key ; }
public string get private key ( ) { return this . private key ; } // -- string get private key ( )
public char [ ] to char array ( ) { return back . to char array ( ) ; }
public static string to string ( byte [ ] array ) { string builder buf = new string builder ( ) ; buf . append ( ' [ ' ) ; int max index = array . length - 1 ; for ( int i = 0 ; i < = max index ; i++ ) { buf . append ( array [ i ] ) ; if ( i < max index ) { buf . append ( `` , `` ) ; } } buf . append ( ' ] ' ) ; return buf . to string ( ) ; }
protect string get model attribute ( ) { return this . model attribute ; }
public x m l stream reader create x m l stream reader ( input stream be , string charset ) throw x m l stream exception { / * ! ! ! this be not really correct : should ( try to ) auto-detect * encoding , since json only allow 3 unicode-based variant . * for now it 's ok to default to utf-8 though . * / if ( charset == null ) { charset = `` utf-8 `` ; } try { string doc = read all ( be , charset ) ; return create x m l stream reader ( new j s o n tokener ( doc ) ) ; } catch ( i o exception e ) { throw new x m l stream exception ( e ) ; } }
public object get ( char sequence key ) { final int bucket = normal completion . get bucket ( key ) ; return bucket == -1 ? null : long . value of ( bucket ) ; }
public void set system ( string system ) { this . system = system ; } // -- void set system ( string )
public static class get class ( class loader class loader , string class name ) throw class not find exception { return get class ( class loader , class name , true ) ; }
public void set parameter ( parameter [ ] parameter ) { if ( parameter ! = null ) { for ( int i = 0 ; i < parameter . length ; i++ ) { config parameter . add ( parameter [ i ] ) ; } } }
public string get description ( ) { return description ; }
public string get name ( ) { return name ; }
public string get type ( ) { return type ; }
public void set format ( format element e ) { format = e . get format ( ) ; }
public string get type ( ) { return type ; }
public string get schema ( ) { return schema ; }
public @ nullable response < ? > response ( ) { return response ; }
public boolean collection value ( ) { return new abstract boolean collection ( ) { public boolean contains ( final boolean k ) { return contain value ( k ) ; } public int size ( ) { return abstract byte2 boolean map . this . size ( ) ; } public void clear ( ) { abstract byte2 boolean map . this . clear ( ) ; } public boolean iterator iterator ( ) { return new abstract boolean iterator ( ) { final object iterator < map . entry < byte , boolean > > i = entry set ( ) . iterator ( ) ; / * * * { @ inherit doc } * * @ deprecate please use the corresponding type-specific * method instead . * / @ deprecate public boolean next boolean ( ) { return ( ( byte2 boolean map . entry ) i . next ( ) ) . get boolean value ( ) ; } ; public boolean have next ( ) { return i . have next ( ) ; } } ; } } ; }
public string get description ( ) { return description ; }
public set < type > get type ( ) { return type ; }
public synchronize boolean be connect ( ) { return connect ; }
public static < e extend enum < e > > boolean be valid enum ( class < e > enum class , string enum name ) { if ( enum name == null ) { return false ; } try { enum . value of ( enum class , enum name ) ; return true ; } catch ( illegal argument exception ex ) { return false ; } }
public string get description ( ) { return description ; }
public int next ( int node ) { return tree . next ( node ) ; }
public node get node ( ) { return node ; }
public long count ( ) { return count ; }
public boolean be root ( ) { return be root ; }
public node get node ( ) { return node ; }
public static message digest get sha256 digest ( ) { return get digest ( message digest algorithms . sha_256 ) ; }
public static void assert equal ( char actual , char expect , string message ) { assert equal ( character . value of ( actual ) , character . value of ( expect ) , message ) ; }
public static void assert equal ( long actual , long expect , string message ) { assert equal ( long . value of ( actual ) , long . value of ( expect ) , message ) ; }
static public void assert equal ( string message , object expect , object actual ) { if ( expect == null & & actual == null ) return ; if ( expect ! = null & & expect . equal ( actual ) ) return ; if ( expect instanceof string & & actual instanceof string ) throw new comparison failure ( message , ( string ) expect , ( string ) actual ) ; else fail not equal ( message , expect , actual ) ; }
public final u assert empty ( ) { return assert subscribe ( ) . assert no value ( ) . assert no error ( ) . assert not complete ( ) ; }
public static void append to file ( string output dir , string file name , string sb ) { string out dir path= output dir ! = null ? output dir : `` `` ; file out dir= new file ( out dir path ) ; write file ( out dir , file name , sb , null , true / * append * / ) ; }
public string get file name ( ) { return file name ; }
public boolean be trace enable ( ) { return logger . be trace enable ( ) ; }
public final boolean be info enable ( ) { return false ; }
public string get name ( ) { return to string ( ) ; }
public void set verbose ( boolean verbose ) { this . verbose = verbose ; }
public policy get policy ( ) { return policy ; }
public void set variable ( variable declaration variable ) { assert not null ( variable ) ; this . variable = variable ; variable . set parent ( this ) ; }
public void set classpath ( path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } }
public void set name ( string name ) { dictionary . set string ( c o s name . name , name ) ; }
public string get property ( final string key , final string def ) { final string value = this . get property ( key ) ; return value == null ? def : value ; }
public void add ( final future < ? > f ) { cancel . add ( new future completer ( f ) ) ; }
public static void write utf8 file ( @ nullable string output dir , string file name , string sb ) { final string out dir path= output dir ! = null ? output dir : `` `` ; final file out dir= new file ( out dir path ) ; write file ( out dir , file name , escape unicode ( sb ) , `` utf-8 `` ) ; }
public int count ( ) { return count ; }
public string get procedure term ( ) { debug code call ( `` get procedure term `` ) ; return `` procedure `` ; }
public int size ( ) { return _size ; }
public void set link ( boolean value ) { this . link = value ; }
public list < e > apply2 previous ( final list < e > previous ) { return apply2 previous ( previous , get list ( list type . create ) , get list ( list type . delete ) ) ; }
public boolean find ( int key ) { for ( int i=0 ; i < use ; i++ ) { if ( key [ i ] == key ) { return true ; } } return false ; }
public boolean contains key ( final object key ) { check key ( key ) ; return lookup key ( key ) ! = null ; }
public static boolean collection synchronize ( final boolean collection c ) { return new synchronize collection ( c ) ; }
public void set ( object instance ) { this . declared class = instance . get class ( ) ; this . instance = instance ; }
public int get row expect ( ) { return this . row expect ; }
protect char appender new char appender ( ) { int char = get max char per column ( ) ; if ( char ! = -1 ) { return new default char appender ( char , empty value , get whitespace range start ( ) ) ; } else { return new expand char appender ( empty value , get whitespace range start ( ) ) ; } }
public spark launcher add app args ( string . . . args ) { for ( string arg : args ) { check not null ( arg , `` arg `` ) ; builder . app args . add ( arg ) ; } return this ; }
public @ not null thread get thread ( ) { return thread ; }
public boolean be enable ( ) { return this . enable ; }
public void set empty value ( string empty value ) { this . empty value = empty value ; }
public boolean be ignore error ( ) { return ignore error ; }
public string get content ( ) { return content ; }
public void set expand entity ( final boolean expand ) { this . expand = expand ; engine = null ; }
public object apply conversion ( int index , string string value , boolean [ ] convert flag ) { list < conversion < ? , ? > > conversion = conversion by index . get ( index ) ; if ( conversion ! = null ) { if ( convert flags ! = null ) { convert flag [ index ] = true ; } object result = string value ; for ( conversion conversion : conversion ) { try { result = conversion . execute ( result ) ; } catch ( data process exception ex ) { ex . set column index ( index ) ; ex . mark a non fatal ( ) ; throw ex ; } catch ( throwable ex ) { data process exception exception = new data processing exception ( `` error convert value ' { value } ' use conversion `` + conversion . get class ( ) . get name ( ) , ex ) ; exception . set value ( result ) ; exception . set column index ( index ) ; exception . mark a non fatal ( ) ; throw exception ; } } return result ; } return string value ; }
public object reverse conversion ( boolean execute in reverse order , int index , object value , boolean [ ] convert flag ) { list < conversion < ? , ? > > conversion = conversion by index . get ( index ) ; if ( conversion ! = null ) { if ( convert flags ! = null ) { convert flag [ index ] = true ; } conversion conversion = null ; try { if ( execute in reverse order ) { for ( int i = conversion . size ( ) - 1 ; i > = 0 ; i -- ) { conversion = conversion . get ( i ) ; value = conversion . revert ( value ) ; } } else { for ( conversion < ? , ? > c : conversion ) { conversion = c ; value = conversion . revert ( value ) ; } } } catch ( data process exception ex ) { ex . set value ( value ) ; ex . set column index ( index ) ; ex . mark a non fatal ( ) ; throw ex ; } catch ( throwable ex ) { data process exception exception ; if ( conversion ! = null ) { exception = new data processing exception ( `` error convert value ' { value } ' use conversion `` + conversion . get class ( ) . get name ( ) , ex ) ; } else { exception = new data processing exception ( `` error convert value ' { value } ' `` , ex ) ; } exception . set value ( value ) ; exception . set column index ( index ) ; exception . mark a non fatal ( ) ; throw exception ; } } return value ; }
public date time field get field ( int index ) { return get field ( index , get chronology ( ) ) ; }
public final collection < t > to collection ( ) { list < t > list = new array list < t > ( ) ; add to ( list ) ; return list ; }
public void lock row add ( array list < row > row ) { if ( state == find ) { row . add ( get ( ) ) ; } }
public int get index ( ) { return index ; }
public object reverse conversion ( boolean execute in reverse order , int index , object value , boolean [ ] convert flag ) { list < conversion < ? , ? > > conversion = conversion by index . get ( index ) ; if ( conversion ! = null ) { if ( convert flags ! = null ) { convert flag [ index ] = true ; } conversion conversion = null ; try { if ( execute in reverse order ) { for ( int i = conversion . size ( ) - 1 ; i > = 0 ; i -- ) { conversion = conversion . get ( i ) ; value = conversion . revert ( value ) ; } } else { for ( conversion < ? , ? > c : conversion ) { conversion = c ; value = conversion . revert ( value ) ; } } } catch ( data process exception ex ) { ex . set value ( value ) ; ex . set column index ( index ) ; ex . mark a non fatal ( ) ; throw ex ; } catch ( throwable ex ) { data process exception exception ; if ( conversion ! = null ) { exception = new data processing exception ( `` error convert value ' { value } ' use conversion `` + conversion . get class ( ) . get name ( ) , ex ) ; } else { exception = new data processing exception ( `` error convert value ' { value } ' `` , ex ) ; } exception . set value ( value ) ; exception . set column index ( index ) ; exception . mark a non fatal ( ) ; throw exception ; } } return value ; }
public int get field index ( string header ) { return get field index ( new string [ ] { header } ) [ 0 ] ; }
public setting setting ( ) { return setting ; }
protect < t > t get bean ( string bean name , class < t > expect type ) { return bean factory annotation utils . qualified bean of type ( this . application context , expect type , bean name ) ; }
public < t > t get from context ( string key ) { return context ! = null ? ( t ) context . get ( key ) : null ; }
public void set column name ( string column name ) { this . column name = column name ; }
public static boolean be char a s c i i ( char [ ] char , int index , char car ) { if ( ( char == null ) || ( char . length == 0 ) || ( index < 0 ) || ( index > = char . length ) ) { return false ; } else { return ( ( char [ index ] == car ) ? true : false ) ; } }
public void set float value ( float float value ) { this . float value = float value ; }
public ct query impl add input ( object . . . input ) { if ( this . input == null ) { this . input = new array list < > ( ) ; } if ( input ! = null ) { collection . add all ( this . input , input ) ; } return this ; }
public void set null value ( string empty value ) { this . null value = empty value ; }
protect char appender new char appender ( ) { return new default char appender ( get max char per column ( ) , get null value ( ) , get whitespace range start ( ) ) ; }
public boolean be quote ( ) { return be quote ; }
public string get format ( ) { return format ; }
public void trigger action ( ) { trigger action ( time ) ; }
public boolean be pad ( char padding ) { return this . pad == padding ; }
public char [ ] get field padding ( ) { return argument utils . to char array ( field pad ) ; }
public void set new line ( string newline ) { this . default new line = newline ; }
protect char appender new char appender ( ) { int char = get max char per column ( ) ; if ( char ! = -1 ) { return new default char appender ( char , empty value , get whitespace range start ( ) ) ; } else { return new expand char appender ( empty value , get whitespace range start ( ) ) ; } }
public void set escape tab char ( char escape tab char ) { this . escape tab char = escape tab char ; }
public void set escape char ( char escape char ) { this . escape char = escape char ; }
public static < t extend comparable < t > > range < t > be ( t element ) { return between ( element , element , null ) ; }
public bit set < t > of all ( java . util . stream . stream < ? extend t > java stream ) { object . require non null ( java stream , `` java stream be null `` ) ; return empty ( ) . add all ( iterator . of all ( java stream . iterator ( ) ) ) ; }
public bit set < t > of all ( java . util . stream . stream < ? extend t > java stream ) { object . require non null ( java stream , `` java stream be null `` ) ; return empty ( ) . add all ( iterator . of all ( java stream . iterator ( ) ) ) ; }
public char seq [ ] split ( string regex , int limit ) { return split seq ( regex , limit ) . to java array ( char seq . class ) ; }
public static tree set < float > of all ( float . . . element ) { object . require non null ( element , `` element be null `` ) ; return tree set . of all ( iterator . of all ( element ) ) ; }
public static hash set < long > of all ( long . . . element ) { object . require non null ( element , `` element be null `` ) ; return hash set . of all ( iterator . of all ( element ) ) ; }
public static hash set < long > of all ( long . . . element ) { object . require non null ( element , `` element be null `` ) ; return hash set . of all ( iterator . of all ( element ) ) ; }
public static hash set < long > of all ( long . . . element ) { object . require non null ( element , `` element be null `` ) ; return hash set . of all ( iterator . of all ( element ) ) ; }
public string get mode ( ) { return mode ; }
public int get max text message buffer size ( ) { return get policy ( ) . get max text message buffer size ( ) ; }
public string to string ( ) { return to string ( `` `` ) ; }
public class < ? > get value class ( ) { return object . class ; }
public void set superclass ( name superclass name ) { internal set superclass ( superclass name ) ; }
public object get bean ( ) { return bean ; }
public class < ? > get type ( ) { return i type ; }
public static method [ ] get all method ( class < ? > clazz ) { if ( clazz == null ) { throw new illegal argument exception ( `` you must specify a class in order to get the method . `` ) ; } set < method > method = new link hash set < method > ( ) ; class < ? > this type = clazz ; while ( this type ! = null ) { final class < ? > type = this type ; final method [ ] declare method = access controller . do privilege ( new privilege action < method [ ] > ( ) { public method [ ] run ( ) { return type . get declare method ( ) ; } } ) ; for ( method method : declare method ) { method . set accessible ( true ) ; method . add ( method ) ; } collection . add all ( method , type . get method ( ) ) ; this type = this type . get superclass ( ) ; } return method . to array ( new method [ method . size ( ) ] ) ; }
public static stack get stack ( ) { stack stack = interception context . get ( ) ; if ( stack == null ) { stack = new stack ( interception context ) ; interception context . set ( stack ) ; } return stack ; }
public stack get stack ( ) { return stack ; }
protect bean manager impl ambiguous bean manager ( string caller class name , set < bean manager impl > manager ) { throw bean manager logger . log . ambiguous bean manager ( caller class name ) ; }
public response spec builder detach root path ( string path to detach ) { spec . detach root path ( path to detach ) ; return this ; }
public void set parameter ( parameter [ ] parameter ) { if ( parameter ! = null ) { for ( int i = 0 ; i < parameter . length ; i++ ) { config parameter . add ( parameter [ i ] ) ; } } }
public void set interceptor ( object [ ] interceptor ) { this . interceptor = interceptor ; }
public list < observer > get observer ( ) { return observer ; }
public string to string ( ) { string valid = be valid ( ) ? `` valid `` : `` invalid `` ; string normal = be normal ( ) ? `` normal `` : `` non-normal `` ; string passivating = be passivating ( ) ? `` passivating `` : `` pon-passivating `` ; return valid + normal + passivating + `` scope model for `` + get raw type ( ) ; }
public boolean be normal ( ) { return normal ; }
public void set manager ( string manager ) { this . manager = manager ; }
public static < t extend bean < ? > > set < t > remove disable bean ( set < t > bean , final bean manager impl bean manager ) { if ( bean . be empty ( ) ) { return bean ; } else { for ( iterator < t > iterator = bean . iterator ( ) ; iterator . have next ( ) ; ) { if ( ! be bean enable ( iterator . next ( ) , bean manager . get enabled ( ) ) ) { iterator . remove ( ) ; } } return bean ; } }
public object get bean ( ) { return bean ; }
public object get ( object name ) { if ( bean ! = null ) { method method = get read method ( name ) ; if ( method ! = null ) { try { return method . invoke ( bean , null_arguments ) ; } catch ( illegal access exception e ) { log warn ( e ) ; } catch ( illegal argument exception e ) { log warn ( e ) ; } catch ( invocation target exception e ) { log warn ( e ) ; } catch ( null pointer exception e ) { log warn ( e ) ; } } } return null ; }
public resource get archive ( ) { return be reference ( ) ? ( ( archive resource ) get check ref ( ) ) . get archive ( ) : archive ; }
public static void shutdown ( boolean now ) { if ( now ) lazy holder . executor . shutdown now ( ) ; else lazy holder . executor . shutdown ( ) ; }
public void import package ( string package name ) { import package . add ( package name ) ; }
public void decorate with ( java parser visitor decorator decorator ) { decorator . set base ( visitor ) ; visitor = decorator ; }
public bean < t > create ( ) { if ( ! passivation capable ) { return new immutable bean < t > ( bean class , name , qualifier , scope , stereotype , type , alternative , nullable , injection point , to string , bean lifecycle ) ; } else { return new immutable passivation capable bean < t > ( bean class , name , qualifier , scope , stereotype , type , alternative , nullable , injection point , to string , bean lifecycle , id ) ; } }
public header configurer < h > default disable ( ) { this . content type option . disable ( ) ; this . xss protection . disable ( ) ; this . cache control . disable ( ) ; this . hsts . disable ( ) ; this . frame option . disable ( ) ; return this ; }
public boolean remove shutdown hook ( runnable shutdown hook ) { if ( shutdown in progress . get ( ) ) { throw new illegal state exception ( `` shutdown in progress , can not remove a shutdown hook `` ) ; } return hook . remove ( new hook entry ( shutdown hook , 0 ) ) ; }
public string get id ( ) { return id ; }
public synchronize void set parent ( part parent ) { this . parent = parent ; }
public void set context ( object data ) { this . data = data ; }
public rule get rule ( ) { return this . rule ; }
public synchronize void add child ( runtime configurable child ) { child = ( child == null ) ? new array list ( ) : child ; child . add ( child ) ; }
public void close ( ) { delegate . close ( ) ; }
public request < ? > get request ( ) { return request ; }
public void set size ( long size ) { this . size = size ; }
public long get commit time ( ) { return commit time ; }
public static void main ( string [ ] args ) throw i o exception { parse args ( args ) . upgrade ( ) ; }
public list < string > get child ( string path , stat stat , watcher watcher ) throw keeper exception . no node exception { return data tree . get child ( path , stat , watcher ) ; }
public stat get stat ( ) { return stat ; }
public byte [ ] get data ( string path , stat stat , watcher watcher ) throw keeper exception . no node exception { return data tree . get data ( path , stat , watcher ) ; }
public void set snapshot ( snapshot snapshot ) { this . snapshot = snapshot ; } // -- void set snapshot ( snapshot )
public void set commit name ( string [ ] commit name ) { this . commit name = commit name ; }
public database get database ( ) { return database ; }
public request < ? > get request ( ) { return request ; }
public string get event ( ) { return event ; }
public void set session ( session session ) { this . session = session ; }
protect string get client thread name ( socket socket ) { return string . format ( `` logback socket node ( client : % s ) `` , socket . get remote socket address ( ) ) ; }
public void set dir ( file directory ) { this . directory = directory ; }
